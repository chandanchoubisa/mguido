ceptionBlock);
                            currentExceptionBlock = block;
                        }
                        else if (blockAction === 1) {
                            currentExceptionBlock = exceptionBlockStack.pop();
                        }
                    }
                    else if (isWithBlock(block)) {
                        if (blockAction === 0) {
                            if (!withBlockStack) {
                                withBlockStack = [];
                            }
                            withBlockStack.push(block);
                        }
                        else if (blockAction === 1) {
                            withBlockStack.pop();
                        }
                    }
                }
            }
        }
        function writeOperation(operationIndex) {
            tryEnterLabel(operationIndex);
            tryEnterOrLeaveBlock(operationIndex);
            if (lastOperationWasAbrupt) {
                return;
            }
            lastOperationWasAbrupt = false;
            lastOperationWasCompletion = false;
            var opcode = operations[operationIndex];
            if (opcode === 0) {
                return;
            }
            else if (opcode === 10) {
                return writeEndfinally();
            }
            var args = operationArguments[operationIndex];
            if (opcode === 1) {
                return writeStatement(args[0]);
            }
            var location = operationLocations[operationIndex];
            switch (opcode) {
                case 2:
                    return writeAssign(args[0], args[1], location);
                case 3:
                    return writeBreak(args[0], location);
                case 4:
                    return writeBreakWhenTrue(args[0], args[1], location);
                case 5:
                    return writeBreakWhenFalse(args[0], args[1], location);
                case 6:
                    return writeYield(args[0], location);
                case 7:
                    return writeYieldStar(args[0], location);
                case 8:
                    return writeReturn(args[0], location);
                case 9:
                    return writeThrow(args[0], location);
            }
        }
        function writeStatement(statement) {
            if (statement) {
                if (!statements) {
                    statements = [statement];
                }
                else {
                    statements.push(statement);
                }
            }
        }
        function writeAssign(left, right, operationLocation) {
            writeStatement(ts.setTextRange(ts.createStatement(ts.createAssignment(left, right)), operationLocation));
        }
        function writeThrow(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            lastOperationWasCompletion = true;
            writeStatement(ts.setTextRange(ts.createThrow(expression), operationLocation));
        }
        function writeReturn(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            lastOperationWasCompletion = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(ts.createReturn(ts.createArrayLiteral(expression
                ? [createInstruction(2), expression]
                : [createInstruction(2)])), operationLocation), 384));
        }
        function writeBreak(label, operationLocation) {
            lastOperationWasAbrupt = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(ts.createReturn(ts.createArrayLiteral([
                createInstruction(3),
                createLabel(label)
            ])), operationLocation), 384));
        }
        function writeBreakWhenTrue(label, condition, operationLocation) {
            writeStatement(ts.setEmitFlags(ts.createIf(condition, ts.setEmitFlags(ts.setTextRange(ts.createReturn(ts.createArrayLiteral([
                createInstruction(3),
                createLabel(label)
            ])), operationLocation), 384)), 1));
        }
        function writeBreakWhenFalse(label, condition, operationLocation) {
            writeStatement(ts.setEmitFlags(ts.createIf(ts.createLogicalNot(condition), ts.setEmitFlags(ts.setTextRange(ts.createReturn(ts.createArrayLiteral([
                createInstruction(3),
                createLabel(label)
            ])), operationLocation), 384)), 1));
        }
        function writeYield(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(ts.createReturn(ts.createArrayLiteral(expression
                ? [createInstruction(4), expression]
                : [createInstruction(4)])), operationLocation), 384));
        }
        function writeYieldStar(expression, operationLocation) {
            lastOperationWasAbrupt = true;
            writeStatement(ts.setEmitFlags(ts.setTextRange(ts.createReturn(ts.createArrayLiteral([
                createInstruction(5),
                expression
            ])), operationLocation), 384));
        }
        function writeEndfinally() {
            lastOperationWasAbrupt = true;
            writeStatement(ts.createReturn(ts.createArrayLiteral([
                createInstruction(7)
            ])));
        }
    }
    ts.transformGenerators = transformGenerators;
    function createGeneratorHelper(context, body) {
        context.requestEmitHelper(generatorHelper);
        return ts.createCall(ts.getHelperName("__generator"), undefined, [ts.createThis(), body]);
    }
    var generatorHelper = {
        name: "typescript:generator",
        scoped: false,
        priority: 6,
        text: "\n            var __generator = (this && this.__generator) || function (thisArg, body) {\n                var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n                return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n                function verb(n) { return function (v) { return step([n, v]); }; }\n                function step(op) {\n                    if (f) throw new TypeError(\"Generator is already executing.\");\n                    while (_) try {\n                        if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n                        if (y = 0, t) op = [0, t.value];\n                        switch (op[0]) {\n                            case 0: case 1: t = op; break;\n                            case 4: _.label++; return { value: op[1], done: false };\n                            case 5: _.label++; y = op[1]; op = [0]; continue;\n                            case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                            default:\n                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                                if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                                if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                                if (t[2]) _.ops.pop();\n                                _.trys.pop(); continue;\n                        }\n                        op = body.call(thisArg, _);\n                    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n                    if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n                }\n            };"
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformES5(context) {
        var compilerOptions = context.getCompilerOptions();
        var previousOnEmitNode;
        var noSubstitution;
        if (compilerOptions.jsx === 1 || compilerOptions.jsx === 3) {
            previousOnEmitNode = context.onEmitNode;
           