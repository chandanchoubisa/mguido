ArrayTypeMapper(sources, targets) {
            return function (t) {
                for (var i = 0; i < sources.length; i++) {
                    if (t === sources[i]) {
                        return targets ? targets[i] : anyType;
                    }
                }
                return t;
            };
        }
        function createTypeMapper(sources, targets) {
            var mapper = sources.length === 1 ? makeUnaryTypeMapper(sources[0], targets ? targets[0] : anyType) :
                sources.length === 2 ? makeBinaryTypeMapper(sources[0], targets ? targets[0] : anyType, sources[1], targets ? targets[1] : anyType) :
                    makeArrayTypeMapper(sources, targets);
            mapper.mappedTypes = sources;
            return mapper;
        }
        function createTypeEraser(sources) {
            return createTypeMapper(sources, undefined);
        }
        function createBackreferenceMapper(typeParameters, index) {
            var mapper = function (t) { return ts.indexOf(typeParameters, t) >= index ? emptyObjectType : t; };
            mapper.mappedTypes = typeParameters;
            return mapper;
        }
        function getInferenceMapper(context) {
            if (!context.mapper) {
                var mapper = function (t) {
                    var typeParameters = context.signature.typeParameters;
                    for (var i = 0; i < typeParameters.length; i++) {
                        if (t === typeParameters[i]) {
                            context.inferences[i].isFixed = true;
                            return getInferredType(context, i);
                        }
                    }
                    return t;
                };
                mapper.mappedTypes = context.signature.typeParameters;
                mapper.context = context;
                context.mapper = mapper;
            }
            return context.mapper;
        }
        function identityMapper(type) {
            return type;
        }
        function combineTypeMappers(mapper1, mapper2) {
            var mapper = function (t) { return instantiateType(mapper1(t), mapper2); };
            mapper.mappedTypes = ts.concatenate(mapper1.mappedTypes, mapper2.mappedTypes);
            return mapper;
        }
        function createReplacementMapper(source, target, baseMapper) {
            var mapper = function (t) { return t === source ? target : baseMapper(t); };
            mapper.mappedTypes = baseMapper.mappedTypes;
            return mapper;
        }
        function cloneTypeParameter(typeParameter) {
            var result = createType(16384);
            result.symbol = typeParameter.symbol;
            result.target = typeParameter;
            return result;
        }
        function cloneTypePredicate(predicate, mapper) {
            if (ts.isIdentifierTypePredicate(predicate)) {
                return {
                    kind: 1,
                    parameterName: predicate.parameterName,
                    parameterIndex: predicate.parameterIndex,
                    type: instantiateType(predicate.type, mapper)
                };
            }
            else {
                return {
                    kind: 0,
                    type: instantiateType(predicate.type, mapper)
                };
            }
        }
        function instantiateSignature(signature, mapper, eraseTypeParameters) {
            var freshTypeParameters;
            var freshTypePredicate;
            if (signature.typeParameters && !eraseTypeParameters) {
                freshTypeParameters = ts.map(signature.typeParameters, cloneTypeParameter);
                mapper = combineTypeMappers(createTypeMapper(signature.typeParameters, freshTypeParameters), mapper);
                for (var _i = 0, freshTypeParameters_1 = freshTypeParameters; _i < freshTypeParameters_1.length; _i++) {
                    var tp = freshTypeParameters_1[_i];
                    tp.mapper = mapper;
                }
            }
            if (signature.typePredicate) {
                freshTypePredicate = cloneTypePredicate(signature.typePredicate, mapper);
            }
            var result = createSignature(signature.declaration, freshTypeParameters, signature.thisParameter && instantiateSymbol(signature.thisParameter, mapper), instantiateList(signature.parameters, mapper, instantiateSymbol), instantiateType(signature.resolvedReturnType, mapper), freshTypePredicate, signature.minArgumentCount, signature.hasRestParameter, signature.hasLiteralTypes);
            result.target = signature;
            result.mapper = mapper;
            return result;
        }
        function instantiateSymbol(symbol, mapper) {
            if (getCheckFlags(symbol) & 1) {
                var links = getSymbolLinks(symbol);
                symbol = links.target;
                mapper = combineTypeMappers(links.mapper, mapper);
            }
            var result = createSymbol(symbol.flags, symbol.name);
            result.checkFlags = 1;
            result.declarations = symbol.declarations;
            result.parent = symbol.parent;
            result.target = symbol;
            result.mapper = mapper;
            if (symbol.valueDeclaration) {
                result.valueDeclaration = symbol.valueDeclaration;
            }
            return result;
        }
        function instantiateAnonymousType(type, mapper) {
            var result = createObjectType(16 | 64, type.symbol);
            result.target = type.objectFlags & 64 ? type.target : type;
            result.mapper = type.objectFlags & 64 ? combineTypeMappers(type.mapper, mapper) : mapper;
            result.aliasSymbol = type.aliasSymbol;
            result.aliasTypeArguments = instantiateTypes(type.aliasTypeArguments, mapper);
            return result;
        }
        function instantiateMappedType(type, mapper) {
            var constraintType = getConstraintTypeFromMappedType(type);
            if (constraintType.flags & 262144) {
                var typeVariable_1 = constraintType.type;
                if (typeVariable_1.flags & 16384) {
                    var mappedTypeVariable = instantiateType(typeVariable_1, mapper);
                    if (typeVariable_1 !== mappedTypeVariable) {
                        return mapType(mappedTypeVariable, function (t) {
                            if (isMappableType(t)) {
                                return instantiateMappedObjectType(type, createReplacementMapper(typeVariable_1, t, mapper));
                            }
                            return t;
                        });
                    }
                }
            }
            return instantiateMappedObjectType(type, mapper);
        }
        function isMappableType(type) {
            return type.flags & (16384 | 32768 | 131072 | 524288);
        }
        function instantiateMappedObjectType(type, mapper) {
            var result = createObjectType(32 | 64, type.symbol);
            result.declaration = type.declaration;
            result.mapper = type.mapper ? combineTypeMappers(type.mapper, mapper) : mapper;
            result.aliasSymbol = type.aliasSymbol;
            result.aliasTypeArguments = instantiateTypes(type.aliasTypeArguments, mapper);
            return result;
        }
        function isSymbolInScopeOfMappedTypeParameter(symbol, mapper) {
            if (!(symbol.declarations && symbol.declarations.length)) {
                return false;
            }
            var mappedTypes = mapper.mappedTypes;
            return !!ts.findAncestor(symbol.declarations[0], function (node) {
                if (node.kind === 233 || node.kind === 265) {
                    return "quit";
                }
                switch (node.kind) {
                    case 160:
                    case 161:
                    case 228:
                    case 151:
                    case 150:
                    case 152:
                    case 155:
                    case 156:
                    case 157:
                    case 153:
                    case 154:
                    case 186:
                    case 187:
                    case 229:
                    case 199:
                    case 230:
                    case 231:
                        var declaration = node;
                        if (declaration.typeParameters) {
                            for (var _i = 0, _a = declaration.typeParameters; _i < _a.length; _i++) {
                                var d = _a[_i];
                                if (ts.contains(mappedTypes, getDeclaredTypeOfTypeParameter(getSymbolOfNode(d)))) {
                                    return true;
                                }
                            }
                        }
                        if (ts.isClassLike(node) || node.kind === 230) {
                            var thisType = getDeclaredTypeOfClassOrInterface(getSymbolOfNode(node)).thisType;
                            if (thisType && ts.contains(mappedTypes, thisType)) {
                                return true;
                            }
                        }
                        break;
                    case 172:
                        if (ts.contains(mappedTypes, getDeclaredTypeOfTypeParameter(getSymbolOfNode(node.typeParameter)))) {
                            return true;
                        }
                        break;
                    case 279:
                        var func = node;
                        for (var _b = 0, _c = func.parameters; _b < _c.length; _b++) {
                            var p = _c[_b];
                            if (ts.contains(mappedTypes, getTypeOfNode(p))) {
                                return true;
                            }
                        }
                        break;
                }
            });
        }
        function isTopLevelTypeAlias(symbol) {
            if (symbol.declarations && symbol.declarations.length) {
                var parentKind = symbol.declarations[0].parent.kind;
                return parentKind === 265 || parentKind === 234;
            }
            return false;
        }
        function instantiateType(type, mapper) {
            if (type && mapper !== identityMapper) {
                if (type.aliasSymbol && isTopLevelTypeAlias(type.aliasSymbol)) {
                    if (type.aliasTypeArguments) {
                        return getTypeAliasInstantiation(type.aliasSymbol, instantiateTypes(type.aliasTypeArguments, mapper));
                    }
                    return type;
                }
                return instantiateTypeNoAlias(type, mapper);
            }
            return type;
        }
        function instantiateTypeNoAlias(type, mapper) {
            if (type.flags & 16384) {
                return mapper(type);
            }
            if (type.flags & 32768) {
                if (type.objectFlags & 16) {
                    return type.symbol &&
                        type.symbol.flags & (16 | 8192 | 32 | 2048 | 4096) &&
                        (type.objectFlags & 64 || isSymbolInScopeOfMappedTypeParameter(type.symbol, mapper)) ?
                        instantiateCached(type, mapper, instantiateAnonymousType) : type;
                }
                if (type.objectFlags & 32) {
                    return instantiateCached(type, mapper, instantiateMappedType);
                }
                if (type.objectFlags & 4) {
                    return createTypeReference(type.target, instantiateTypes(type.typeArguments, mapper));
                }
            }
            if (type.flags & 65536 && !(type.flags & 8190)) {
                return getUnionType(instantiateTypes(type.types, mapper), false, type.aliasSymbol, instantiateTypes(type.aliasTypeArguments, mapper));
            }
            if (type.flags & 131072) {
                return getIntersectionType(instantiateTypes(type.types, mapper), type.aliasSymbol, instantiateTypes(type.aliasTypeArguments, mapper));
            }
            if (type.flags & 262144) {
                return getIndexType(instantiateType(type.type, mapper));
            }
            if (type.flags & 524288) {
                return getIndexedAccessType(instantiateType(type.objectType, mapper), instantiateType(type.indexType, mapper));
            }
            return type;
        }
        function instantiateIndexInfo(info, mapper) {
            return info && createIndexInfo(instantiateType(info.type, mapper), info.isReadonly, info.declaration);
        }
        function isContextSensitive(node) {
            ts.Debug.assert(node.kind !== 151 || ts.isObjectLiteralMethod(node));
            switch (node.kind) {
                case 186:
                case 187:
                    return isContextSensitiveFunctionLikeDeclaration(node);
                case 178:
                    return ts.forEach(node.properties, isContextSensitive);
                case 177:
                    return ts.forEach(node.elements, isContextSensitive);
                case 195:
                    return isContextSensitive(node.whenTrue) ||
                        isContextSensitive(node.whenFalse);
                case 194:
                    return node.operatorToken.kind === 54 &&
                        (isContextSensitive(node.left) || isContextSensitive(node.right));
                case 261:
                    return isContextSensitive(node.initializer);
                case 151:
                case 150:
                    return isContextSensitiveFunctionLikeDeclaration(node);
                case 185:
                    return isContextSensitive(node.expression);
                case 254:
                    return ts.forEach(node.properties, isContextSensitive);
                case 253:
                    return node.initializer && isContextSensitive(node.initializer);
                case 256:
                    return node.expression && isContextSensitive(node.expression);
            }
            return false;
        }
        function isContextSensitiveFunctionLikeDeclaration(node) {
            if (node.typeParameters) {
                return false;
            }
            if (ts.forEach(node.parameters, function (p) { return !p.type; })) {
                return true;
            }
            if (node.kind === 187) {
                return false;
            }
            var parameter = ts.firstOrUndefined(node.parameters);
            return !(parameter && ts.parameterIsThisKeyword(parameter));
        }
        function isContextSensitiveFunctionOrObjectLiteralMethod(func) {
            return (isFunctionExpressionOrArrowFunction(func) || ts.isObjectLiteralMethod(func)) && isContextSensitiveFunctionLikeDeclaration(func);
        }
        function getTypeWithoutSignatures(type) {
            if (type.flags & 32768) {
                var resolved = resolveStructuredTypeMembers(type);
                if (resolved.constructSignatures.length) {
                    var result = createObjectType(16, type.symbol);
                    result.members = resolved.members;
                    result.properties = resolved.properties;
                    result.callSignatures = emptyArray;
                    result.constructSignatures = emptyArray;
                    return result;
                }
            }
            else if (type.flags & 131072) {
                return getIntersectionType(ts.map(type.types, getTypeWithoutSignatures));
            }
            return type;
        }
        function isTypeIdenticalTo(source, target) {
            return isTypeRelatedTo(source, target, identityRelation);
        }
        function compareTypesIdentical(source, target) {
            return isTypeRelatedTo(source, target, identityRelation) ? -1 : 0;
        }
        function compareTypesAssignable(source, target) {
            return isTypeRelatedTo(source, target, assignableRelation) ? -1 : 0;
        }
        function isTypeSubtypeOf(source, target) {
            return isTypeRelatedTo(source, target, subtypeRelation);
        }
        function isTypeAssignableTo(source, target) {
            return isTypeRelatedTo(source, target, assignableRelation);
        }
        function isTypeInstanceOf(source, target) {
            return getTargetType(source) === getTargetType(target) || isTypeSubtypeOf(source, target) && !isTypeIdenticalTo(source, target);
        }
        function isTypeComparableTo(source, target) {
            return isTypeRelatedTo(source, target, comparableRelation);
        }
        function areTypesComparable(type1, type2) {
            return isTypeComparableTo(type1, type2) || isTypeComparableTo(type2, type1);
        }
        function checkTypeSubtypeOf(source, target, errorNode, headMessage, containingMessageChain) {
            return checkTypeRelatedTo(source, target, subtypeRelation, errorNode, headMessage, containingMessageChain);
        }
        function checkTypeAssignableTo(source, target, errorNode, headMessage, containingMessageChain) {
            return checkTypeRelatedTo(source, target, assignableRelation, errorNode, headMessage, containingMessageChain);
        }
        function checkTypeComparableTo(source, target, errorNode, headMessage, containingMessageChain) {
            return checkTypeRelatedTo(source, target, comparableRelation, errorNode, headMessage, containingMessageChain);
        }
        function isSignatureAssignableTo(source, target, ignoreReturnTypes) {
            return compareSignaturesRelated(source, target, ignoreReturnTypes, false, undefined, compareTypesAssignable) !== 0;
        }
        function compareSignaturesRelated(source, target, ignoreReturnTypes, reportErrors, errorReporter, compareTypes) {
            if (source === target) {
                return -1;
            }
            if (!target.hasRestParameter && source.minArgumentCount > target.parameters.length) {
                return 0;
            }
            source = getErasedSignature(source);
            target = getErasedSignature(target);
            var result = -1;
            var sourceThisType = getThisTypeOfSignature(source);
            if (sourceThisType && sourceThisType !== voidType) {
                var targetThisType = getThisTypeOfSignature(target);
                if (targetThisType) {
                    var related = compareTypes(sourceThisType, targetThisType, false)
                        || compareTypes(targetThisType, sourceThisType, reportErrors);
                    if (!related) {
                        if (reportErrors) {
                            errorReporter(ts.Diagnostics.The_this_types_of_each_signature_are_incompatible);
                        }
                        return 0;
                    }
                    result &= related;
                }
            }
            var sourceMax = getNumNonRestParameters(source);
            var targetMax = getNumNonRestParameters(target);
            var checkCount = getNumParametersToCheckForSignatureRelatability(source, sourceMax, target, targetMax);
            var sourceParams = source.parameters;
            var targetParams = target.parameters;
            for (var i = 0; i < checkCount; i++) {
                var s = i < sourceMax ? getTypeOfParameter(sourceParams[i]) : getRestTypeOfSignature(source);
                var t = i < targetMax ? getTypeOfParameter(targetParams[i]) : getRestTypeOfSignature(target);
                var related = compareTypes(s, t, false) || compareTypes(t, s, reportErrors);
                if (!related) {
                    if (reportErrors) {
                        errorReporter(ts.Diagnostics.Types_of_parameters_0_and_1_are_incompatible, sourceParams[i < sourceMax ? i : sourceMax].name, targetParams[i < targetMax ? i : targetMax].name);
                    }
                    return 0;
                }
                result &= related;
            }
            if (!ignoreReturnTypes) {
                var targetReturnType = getReturnTypeOfSignature(target);
                if (targetReturnType === voidType) {
                    return result;
                }
                var sourceReturnType = getReturnTypeOfSignature(source);
                if (target.typePredicate) {
                    if (source.typePredicate) {
                        result &= compareTypePredicateRelatedTo(source.typePredicate, target.typePredicate, reportErrors, errorReporter, compareTypes);
                    }
                    else if (ts.isIdentifierTypePredicate(target.typePredicate)) {
                        if (reportErrors) {
                            errorReporter(ts.Diagnostics.Signature_0_must_have_a_type_predicate, signatureToString(source));
                        }
                        return 0;
                    }
                }
                else {
                    result &= compareTypes(sourceReturnType, targetReturnType, reportErrors);
                }
            }
            return result;
        }
        function compareTypePredicateRelatedTo(source, target, reportErrors, errorReporter, compareTypes) {
            if (source.kind !== target.kind) {
                if (reportErrors) {
                    errorReporter(ts.Diagnostics.A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard);
                    errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
                }
                return 0;
            }
            if (source.kind === 1) {
                var sourceIdentifierPredicate = source;
                var targetIdentifierPredicate = target;
                if (sourceIdentifierPredicate.parameterIndex !== targetIdentifierPredicate.parameterIndex) {
                    if (reportErrors) {
                        errorReporter(ts.Diagnostics.Parameter_0_is_not_in_the_same_position_as_parameter_1, sourceIdentifierPredicate.parameterName, targetIdentifierPredicate.parameterName);
                        errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
                    }
                    return 0;
                }
            }
            var related = compareTypes(source.type, target.type, reportErrors);
            if (related === 0 && reportErrors) {
                errorReporter(ts.Diagnostics.Type_predicate_0_is_not_assignable_to_1, typePredicateToString(source), typePredicateToString(target));
            }
            return related;
        }
        function isImplementationCompatibleWithOverload(implementation, overload) {
            var erasedSource = getErasedSignature(implementation);
            var erasedTarget = getErasedSignature(overload);
            var sourceReturnType = getReturnTypeOfSignature(erasedSource);
            var targetReturnType = getReturnTypeOfSignature(erasedTarget);
            if (targetReturnType === voidType
                || isTypeRelatedTo(targetReturnType, sourceReturnType, assignableRelation)
                || isTypeRelatedTo(sourceReturnType, targetReturnType, assignableRelation)) {
                return isSignatureAssignableTo(erasedSource, erasedTarget, true);
            }
            return false;
        }
        function getNumNonRestParameters(signature) {
            var numParams = signature.parameters.length;
            return signature.hasRestParameter ?
                numParams - 1 :
                numParams;
        }
        function getNumParametersToCheckForSignatureRelatability(source, sourceNonRestParamCount, target, targetNonRestParamCount) {
            if (source.hasRestParameter === target.hasRestParameter) {
                if (source.hasRestParameter) {
                    return Math.max(sourceNonRestParamCount, targetNonRestParamCount) + 1;
                }
                else {
                    return Math.min(sourceNonRestParamCount, targetNonRestParamCount);
                }
            }
            else {
                return source.hasRestParameter ?
                    targetNonRestParamCount :
                    sourceNonRestParamCount;
            }
        }
        function isEmptyResolvedType(t) {
            return t.properties.length === 0 &&
                t.callSignatures.length === 0 &&
                t.constructSignatures.length === 0 &&
                !t.stringIndexInfo &&
                !t.numberIndexInfo;
        }
        function isEmptyObjectType(type) {
            return type.flags & 32768 ? isEmptyResolvedType(resolveStructuredTypeMembers(type)) :
                type.flags & 65536 ? ts.forEach(type.types, isEmptyObjectType) :
                    type.flags & 131072 ? !ts.forEach(type.types, function (t) { return !isEmptyObjectType(t); }) :
                        false;
        }
        function isEnumTypeRelatedTo(source, target, errorReporter) {
            if (source === target) {
                return true;
            }
            var id = source.id + "," + target.id;
            var relation = enumRelation.get(id);
            if (relation !== undefined) {
                return relation;
            }
            if (source.symbol.name !== target.symbol.name ||
                !(source.symbol.flags & 256) || !(target.symbol.flags & 256) ||
                (source.flags & 65536) !== (target.flags & 65536)) {
                enumRelation.set(id, false);
                return false;
            }
            var targetEnumType = getTypeOfSymbol(target.symbol);
            for (var _i = 0, _a = getPropertiesOfType(getTypeOfSymbol(source.symbol)); _i < _a.length; _i++) {
                var property = _a[_i];
                if (property.flags & 8) {
                    var targetProperty = getPropertyOfType(targetEnumType, property.name);
                    if (!targetProperty || !(targetProperty.flags & 8)) {
                        if (errorReporter) {
                            errorReporter(ts.Diagnostics.Property_0_is_missing_in_type_1, property.name, typeToString(target, undefined, 128));
                        }
                        enumRelation.set(id, false);
                        return false;
                    }
                }
            }
            enumRelation.set(id, true);
            return true;
        }
        function isSimpleTypeRelatedTo(source, target, relation, errorReporter) {
            if (target.flags & 8192)
                return false;
            if (target.flags & 1 || source.flags & 8192)
                return true;
            if (source.flags & 262178 && target.flags & 2)
                return true;
            if (source.flags & 340 && target.flags & 4)
                return true;
            if (source.flags & 136 && target.flags & 8)
                return true;
            if (source.flags & 256 && target.flags & 16 && source.baseType === target)
                return true;
            if (source.flags & 16 && target.flags & 16 && isEnumTypeRelatedTo(source, target, errorReporter))
                return true;
            if (source.flags & 2048 && (!strictNullChecks || target.flags & (2048 | 1024)))
                return true;
            if (source.flags & 4096 && (!strictNullChecks || target.flags & 4096))
                return true;
            if (source.flags & 32768 && target.flags & 16777216)
                return true;
            if (relation === assignableRelation || relation === comparableRelation) {
                if (source.flags & 1)
                    return true;
                if ((source.flags & 4 | source.flags & 64) && target.flags & 272)
                    return true;
                if (source.flags & 256 &&
                    target.flags & 256 &&
                    source.text === target.text &&
                    isEnumTypeRelatedTo(source.baseType, target.baseType, errorReporter)) {
                    return true;
                }
                if (source.flags & 256 &&
                    target.flags & 16 &&
                    isEnumTypeRelatedTo(target, source.baseType, errorReporter)) {
                    return true;
                }
            }
            return false;
        }
        function isTypeRelatedTo(source, target, relation) {
            if (source.flags & 96 && source.flags & 1048576) {
                source = source.regularType;
            }
            if (target.flags & 96 && target.flags & 1048576) {
                target = target.regularType;
            }
            if (source === target || relation !== identityRelation && isSimpleTypeRelatedTo(source, target, relation)) {
                return true;
            }
            if (source.flags & 32768 && target.flags & 32768) {
                var id = relation !== identityRelation || source.id < target.id ? source.id + "," + target.id : target.id + "," + source.id;
                var related = relation.get(id);
                if (related !== undefined) {
                    return related === 1;
                }
            }
            if (source.flags & 1032192 || target.flags & 1032192) {
                return checkTypeRelatedTo(source, target, relation, undefined);
            }
            return false;
        }
        function checkTypeRelatedTo(source, target, relation, errorNode, headMessage, containingMessageChain) {
            var errorInfo;
            var sourceStack;
            var targetStack;
            var maybeStack;
            var expandingFlags;
            var depth = 0;
            var overflow = false;
            ts.Debug.assert(relation !== identityRelation || !errorNode, "no error reporting in identity checking");
            var result = isRelatedTo(source, target, !!errorNode, headMessage);
            if (overflow) {
                error(errorNode, ts.Diagnostics.Excessive_stack_depth_comparing_types_0_and_1, typeToString(source), typeToString(target));
            }
            else if (errorInfo) {
                if (containingMessageChain) {
                    errorInfo = ts.concatenateDiagnosticMessageChains(containingMessageChain, errorInfo);
                }
                diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(errorNode, errorInfo));
            }
            return result !== 0;
            function reportError(message, arg0, arg1, arg2) {
                ts.Debug.assert(!!errorNode);
                errorInfo = ts.chainDiagnosticMessages(errorInfo, message, arg0, arg1, arg2);
            }
            function reportRelationError(message, source, target) {
                var sourceType = typeToString(source);
                var targetType = typeToString(target);
                if (sourceType === targetType) {
                    sourceType = typeToString(source, undefined, 128);
                    targetType = typeToString(target, undefined, 128);
                }
                if (!message) {
                    if (relation === comparableRelation) {
                        message = ts.Diagnostics.Type_0_is_not_comparable_to_type_1;
                    }
                    else if (sourceType === targetType) {
                        message = ts.Diagnostics.Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated;
                    }
                    else {
                        message = ts.Diagnostics.Type_0_is_not_assignable_to_type_1;
                    }
                }
                reportError(message, sourceType, targetType);
            }
            function tryElaborateErrorsForPrimitivesAndObjects(source, target) {
                var sourceType = typeToString(source);
                var targetType = typeToString(target);
                if ((globalStringType === source && stringType === target) ||
                    (globalNumberType === source && numberType === target) ||
                    (globalBooleanType === source && booleanType === target) ||
                    (getGlobalESSymbolType(false) === source && esSymbolType === target)) {
                    reportError(ts.Diagnostics._0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible, targetType, sourceType);
                }
            }
            function isUnionOrIntersectionTypeWithoutNullableConstituents(type) {
                if (!(type.flags & 196608)) {
                    return false;
                }
                var seenNonNullable = false;
                for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    if (t.flags & 6144) {
                        continue;
                    }
                    if (seenNonNullable) {
                        return true;
                    }
                    seenNonNullable = true;
                }
                return false;
            }
            function isRelatedTo(source, target, reportErrors, headMessage) {
                var result;
                if (source.flags & 96 && source.flags & 1048576) {
                    source = source.regularType;
                }
                if (target.flags & 96 && target.flags & 1048576) {
                    target = target.regularType;
                }
                if (source === target)
                    return -1;
                if (relation === identityRelation) {
                    return isIdenticalTo(source, target);
                }
                if (isSimpleTypeRelatedTo(source, target, relation, reportErrors ? reportError : undefined))
                    return -1;
                if (getObjectFlags(source) & 128 && source.flags & 1048576) {
                    if (hasExcessProperties(source, target, reportErrors)) {
                        if (reportErrors) {
                            reportRelationError(headMessage, source, target);
                        }
                        return 0;
                    }
                    if (isUnionOrIntersectionTypeWithoutNullableConstituents(target)) {
                        source = getRegularTypeOfObjectLiteral(source);
                    }
                }
                var saveErrorInfo = errorInfo;
                if (source.flags & 65536) {
                    if (relation === comparableRelation) {
                        result = someTypeRelatedToType(source, target, reportErrors && !(source.flags & 8190));
                    }
                    else {
                        result = eachTypeRelatedToType(source, target, reportErrors && !(source.flags & 8190));
                    }
                    if (result) {
                        return result;
                    }
                }
                else {
                    if (target.flags & 65536) {
                        if (result = typeRelatedToSomeType(source, target, reportErrors && !(source.flags & 8190) && !(target.flags & 8190))) {
                            return result;
                        }
                    }
                    else if (target.flags & 131072) {
                        if (result = typeRelatedToEachType(source, target, reportErrors)) {
                            return result;
                        }
                    }
                    else if (source.flags & 131072) {
                        if (result = someTypeRelatedToType(source, target, false)) {
                            return result;
                        }
                    }
                    if (source.flags & 1032192 || target.flags & 1032192) {
                        if (result = recursiveTypeRelatedTo(source, target, reportErrors)) {
                            errorInfo = saveErrorInfo;
                            return result;
                        }
                    }
                }
                if (reportErrors) {
                    if (source.flags & 32768 && target.flags & 8190) {
                        tryElaborateErrorsForPrimitivesAndObjects(source, target);
                    }
                    else if (source.symbol && source.flags & 32768 && globalObjectType === source) {
                        reportError(ts.Diagnostics.The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead);
                    }
                    reportRelationError(headMessage, source, target);
                }
                return 0;
            }
            function isIdenticalTo(source, target) {
                var result;
                if (source.flags & 32768 && target.flags & 32768) {
                    return recursiveTypeRelatedTo(source, target, false);
                }
                if (source.flags & 65536 && target.flags & 65536 ||
                    source.flags & 131072 && target.flags & 131072) {
                    if (result = eachTypeRelatedToSomeType(source, target)) {
                        if (result &= eachTypeRelatedToSomeType(target, source)) {
                            return result;
                        }
                    }
                }
                return 0;
            }
            function hasExcessProperties(source, target, reportErrors) {
                if (maybeTypeOfKind(target, 32768) && !(getObjectFlags(target) & 512)) {
                    var isComparingJsxAttributes = !!(source.flags & 33554432);
                    if ((relation === assignableRelation || relation === comparableRelation) &&
                        (isTypeSubsetOf(globalObjectType, target) || (!isComparingJsxAttributes && isEmptyObjectType(target)))) {
                        return false;
                    }
                    for (var _i = 0, _a = getPropertiesOfObjectType(source); _i < _a.length; _i++) {
                        var prop = _a[_i];
                        if (!isKnownProperty(target, prop.name, isComparingJsxAttributes)) {
                            if (reportErrors) {
                                ts.Debug.assert(!!errorNode);
                                if (ts.isJsxAttributes(errorNode) || ts.isJsxOpeningLikeElement(errorNode)) {
                                    reportError(ts.Diagnostics.Property_0_does_not_exist_on_type_1, symbolToString(prop), typeToString(target));
                                }
                                else {
                                    errorNode = prop.valueDeclaration;
                                    reportError(ts.Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(prop), typeToString(target));
                                }
                            }
                            return true;
                        }
                    }
                }
                return false;
            }
            function eachTypeRelatedToSomeType(source, target) {
                var result = -1;
                var sourceTypes = source.types;
                for (var _i = 0, sourceTypes_1 = sourceTypes; _i < sourceTypes_1.length; _i++) {
                    var sourceType = sourceTypes_1[_i];
                    var related = typeRelatedToSomeType(sourceType, target, false);
                    if (!related) {
                        return 0;
                    }
                    result &= related;
                }
                return result;
            }
            function typeRelatedToSomeType(source, target, reportErrors) {
                var targetTypes = target.types;
                if (target.flags & 65536 && containsType(targetTypes, source)) {
                    return -1;
                }
                for (var _i = 0, targetTypes_1 = targetTypes; _i < targetTypes_1.length; _i++) {
                    var type = targetTypes_1[_i];
                    var related = isRelatedTo(source, type, false);
                    if (related) {
                        return related;
                    }
                }
                if (reportErrors) {
                    var discriminantType = findMatchingDiscriminantType(source, target);
                    isRelatedTo(source, discriminantType || targetTypes[targetTypes.length - 1], true);
                }
                return 0;
            }
            function findMatchingDiscriminantType(source, target) {
                var sourceProperties = getPropertiesOfObjectType(source);
                if (sourceProperties) {
                    for (var _i = 0, sourceProperties_1 = sourceProperties; _i < sourceProperties_1.length; _i++) {
                        var sourceProperty = sourceProperties_1[_i];
                        if (isDiscriminantProperty(target, sourceProperty.name)) {
                            var sourceType = getTypeOfSymbol(sourceProperty);
                            for (var _a = 0, _b = target.types; _a < _b.length; _a++) {
                                var type = _b[_a];
                                var targetType = getTypeOfPropertyOfType(type, sourceProperty.name);
                                if (targetType && isRelatedTo(sourceType, targetType)) {
                                    return type;
                                }
                            }
                        }
                    }
                }
            }
            function typeRelatedToEachType(source, target, reportErrors) {
                var result = -1;
                var targetTypes = target.types;
                for (var _i = 0, targetTypes_2 = targetTypes; _i < targetTypes_2.length; _i++) {
                    var targetType = targetTypes_2[_i];
                    var related = isRelatedTo(source, targetType, reportErrors);
                    if (!related) {
                        return 0;
                    }
                    result &= related;
                }
                return result;
            }
            function someTypeRelatedToType(source, target, reportErrors) {
                var sourceTypes = source.types;
                if (source.flags & 65536 && containsType(sourceTypes, target)) {
                    return -1;
                }
                var len = sourceTypes.length;
                for (var i = 0; i < len; i++) {
                    var related = isRelatedTo(sourceTypes[i], target, reportErrors && i === len - 1);
                    if (related) {
                        return related;
                    }
                }
                return 0;
            }
            function eachTypeRelatedToType(source, target, reportErrors) {
                var result = -1;
                var sourceTypes = source.types;
                for (var _i = 0, sourceTypes_2 = sourceTypes; _i < sourceTypes_2.length; _i++) {
                    var sourceType = sourceTypes_2[_i];
                    var related = isRelatedTo(sourceType, target, reportErrors);
                    if (!related) {
                        return 0;
                    }
                    result &= related;
                }
                return result;
            }
            function typeArgumentsRelatedTo(source, target, reportErrors) {
                var sources = source.typeArguments || emptyArray;
                var targets = target.typeArguments || emptyArray;
                if (sources.length !== targets.length && relation === identityRelation) {
                    return 0;
                }
                var length = sources.length <= targets.length ? sources.length : targets.length;
                var result = -1;
                for (var i = 0; i < length; i++) {
                    var related = isRelatedTo(sources[i], targets[i], reportErrors);
                    if (!related) {
                        return 0;
                    }
                    result &= related;
                }
                return result;
            }
            function recursiveTypeRelatedTo(source, target, reportErrors) {
                if (overflow) {
                    return 0;
                }
                var id = relation !== identityRelation || source.id < target.id ? source.id + "," + target.id : target.id + "," + source.id;
                var related = relation.get(id);
                if (related !== undefined) {
                    if (reportErrors && related === 2) {
                        relation.set(id, 3);
                    }
                    else {
                        return related === 1 ? -1 : 0;
                    }
                }
                if (depth > 0) {
                    for (var i = 0; i < depth; i++) {
                        if (maybeStack[i].get(id)) {
                            return 1;
                        }
                    }
                    if (depth === 100) {
                        overflow = true;
                        return 0;
                    }
                }
                else {
                    sourceStack = [];
                    targetStack = [];
                    maybeStack = [];
                    expandingFlags = 0;
                }
                sourceStack[depth] = source;
                targetStack[depth] = target;
                maybeStack[depth] = ts.createMap();
                maybeStack[depth].set(id, 1);
                depth++;
                var saveExpandingFlags = expandingFlags;
                if (!(expandingFlags & 1) && isDeeplyNestedType(source, sourceStack, depth))
                    expandingFlags |= 1;
                if (!(expandingFlags & 2) && isDeeplyNestedType(target, targetStack, depth))
                    expandingFlags |= 2;
                var result = expandingFlags !== 3 ? structuredTypeRelatedTo(source, target, reportErrors) : 1;
                expandingFlags = saveExpandingFlags;
                depth--;
                if (result) {
                    var maybeCache = maybeStack[depth];
                    var destinationCache = (result === -1 || depth === 0) ? relation : maybeStack[depth - 1];
                    ts.copyEntries(maybeCache, destinationCache);
                }
                else {
                    relation.set(id, reportErrors ? 3 : 2);
                }
                return result;
            }
            function structuredTypeRelatedTo(source, target, reportErrors) {
                var result;
                var saveErrorInfo = errorInfo;
                if (target.flags & 16384) {
                    if (getObjectFlags(source) & 32 && getConstraintTypeFromMappedType(source) === getIndexType(target)) {
                        if (!source.declaration.questionToken) {
                            var templateType = getTemplateTypeFromMappedType(source);
                            var indexedAccessType = getIndexedAccessType(target, getTypeParameterFromMappedType(source));
                            if (result = isRelatedTo(templateType, indexedAccessType, reportErrors)) {
                                return result;
                            }
                        }
                    }
                }
                else if (target.flags & 262144) {
                    if (source.flags & 262144) {
                        if (result = isRelatedTo(target.type, source.type, false)) {
                            return result;
                        }
                    }
                    var constraint = getConstraintOfType(target.type);
                    if (constraint) {
                        if (result = isRelatedTo(source, getIndexType(constraint), reportErrors)) {
                            return result;
                        }
                    }
                }
                else if (target.flags & 524288) {
                    var constraint = getConstraintOfType(target);
                    if (constraint) {
                        if (result = isRelatedTo(source, constraint, reportErrors)) {
                            errorInfo = saveErrorInfo;
                            return result;
                        }
                    }
                }
                if (source.flags & 16384) {
                    if (getObjectFlags(target) & 32 && getConstraintTypeFromMappedType(target) === getIndexType(source)) {
                        var indexedAccessType = getIndexedAccessType(source, getTypeParameterFromMappedType(target));
                        var templateType = getTemplateTypeFromMappedType(target);
                        if (result = isRelatedTo(indexedAccessType, templateType, reportErrors)) {
                            errorInfo = saveErrorInfo;
                            return result;
                        }
                    }
                    else {
                        var constraint = getConstraintOfTypeParameter(source);
                        if (constraint || !(target.flags & 16777216)) {
                            if (!constraint || constraint.flags & 1) {
                                constraint = emptyObjectType;
                            }
                            constraint = getTypeWithThisArgument(constraint, source);
                            var reportConstraintErrors = reportErrors && constraint !== emptyObjectType;
                            if (result = isRelatedTo(constraint, target, reportConstraintErrors)) {
                                errorInfo = saveErrorInfo;
                                return result;
                            }
                        }
                    }
                }
                else if (source.flags & 524288) {
                    var constraint = getConstraintOfType(source);
                    if (constraint) {
                        if (result = isRelatedTo(constraint, target, reportErrors)) {
                            errorInfo = saveErrorInfo;
                            return result;
                        }
                    }
                    else if (target.flags & 524288 && source.indexType === target.indexType) {
                        if (result = isRelatedTo(source.objectType, target.objectType, reportErrors)) {
                            return result;
                        }
                    }
                }
                else {
                    if (getObjectFlags(source) & 4 && getObjectFlags(target) & 4 && source.target === target.target) {
                        if (result = typeArgumentsRelatedTo(source, target, reportErrors)) {
                            return result;
                        }
                    }
                    var sourceIsPrimitive = !!(source.flags & 8190);
                    if (relation !== identityRelation) {
                        source = getApparentType(source);
                    }
                    if (source.flags & (32768 | 131072) && target.flags & 32768) {
                        var reportStructuralErrors = reportErrors && errorInfo === saveErrorInfo && !sourceIsPrimitive;
                        if (isGenericMappedType(source) || isGenericMappedType(target)) {
                            result = mappedTypeRelatedTo(source, target, reportStructuralErrors);
                        }
                        else {
                            result = propertiesRelatedTo(source, target, reportStructuralErrors);
                            if (result) {
                                result &= signaturesRelatedTo(source, target, 0, reportStructuralErrors);
                                if (result) {
                                    result &= signaturesRelatedTo(source, target, 1, reportStructuralErrors);
                                    if (result) {
                                        result &= indexTypesRelatedTo(source, target, 0, sourceIsPrimitive, reportStructuralErrors);
                                        if (result) {
                                            result &= indexTypesRelatedTo(source, target, 1, sourceIsPrimitive, reportStructuralErrors);
                                        }
                                    }
                                }
                            }
                        }
                        if (result) {
                            errorInfo = saveErrorInfo;
                            return result;
                        }
                    }
                }
                return 0;
            }
            function mappedTypeRelatedTo(source, target, reportErrors) {
                if (isGenericMappedType(target)) {
                    if (isGenericMappedType(source)) {
                        var sourceReadonly = !!source.declaration.readonlyToken;
                        var sourceOptional = !!source.declaration.questionToken;
                        var targetReadonly = !!target.declaration.readonlyToken;
                        var targetOptional = !!target.declaration.questionToken;
                        var modifiersRelated = relation === identityRelation ?
                            sourceReadonly === targetReadonly && sourceOptional === targetOptional :
                            relation === comparableRelation || !sourceOptional || targetOptional;
                        if (modifiersRelated) {
                            var result_2;
                            if (result_2 = isRelatedTo(getConstraintTypeFromMappedType(target), getConstraintTypeFromMappedType(source), reportErrors)) {
                                var mapper = createTypeMapper([getTypeParameterFromMappedType(source)], [getTypeParameterFromMappedType(target)]);
                                return result_2 & isRelatedTo(instantiateType(getTemplateTypeFromMappedType(source), mapper), getTemplateTypeFromMappedType(target), reportErrors);
                            }
                        }
                    }
                    else if (target.declaration.questionToken && isEmptyObjectType(source)) {
                        return -1;
                    }
                }
                else if (relation !== identityRelation) {
                    var resolved = resolveStructuredTypeMembers(target);
                    if (isEmptyResolvedType(resolved) || resolved.stringIndexInfo && resolved.stringIndexInfo.type.flags & 1) {
                        return -1;
                    }
                }
                return 0;
            }
            function propertiesRelatedTo(source, target, reportErrors) {
                if (relation === identityRelation) {
                    return propertiesIdenticalTo(source, target);
                }
                var result = -1;
                var properties = getPropertiesOfObjectType(target);
                var requireOptionalProperties = relation === subtypeRelation && !(getObjectFlags(source) & 128);
                for (var _i = 0, properties_4 = properties; _i < properties_4.length; _i++) {
                    var targetProp = properties_4[_i];
                    var sourceProp = getPropertyOfType(source, targetProp.name);
                    if (sourceProp !== targetProp) {
                        if (!sourceProp) {
                            if (!(targetProp.flags & 67108864) || requireOptionalProperties) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_is_missing_in_type_1, symbolToString(targetProp), typeToString(source));
                                }
                                return 0;
                            }
                        }
                        else if (!(targetProp.flags & 16777216)) {
                            var sourcePropFlags = getDeclarationModifierFlagsFromSymbol(sourceProp);
                            var targetPropFlags = getDeclarationModifierFlagsFromSymbol(targetProp);
                            if (sourcePropFlags & 8 || targetPropFlags & 8) {
                                if (getCheckFlags(sourceProp) & 256) {
                                    if (reportErrors) {
                                        reportError(ts.Diagnostics.Property_0_has_conflicting_declarations_and_is_inaccessible_in_type_1, symbolToString(sourceProp), typeToString(source));
                                    }
                                    return 0;
                                }
                                if (sourceProp.valueDeclaration !== targetProp.valueDeclaration) {
                                    if (reportErrors) {
                                        if (sourcePropFlags & 8 && targetPropFlags & 8) {
                                            reportError(ts.Diagnostics.Types_have_separate_declarations_of_a_private_property_0, symbolToString(targetProp));
                                        }
                                        else {
                                            reportError(ts.Diagnostics.Property_0_is_private_in_type_1_but_not_in_type_2, symbolToString(targetProp), typeToString(sourcePropFlags & 8 ? source : target), typeToString(sourcePropFlags & 8 ? target : source));
                                        }
                                    }
                                    return 0;
                                }
                            }
                            else if (targetPropFlags & 16) {
                                if (!isValidOverrideOf(sourceProp, targetProp)) {
                                    if (reportErrors) {
                                        reportError(ts.Diagnostics.Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2, symbolToString(targetProp), typeToString(getDeclaringClass(sourceProp) || source), typeToString(getDeclaringClass(targetProp) || target));
                                    }
                                    return 0;
                                }
                            }
                            else if (sourcePropFlags & 16) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_is_protected_in_type_1_but_public_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                                }
                                return 0;
                            }
                            var related = isRelatedTo(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp), reportErrors);
                            if (!related) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Types_of_property_0_are_incompatible, symbolToString(targetProp));
                                }
                                return 0;
                            }
                            result &= related;
                            if (relation !== comparableRelation && sourceProp.flags & 67108864 && !(targetProp.flags & 67108864)) {
                                if (reportErrors) {
                                    reportError(ts.Diagnostics.Property_0_is_optional_in_type_1_but_required_in_type_2, symbolToString(targetProp), typeToString(source), typeToString(target));
                                }
                                return 0;
                            }
                        }
                    }
                }
                return result;
            }
            function propertiesIdenticalTo(source, target) {
                if (!(source.flags & 32768 && target.flags & 32768)) {
                    return 0;
                }
                var sourceProperties = getPropertiesOfObjectType(source);
                var targetProperties = getPropertiesOfObjectType(target);
                if (sourceProperties.length !== targetProperties.length) {
                    return 0;
                }
                var result = -1;
                for (var _i = 0, sourceProperties_2 = sourceProperties; _i < sourceProperties_2.length; _i++) {
                    var sourceProp = sourceProperties_2[_i];
                    var targetProp = getPropertyOfObjectType(target, sourceProp.name);
                    if (!targetProp) {
                        return 0;
                    }
                    var related = compareProperties(sourceProp, targetProp, isRelatedTo);
                    if (!related) {
                        return 0;
                    }
                    result &= related;
                }
                return result;
            }
            function signaturesRelatedTo(source, target, kind, reportErrors) {
                if (relation === identityRelation) {
                    return signaturesIdenticalTo(source, target, kind);
                }
                if (target === anyFunctionType || source === anyFunctionType) {
                    return -1;
                }
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                if (kind === 1 && sourceSignatures.length && targetSignatures.length) {
                    if (isAbstractConstructorType(source) && !isAbstractConstructorType(target)) {
                        if (reportErrors) {
                            reportError(ts.Diagnostics.Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type);
                        }
                        return 0;
                    }
                    if (!constructorVisibilitiesAreCompatible(sourceSignatures[0], targetSignatures[0], reportErrors)) {
                        return 0;
                    }
                }
                var result = -1;
                var saveErrorInfo = errorInfo;
                if (getObjectFlags(source) & 64 && getObjectFlags(target) & 64 && source.symbol === target.symbol) {
                    for (var i = 0; i < targetSignatures.length; i++) {
                        var related = signatureRelatedTo(sourceSignatures[i], targetSignatures[i], reportErrors);
                        if (!related) {
                            return 0;
                        }
                        result &= related;
                    }
                }
                else {
                    outer: for (var _i = 0, targetSignatures_1 = targetSignatures; _i < targetSignatures_1.length; _i++) {
                        var t = targetSignatures_1[_i];
                        var shouldElaborateErrors = reportErrors;
                        for (var _a = 0, sourceSignatures_1 = sourceSignatures; _a < sourceSignatures_1.length; _a++) {
                            var s = sourceSignatures_1[_a];
                            var related = signatureRelatedTo(s, t, shouldElaborateErrors);
                            if (related) {
                                result &= related;
                                errorInfo = saveErrorInfo;
                                continue outer;
                            }
                            shouldElaborateErrors = false;
                        }
                        if (shouldElaborateErrors) {
                            reportError(ts.Diagnostics.Type_0_provides_no_match_for_the_signature_1, typeToString(source), signatureToString(t, undefined, undefined, kind));
                        }
                        return 0;
                    }
                }
                return result;
            }
            function signatureRelatedTo(source, target, reportErrors) {
                return compareSignaturesRelated(source, target, false, reportErrors, reportError, isRelatedTo);
            }
            function signaturesIdenticalTo(source, target, kind) {
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                if (sourceSignatures.length !== targetSignatures.length) {
                    return 0;
                }
                var result = -1;
                for (var i = 0; i < sourceSignatures.length; i++) {
                    var related = compareSignaturesIdentical(sourceSignatures[i], targetSignatures[i], false, false, false, isRelatedTo);
                    if (!related) {
                        return 0;
                    }
                    result &= related;
                }
                return result;
            }
            function eachPropertyRelatedTo(source, target, kind, reportErrors) {
                var result = -1;
                for (var _i = 0, _a = getPropertiesOfObjectType(source); _i < _a.length; _i++) {
                    var prop = _a[_i];
                    if (kind === 0 || isNumericLiteralName(prop.name)) {
                        var related = isRelatedTo(getTypeOfSymbol(prop), target, reportErrors);
                        if (!related) {
                            if (reportErrors) {
                                reportError(ts.Diagnostics.Property_0_is_incompatible_with_index_signature, symbolToString(prop));
                            }
                            return 0;
                        }
                        result &= related;
                    }
                }
                return result;
            }
            function indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors) {
                var related = isRelatedTo(sourceInfo.type, targetInfo.type, reportErrors);
                if (!related && reportErrors) {
                    reportError(ts.Diagnostics.Index_signatures_are_incompatible);
                }
                return related;
            }
            function indexTypesRelatedTo(source, target, kind, sourceIsPrimitive, reportErrors) {
                if (relation === identityRelation) {
                    return indexTypesIdenticalTo(source, target, kind);
                }
                var targetInfo = getIndexInfoOfType(target, kind);
                if (!targetInfo || targetInfo.type.flags & 1 && !sourceIsPrimitive) {
                    return -1;
                }
                var sourceInfo = getIndexInfoOfType(source, kind) ||
                    kind === 1 && getIndexInfoOfType(source, 0);
                if (sourceInfo) {
                    return indexInfoRelatedTo(sourceInfo, targetInfo, reportErrors);
                }
                if (isObjectLiteralType(source)) {
                    var related = -1;
                    if (kind === 0) {
                        var sourceNumberInfo = getIndexInfoOfType(source, 1);
                        if (sourceNumberInfo) {
                            related = indexInfoRelatedTo(sourceNumberInfo, targetInfo, reportErrors);
                        }
                    }
                    if (related) {
                        related &= eachPropertyRelatedTo(source, targetInfo.type, kind, reportErrors);
                    }
                    return related;
                }
                if (reportErrors) {
                    reportError(ts.Diagnostics.Index_signature_is_missing_in_type_0, typeToString(source));
                }
                return 0;
            }
            function indexTypesIdenticalTo(source, target, indexKind) {
                var targetInfo = getIndexInfoOfType(target, indexKind);
                var sourceInfo = getIndexInfoOfType(source, indexKind);
                if (!sourceInfo && !targetInfo) {
                    return -1;
                }
                if (sourceInfo && targetInfo && sourceInfo.isReadonly === targetInfo.isReadonly) {
                    return isRelatedTo(sourceInfo.type, targetInfo.type);
                }
                return 0;
            }
            function constructorVisibilitiesAreCompatible(sourceSignature, targetSignature, reportErrors) {
                if (!sourceSignature.declaration || !targetSignature.declaration) {
                    return true;
                }
                var sourceAccessibility = ts.getModifierFlags(sourceSignature.declaration) & 24;
                var targetAccessibility = ts.getModifierFlags(targetSignature.declaration) & 24;
                if (targetAccessibility === 8) {
                    return true;
                }
                if (targetAccessibility === 16 && sourceAccessibility !== 8) {
                    return true;
                }
                if (targetAccessibility !== 16 && !sourceAccessibility) {
                    return true;
                }
                if (reportErrors) {
                    reportError(ts.Diagnostics.Cannot_assign_a_0_constructor_type_to_a_1_constructor_type, visibilityToString(sourceAccessibility), visibilityToString(targetAccessibility));
                }
                return false;
            }
        }
        function forEachProperty(prop, callback) {
            if (getCheckFlags(prop) & 6) {
                for (var _i = 0, _a = prop.containingType.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    var p = getPropertyOfType(t, prop.name);
                    var result = p && forEachProperty(p, callback);
                    if (result) {
                        return result;
                    }
                }
                return undefined;
            }
            return callback(prop);
        }
        function getDeclaringClass(prop) {
            return prop.parent && prop.parent.flags & 32 ? getDeclaredTypeOfSymbol(getParentOfSymbol(prop)) : undefined;
        }
        function isPropertyInClassDerivedFrom(prop, baseClass) {
            return forEachProperty(prop, function (sp) {
                var sourceClass = getDeclaringClass(sp);
                return sourceClass ? hasBaseType(sourceClass, baseClass) : false;
            });
        }
        function isValidOverrideOf(sourceProp, targetProp) {
            return !forEachProperty(targetProp, function (tp) { return getDeclarationModifierFlagsFromSymbol(tp) & 16 ?
                !isPropertyInClassDerivedFrom(sourceProp, getDeclaringClass(tp)) : false; });
        }
        function isClassDerivedFromDeclaringClasses(checkClass, prop) {
            return forEachProperty(prop, function (p) { return getDeclarationModifierFlagsFromSymbol(p) & 16 ?
                !hasBaseType(checkClass, getDeclaringClass(p)) : false; }) ? undefined : checkClass;
        }
        function isAbstractConstructorType(type) {
            if (getObjectFlags(type) & 16) {
                var symbol = type.symbol;
                if (symbol && symbol.flags & 32) {
                    var declaration = getClassLikeDeclarationOfSymbol(symbol);
                    if (declaration && ts.getModifierFlags(declaration) & 128) {
                        return true;
                    }
                }
            }
            return false;
        }
        function isDeeplyNestedType(type, stack, depth) {
            if (depth >= 5 && type.flags & 32768) {
                var symbol = type.symbol;
                if (symbol) {
                    var count = 0;
                    for (var i = 0; i < depth; i++) {
                        var t = stack[i];
                        if (t.flags & 32768 && t.symbol === symbol) {
                            count++;
                            if (count >= 5)
                                return true;
                        }
                    }
                }
            }
            return false;
        }
        function isPropertyIdenticalTo(sourceProp, targetProp) {
            return compareProperties(sourceProp, targetProp, compareTypesIdentical) !== 0;
        }
        function compareProperties(sourceProp, targetProp, compareTypes) {
            if (sourceProp === targetProp) {
                return -1;
            }
            var sourcePropAccessibility = getDeclarationModifierFlagsFromSymbol(sourceProp) & 24;
            var targetPropAccessibility = getDeclarationModifierFlagsFromSymbol(targetProp) & 24;
            if (sourcePropAccessibility !== targetPropAccessibility) {
                return 0;
            }
            if (sourcePropAccessibility) {
                if (getTargetSymbol(sourceProp) !== getTargetSymbol(targetProp)) {
                    return 0;
                }
            }
            else {
                if ((sourceProp.flags & 67108864) !== (targetProp.flags & 67108864)) {
                    return 0;
                }
            }
            if (isReadonlySymbol(sourceProp) !== isReadonlySymbol(targetProp)) {
                return 0;
            }
            return compareTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
        }
        function isMatchingSignature(source, target, partialMatch) {
            if (source.parameters.length === target.parameters.length &&
                source.minArgumentCount === target.minArgumentCount &&
                source.hasRestParameter === target.hasRestParameter) {
                return true;
            }
            var sourceRestCount = source.hasRestParameter ? 1 : 0;
            var targetRestCount = target.hasRestParameter ? 1 : 0;
            if (partialMatch && source.minArgumentCount <= target.minArgumentCount && (sourceRestCount > targetRestCount ||
                sourceRestCount === targetRestCount && source.parameters.length >= target.parameters.length)) {
                return true;
            }
            return false;
        }
        function compareSignaturesIdentical(source, target, partialMatch, ignoreThisTypes, ignoreReturnTypes, compareTypes) {
            if (source === target) {
                return -1;
            }
            if (!(isMatchingSignature(source, target, partialMatch))) {
                return 0;
            }
            if (ts.length(source.typeParameters) !== ts.length(target.typeParameters)) {
                return 0;
            }
            source = getErasedSignature(source);
            target = getErasedSignature(target);
            var result = -1;
            if (!ignoreThisTypes) {
                var sourceThisType = getThisTypeOfSignature(source);
                if (sourceThisType) {
                    var targetThisType = getThisTypeOfSignature(target);
                    if (targetThisType) {
                        var related = compareTypes(sourceThisType, targetThisType);
                        if (!related) {
                            return 0;
                        }
                        result &= related;
                    }
                }
            }
            var targetLen = target.parameters.length;
            for (var i = 0; i < targetLen; i++) {
                var s = isRestParameterIndex(source, i) ? getRestTypeOfSignature(source) : getTypeOfParameter(source.parameters[i]);
                var t = isRestParameterIndex(target, i) ? getRestTypeOfSignature(target) : getTypeOfParameter(target.parameters[i]);
                var related = compareTypes(s, t);
                if (!related) {
                    return 0;
                }
                result &= related;
            }
            if (!ignoreReturnTypes) {
                result &= compareTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
            }
            return result;
        }
        function isRestParameterIndex(signature, parameterIndex) {
            return signature.hasRestParameter && parameterIndex >= signature.parameters.length - 1;
        }
        function isSupertypeOfEach(candidate, types) {
            for (var _i = 0, types_10 = types; _i < types_10.length; _i++) {
                var t = types_10[_i];
                if (candidate !== t && !isTypeSubtypeOf(t, candidate))
                    return false;
            }
            return true;
        }
        function literalTypesWithSameBaseType(types) {
            var commonBaseType;
            for (var _i = 0, types_11 = types; _i < types_11.length; _i++) {
                var t = types_11[_i];
                var baseType = getBaseTypeOfLiteralType(t);
                if (!commonBaseType) {
                    commonBaseType = baseType;
                }
                if (baseType === t || baseType !== commonBaseType) {
                    return false;
                }
            }
            return true;
        }
        function getSupertypeOrUnion(types) {
            return literalTypesWithSameBaseType(types) ? getUnionType(types) : ts.forEach(types, function (t) { return isSupertypeOfEach(t, types) ? t : undefined; });
        }
        function getCommonSupertype(types) {
            if (!strictNullChecks) {
                return getSupertypeOrUnion(types);
            }
            var primaryTypes = ts.filter(types, function (t) { return !(t.flags & 6144); });
            if (!primaryTypes.length) {
                return getUnionType(types, true);
            }
            var supertype = getSupertypeOrUnion(primaryTypes);
            return supertype && includeFalsyTypes(supertype, getFalsyFlagsOfTypes(types) & 6144);
        }
        function reportNoCommonSupertypeError(types, errorLocation, errorMessageChainHead) {
            var bestSupertype;
            var bestSupertypeDownfallType;
            var bestSupertypeScore = 0;
            for (var i = 0; i < types.length; i++) {
                var score = 0;
                var downfallType = undefined;
                for (var j = 0; j < types.length; j++) {
                    if (isTypeSubtypeOf(types[j], types[i])) {
                        score++;
                    }
                    else if (!downfallType) {
                        downfallType = types[j];
                    }
                }
                ts.Debug.assert(!!downfallType, "If there is no common supertype, each type should have a downfallType");
                if (score > bestSupertypeScore) {
                    bestSupertype = types[i];
                    bestSupertypeDownfallType = downfallType;
                    bestSupertypeScore = score;
                }
                if (bestSupertypeScore === types.length - 1) {
                    break;
                }
            }
            checkTypeSubtypeOf(bestSupertypeDownfallType, bestSupertype, errorLocation, ts.Diagnostics.Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0, errorMessageChainHead);
        }
        function isArrayType(type) {
            return getObjectFlags(type) & 4 && type.target === globalArrayType;
        }
        function isArrayLikeType(type) {
            return getObjectFlags(type) & 4 && (type.target === globalArrayType || type.target === globalReadonlyArrayType) ||
                !(type.flags & 6144) && isTypeAssignableTo(type, anyReadonlyArrayType);
        }
        function isTupleLikeType(type) {
            return !!getPropertyOfType(type, "0");
        }
        function isUnitType(type) {
            return (type.flags & (480 | 2048 | 4096)) !== 0;
        }
        function isLiteralType(type) {
            return type.flags & 8 ? true :
                type.flags & 65536 ? type.flags & 16 ? true : !ts.forEach(type.types, function (t) { return !isUnitType(t); }) :
                    isUnitType(type);
        }
        function getBaseTypeOfLiteralType(type) {
            return type.flags & 32 ? stringType :
                type.flags & 64 ? numberType :
                    type.flags & 128 ? booleanType :
                        type.flags & 256 ? type.baseType :
                            type.flags & 65536 && !(type.flags & 16) ? getUnionType(ts.sameMap(type.types, getBaseTypeOfLiteralType)) :
                                type;
        }
        function getWidenedLiteralType(type) {
            return type.flags & 32 && type.flags & 1048576 ? stringType :
                type.flags & 64 && type.flags & 1048576 ? numberType :
                    type.flags & 128 ? booleanType :
                        type.flags & 256 ? type.baseType :
                            type.flags & 65536 && !(type.flags & 16) ? getUnionType(ts.sameMap(type.types, getWidenedLiteralType)) :
                                type;
        }
        function isTupleType(type) {
            return !!(getObjectFlags(type) & 4 && type.target.objectFlags & 8);
        }
        function getFalsyFlagsOfTypes(types) {
            var result = 0;
            for (var _i = 0, types_12 = types; _i < types_12.length; _i++) {
                var t = types_12[_i];
                result |= getFalsyFlags(t);
            }
            return result;
        }
        function getFalsyFlags(type) {
            return type.flags & 65536 ? getFalsyFlagsOfTypes(type.types) :
                type.flags & 32 ? type.text === "" ? 32 : 0 :
                    type.flags & 64 ? type.text === "0" ? 64 : 0 :
                        type.flags & 128 ? type === falseType ? 128 : 0 :
                            type.flags & 7406;
        }
        function includeFalsyTypes(type, flags) {
            if ((getFalsyFlags(type) & flags) === flags) {
                return type;
            }
            var types = [type];
            if (flags & 262178)
                types.push(emptyStringType);
            if (flags & 340)
                types.push(zeroType);
            if (flags & 136)
                types.push(falseType);
            if (flags & 1024)
                types.push(voidType);
            if (flags & 2048)
                types.push(undefinedType);
            if (flags & 4096)
                types.push(nullType);
            return getUnionType(types);
        }
        function removeDefinitelyFalsyTypes(type) {
            return getFalsyFlags(type) & 7392 ?
                filterType(type, function (t) { return !(getFalsyFlags(t) & 7392); }) :
                type;
        }
        function getNonNullableType(type) {
            return strictNullChecks ? getTypeWithFacts(type, 524288) : type;
        }
        function isObjectLiteralType(type) {
            return type.symbol && (type.symbol.flags & (4096 | 2048)) !== 0 &&
                getSignaturesOfType(type, 0).length === 0 &&
                getSignaturesOfType(type, 1).length === 0;
        }
        function createSymbolWithType(source, type) {
            var symbol = createSymbol(source.flags, source.name);
            symbol.declarations = source.declarations;
            symbol.parent = source.parent;
            symbol.type = type;
            symbol.target = source;
            if (source.valueDeclaration) {
                symbol.valueDeclaration = source.valueDeclaration;
            }
            return symbol;
        }
        function transformTypeOfMembers(type, f) {
            var members = ts.createMap();
            for (var _i = 0, _a = getPropertiesOfObjectType(type); _i < _a.length; _i++) {
                var property = _a[_i];
                var original = getTypeOfSymbol(property);
                var updated = f(original);
                members.set(property.name, updated === original ? property : createSymbolWithType(property, updated));
            }
            return members;
        }
        function getRegularTypeOfObjectLiteral(type) {
            if (!(getObjectFlags(type) & 128 && type.flags & 1048576)) {
                return type;
            }
            var regularType = type.regularType;
            if (regularType) {
                return regularType;
            }
            var resolved = type;
            var members = transformTypeOfMembers(type, getRegularTypeOfObjectLiteral);
            var regularNew = createAnonymousType(resolved.symbol, members, resolved.callSignatures, resolved.constructSignatures, resolved.stringIndexInfo, resolved.numberIndexInfo);
            regularNew.flags = resolved.flags & ~1048576;
            regularNew.objectFlags |= 128;
            type.regularType = regularNew;
            return regularNew;
        }
        function getWidenedProperty(prop) {
            var original = getTypeOfSymbol(prop);
            var widened = getWidenedType(original);
            return widened === original ? prop : createSymbolWithType(prop, widened);
        }
        function getWidenedTypeOfObjectLiteral(type) {
            var members = ts.createMap();
            for (var _i = 0, _a = getPropertiesOfObjectType(type); _i < _a.length; _i++) {
                var prop = _a[_i];
                members.set(prop.name, prop.flags & 4 ? getWidenedProperty(prop) : prop);
            }
            var stringIndexInfo = getIndexInfoOfType(type, 0);
            var numberIndexInfo = getIndexInfoOfType(type, 1);
            return createAnonymousType(type.symbol, members, emptyArray, emptyArray, stringIndexInfo && createIndexInfo(getWidenedType(stringIndexInfo.type), stringIndexInfo.isReadonly), numberIndexInfo && createIndexInfo(getWidenedType(numberIndexInfo.type), numberIndexInfo.isReadonly));
        }
        function getWidenedConstituentType(type) {
            return type.flags & 6144 ? type : getWidenedType(type);
        }
        function getWidenedType(type) {
            if (type.flags & 6291456) {
                if (type.flags & 6144) {
                    return anyType;
                }
                if (getObjectFlags(type) & 128) {
                    return getWidenedTypeOfObjectLiteral(type);
                }
                if (type.flags & 65536) {
                    return getUnionType(ts.sameMap(type.types, getWidenedConstituentType));
                }
                if (isArrayType(type) || isTupleType(type)) {
                    return createTypeReference(type.target, ts.sameMap(type.typeArguments, getWidenedType));
                }
            }
            return type;
        }
        function reportWideningErrorsInType(type) {
            var errorReported = false;
            if (type.flags & 65536) {
                for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    if (reportWideningErrorsInType(t)) {
                        errorReported = true;
                    }
                }
            }
            if (isArrayType(type) || isTupleType(type)) {
                for (var _b = 0, _c = type.typeArguments; _b < _c.length; _b++) {
                    var t = _c[_b];
                    if (reportWideningErrorsInType(t)) {
                        errorReported = true;
                    }
                }
            }
            if (getObjectFlags(type) & 128) {
                for (var _d = 0, _e = getPropertiesOfObjectType(type); _d < _e.length; _d++) {
                    var p = _e[_d];
                    var t = getTypeOfSymbol(p);
                    if (t.flags & 2097152) {
                        if (!reportWideningErrorsInType(t)) {
                            error(p.valueDeclaration, ts.Diagnostics.Object_literal_s_property_0_implicitly_has_an_1_type, p.name, typeToString(getWidenedType(t)));
                        }
                        errorReported = true;
                    }
                }
            }
            return errorReported;
        }
        function reportImplicitAnyError(declaration, type) {
            var typeAsString = typeToString(getWidenedType(type));
            var diagnostic;
            switch (declaration.kind) {
                case 149:
                case 148:
                    diagnostic = ts.Diagnostics.Member_0_implicitly_has_an_1_type;
                    break;
                case 146:
                    diagnostic = declaration.dotDotDotToken ?
                        ts.Diagnostics.Rest_parameter_0_implicitly_has_an_any_type :
                        ts.Diagnostics.Parameter_0_implicitly_has_an_1_type;
                    break;
                case 176:
                    diagnostic = ts.Diagnostics.Binding_element_0_implicitly_has_an_1_type;
                    break;
                case 228:
                case 151:
                case 150:
                case 153:
                case 154:
                case 186:
                case 187:
                    if (!declaration.name) {
                        error(declaration, ts.Diagnostics.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type, typeAsString);
                        return;
                    }
                    diagnostic = ts.Diagnostics._0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type;
                    break;
                default:
                    diagnostic = ts.Diagnostics.Variable_0_implicitly_has_an_1_type;
            }
            error(declaration, diagnostic, ts.declarationNameToString(ts.getNameOfDeclaration(declaration)), typeAsString);
        }
        function reportErrorsFromWidening(declaration, type) {
            if (produceDiagnostics && noImplicitAny && type.flags & 2097152) {
                if (!reportWideningErrorsInType(type)) {
                    reportImplicitAnyError(declaration, type);
                }
            }
        }
        function forEachMatchingParameterType(source, target, callback) {
            var sourceMax = source.parameters.length;
            var targetMax = target.parameters.length;
            var count;
            if (source.hasRestParameter && target.hasRestParameter) {
                count = Math.max(sourceMax, targetMax);
            }
            else if (source.hasRestParameter) {
                count = targetMax;
            }
            else if (target.hasRestParameter) {
                count = sourceMax;
            }
            else {
                count = Math.min(sourceMax, targetMax);
            }
            for (var i = 0; i < count; i++) {
                callback(getTypeAtPosition(source, i), getTypeAtPosition(target, i));
            }
        }
        function createInferenceContext(signature, inferUnionTypes, useAnyForNoInferences) {
            var inferences = ts.map(signature.typeParameters, createTypeInferencesObject);
            return {
                signature: signature,
                inferUnionTypes: inferUnionTypes,
                inferences: inferences,
                inferredTypes: new Array(signature.typeParameters.length),
                useAnyForNoInferences: useAnyForNoInferences
            };
        }
        function createTypeInferencesObject() {
            return {
                primary: undefined,
                secondary: undefined,
                topLevel: true,
                isFixed: false,
            };
        }
        function couldContainTypeVariables(type) {
            var objectFlags = getObjectFlags(type);
            return !!(type.flags & 540672 ||
                objectFlags & 4 && ts.forEach(type.typeArguments, couldContainTypeVariables) ||
                objectFlags & 16 && type.symbol && type.symbol.flags & (8192 | 2048 | 32) ||
                objectFlags & 32 ||
                type.flags & 196608 && couldUnionOrIntersectionContainTypeVariables(type));
        }
        function couldUnionOrIntersectionContainTypeVariables(type) {
            if (type.couldContainTypeVariables === undefined) {
                type.couldContainTypeVariables = ts.forEach(type.types, couldContainTypeVariables);
            }
            return type.couldContainTypeVariables;
        }
        function isTypeParameterAtTopLevel(type, typeParameter) {
            return type === typeParameter || type.flags & 196608 && ts.forEach(type.types, function (t) { return isTypeParameterAtTopLevel(t, typeParameter); });
        }
        function inferTypeForHomomorphicMappedType(source, target) {
            var properties = getPropertiesOfType(source);
            var indexInfo = getIndexInfoOfType(source, 0);
            if (properties.length === 0 && !indexInfo) {
                return undefined;
            }
            var typeVariable = getIndexedAccessType(getConstraintTypeFromMappedType(target).type, getTypeParameterFromMappedType(target));
            var typeVariableArray = [typeVariable];
            var typeInferences = createTypeInferencesObject();
            var typeInferencesArray = [typeInferences];
            var templateType = getTemplateTypeFromMappedType(target);
            var readonlyMask = target.declaration.readonlyToken ? false : true;
            var optionalMask = target.declaration.questionToken ? 0 : 67108864;
            var members = createSymbolTable(properties);
            for (var _i = 0, properties_5 = properties; _i < properties_5.length; _i++) {
                var prop = properties_5[_i];
                var inferredPropType = inferTargetType(getTypeOfSymbol(prop));
                if (!inferredPropType) {
                    return undefined;
                }
                var inferredProp = createSymbol(4 | prop.flags & optionalMask, prop.name);
                inferredProp.checkFlags = readonlyMask && isReadonlySymbol(prop) ? 8 : 0;
                inferredProp.declarations = prop.declarations;
                inferredProp.type = inferredPropType;
                members.set(prop.name, inferredProp);
            }
            if (indexInfo) {
                var inferredIndexType = inferTargetType(indexInfo.type);
                if (!inferredIndexType) {
                    return undefined;
                }
                indexInfo = createIndexInfo(inferredIndexType, readonlyMask && indexInfo.isReadonly);
            }
            return createAnonymousType(undefined, members, emptyArray, emptyArray, indexInfo, undefined);
            function inferTargetType(sourceType) {
                typeInferences.primary = undefined;
                typeInferences.secondary = undefined;
                inferTypes(typeVariableArray, typeInferencesArray, sourceType, templateType);
                var inferences = typeInferences.primary || typeInferences.secondary;
                return inferences && getUnionType(inferences, true);
            }
        }
        function inferTypesWithContext(context, originalSource, originalTarget) {
            inferTypes(context.signature.typeParameters, context.inferences, originalSource, originalTarget);
        }
        function inferTypes(typeVariables, typeInferences, originalSource, originalTarget) {
            var sourceStack;
            var targetStack;
            var depth = 0;
            var inferiority = 0;
            var visited = ts.createMap();
            inferFromTypes(originalSource, originalTarget);
            function isInProcess(source, target) {
                for (var i = 0; i < depth; i++) {
                    if (source === sourceStack[i] && target === targetStack[i]) {
                        return true;
                    }
                }
                return false;
            }
            function inferFromTypes(source, target) {
                if (!couldContainTypeVariables(target)) {
                    return;
                }
                if (source.aliasSymbol && source.aliasTypeArguments && source.aliasSymbol === target.aliasSymbol) {
                    var sourceTypes = source.aliasTypeArguments;
                    var targetTypes = target.aliasTypeArguments;
                    for (var i = 0; i < sourceTypes.length; i++) {
                        inferFromTypes(sourceTypes[i], targetTypes[i]);
                    }
                    return;
                }
                if (source.flags & 65536 && target.flags & 65536 && !(source.flags & 16 && target.flags & 16) ||
                    source.flags & 131072 && target.flags & 131072) {
                    if (source === target) {
                        for (var _i = 0, _a = source.types; _i < _a.length; _i++) {
                            var t = _a[_i];
                            inferFromTypes(t, t);
                        }
                        return;
                    }
                    var matchingTypes = void 0;
                    for (var _b = 0, _c = source.types; _b < _c.length; _b++) {
                        var t = _c[_b];
                        if (typeIdenticalToSomeType(t, target.types)) {
                            (matchingTypes || (matchingTypes = [])).push(t);
                            inferFromTypes(t, t);
                        }
                        else if (t.flags & (64 | 32)) {
                            var b = getBaseTypeOfLiteralType(t);
                            if (typeIdenticalToSomeType(b, target.types)) {
                                (matchingTypes || (matchingTypes = [])).push(t, b);
                            }
                        }
                    }
                    if (matchingTypes) {
                        source = removeTypesFromUnionOrIntersection(source, matchingTypes);
                        target = removeTypesFromUnionOrIntersection(target, matchingTypes);
                    }
                }
                if (target.flags & 540672) {
                    if (source.flags & 8388608) {
                        return;
                    }
                    for (var i = 0; i < typeVariables.length; i++) {
                        if (target === typeVariables[i]) {
                            var inferences = typeInferences[i];
                            if (!inferences.isFixed) {
                                var candidates = inferiority ?
                                    inferences.secondary || (inferences.secondary = []) :
                                    inferences.primary || (inferences.primary = []);
                                if (!ts.contains(candidates, source)) {
                                    candidates.push(source);
                                }
                                if (target.flags & 16384 && !isTypeParameterAtTopLevel(originalTarget, target)) {
                                    inferences.topLevel = false;
                                }
                            }
                            return;
                        }
                    }
                }
                else if (getObjectFlags(source) & 4 && getObjectFlags(target) & 4 && source.target === target.target) {
                    var sourceTypes = source.typeArguments || emptyArray;
                    var targetTypes = target.typeArguments || emptyArray;
                    var count = sourceTypes.length < targetTypes.length ? sourceTypes.length : targetTypes.length;
                    for (var i = 0; i < count; i++) {
                        inferFromTypes(sourceTypes[i], targetTypes[i]);
                    }
                }
                else if (target.flags & 196608) {
                    var targetTypes = target.types;
                    var typeVariableCount = 0;
                    var typeVariable = void 0;
                    for (var _d = 0, targetTypes_3 = targetTypes; _d < targetTypes_3.length; _d++) {
                        var t = targetTypes_3[_d];
                        if (t.flags & 540672 && ts.contains(typeVariables, t)) {
                            typeVariable = t;
                            typeVariableCount++;
                        }
                        else {
                            inferFromTypes(source, t);
                        }
                    }
                    if (typeVariableCount === 1) {
                        inferiority++;
                        inferFromTypes(source, typeVariable);
                        inferiority--;
                    }
                }
                else if (source.flags & 196608) {
                    var sourceTypes = source.types;
                    for (var _e = 0, sourceTypes_3 = sourceTypes; _e < sourceTypes_3.length; _e++) {
                        var sourceType = sourceTypes_3[_e];
                        inferFromTypes(sourceType, target);
                    }
                }
                else {
                    source = getApparentType(source);
                    if (source.flags & 32768) {
                        if (isInProcess(source, target)) {
                            return;
                        }
                        if (isDeeplyNestedType(source, sourceStack, depth) && isDeeplyNestedType(target, targetStack, depth)) {
                            return;
                        }
                        var key = source.id + "," + target.id;
                        if (visited.get(key)) {
                            return;
                        }
                        visited.set(key, true);
                        if (depth === 0) {
                            sourceStack = [];
                            targetStack = [];
                        }
                        sourceStack[depth] = source;
                        targetStack[depth] = target;
                        depth++;
                        inferFromObjectTypes(source, target);
                        depth--;
                    }
                }
            }
            function inferFromObjectTypes(source, target) {
                if (getObjectFlags(target) & 32) {
                    var constraintType = getConstraintTypeFromMappedType(target);
                    if (constraintType.flags & 262144) {
                        var index = ts.indexOf(typeVariables, constraintType.type);
                        if (index >= 0 && !typeInferences[index].isFixed) {
                            var inferredType = inferTypeForHomomorphicMappedType(source, target);
                            if (inferredType) {
                                inferiority++;
                                inferFromTypes(inferredType, typeVariables[index]);
                                inferiority--;
                            }
                        }
                        return;
                    }
                    if (constraintType.flags & 16384) {
                        inferFromTypes(getIndexType(source), constraintType);
                        inferFromTypes(getUnionType(ts.map(getPropertiesOfType(source), getTypeOfSymbol)), getTemplateTypeFromMappedType(target));
                        return;
                    }
                }
                inferFromProperties(source, target);
                inferFromSignatures(source, target, 0);
                inferFromSignatures(source, target, 1);
                inferFromIndexTypes(source, target);
            }
            function inferFromProperties(source, target) {
                var properties = getPropertiesOfObjectType(target);
                for (var _i = 0, properties_6 = properties; _i < properties_6.length; _i++) {
                    var targetProp = properties_6[_i];
                    var sourceProp = getPropertyOfObjectType(source, targetProp.name);
                    if (sourceProp) {
                        inferFromTypes(getTypeOfSymbol(sourceProp), getTypeOfSymbol(targetProp));
                    }
                }
            }
            function inferFromSignatures(source, target, kind) {
                var sourceSignatures = getSignaturesOfType(source, kind);
                var targetSignatures = getSignaturesOfType(target, kind);
                var sourceLen = sourceSignatures.length;
                var targetLen = targetSignatures.length;
                var len = sourceLen < targetLen ? sourceLen : targetLen;
                for (var i = 0; i < len; i++) {
                    inferFromSignature(getErasedSignature(sourceSignatures[sourceLen - len + i]), getErasedSignature(targetSignatures[targetLen - len + i]));
                }
            }
            function inferFromParameterTypes(source, target) {
                return inferFromTypes(source, target);
            }
            function inferFromSignature(source, target) {
                forEachMatchingParameterType(source, target, inferFromParameterTypes);
                if (source.typePredicate && target.typePredicate && source.typePredicate.kind === target.typePredicate.kind) {
                    inferFromTypes(source.typePredicate.type, target.typePredicate.type);
                }
                else {
                    inferFromTypes(getReturnTypeOfSignature(source), getReturnTypeOfSignature(target));
                }
            }
            function inferFromIndexTypes(source, target) {
                var targetStringIndexType = getIndexTypeOfType(target, 0);
                if (targetStringIndexType) {
                    var sourceIndexType = getIndexTypeOfType(source, 0) ||
                        getImplicitIndexTypeOfType(source, 0);
                    if (sourceIndexType) {
                        inferFromTypes(sourceIndexType, targetStringIndexType);
                    }
                }
                var targetNumberIndexType = getIndexTypeOfType(target, 1);
                if (targetNumberIndexType) {
                    var sourceIndexType = getIndexTypeOfType(source, 1) ||
                        getIndexTypeOfType(source, 0) ||
                        getImplicitIndexTypeOfType(source, 1);
                    if (sourceIndexType) {
                        inferFromTypes(sourceIndexType, targetNumberIndexType);
                    }
                }
            }
        }
        function typeIdenticalToSomeType(type, types) {
            for (var _i = 0, types_13 = types; _i < types_13.length; _i++) {
                var t = types_13[_i];
                if (isTypeIdenticalTo(t, type)) {
                    return true;
                }
            }
            return false;
        }
        function removeTypesFromUnionOrIntersection(type, typesToRemove) {
            var reducedTypes = [];
            for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                var t = _a[_i];
                if (!typeIdenticalToSomeType(t, typesToRemove)) {
                    reducedTypes.push(t);
                }
            }
            return type.flags & 65536 ? getUnionType(reducedTypes) : getIntersectionType(reducedTypes);
        }
        function getInferenceCandidates(context, index) {
            var inferences = context.inferences[index];
            return inferences.primary || inferences.secondary || emptyArray;
        }
        function hasPrimitiveConstraint(type) {
            var constraint = getConstraintOfTypeParameter(type);
            return constraint && maybeTypeOfKind(constraint, 8190 | 262144);
        }
        function getInferredType(context, index) {
            var inferredType = context.inferredTypes[index];
            var inferenceSucceeded;
            if (!inferredType) {
                var inferences = getInferenceCandidates(context, index);
                if (inferences.length) {
                    var signature = context.signature;
                    var widenLiteralTypes = context.inferences[index].topLevel &&
                        !hasPrimitiveConstraint(signature.typeParameters[index]) &&
                        (context.inferences[index].isFixed || !isTypeParameterAtTopLevel(getReturnTypeOfSignature(signature), signature.typeParameters[index]));
                    var baseInferences = widenLiteralTypes ? ts.sameMap(inferences, getWidenedLiteralType) : inferences;
                    var unionOrSuperType = context.inferUnionTypes ? getUnionType(baseInferences, true) : getCommonSupertype(baseInferences);
                    inferredType = unionOrSuperType ? getWidenedType(unionOrSuperType) : unknownType;
                    inferenceSucceeded = !!unionOrSuperType;
                }
                else {
                    var defaultType = getDefaultFromTypeParameter(context.signature.typeParameters[index]);
                    if (defaultType) {
                        inferredType = instantiateType(defaultType, combineTypeMappers(createBackreferenceMapper(context.signature.typeParameters, index), getInferenceMapper(context)));
                    }
                    else {
                        inferredType = context.useAnyForNoInferences ? anyType : emptyObjectType;
                    }
                    inferenceSucceeded = true;
                }
                context.inferredTypes[index] = inferredType;
                if (inferenceSucceeded) {
                    var constraint = getConstraintOfTypeParameter(context.signature.typeParameters[index]);
                    if (constraint) {
                        var instantiatedConstraint = instantiateType(constraint, getInferenceMapper(context));
                        if (!isTypeAssignableTo(inferredType, getTypeWithThisArgument(instantiatedConstraint, inferredType))) {
                            context.inferredTypes[index] = inferredType = instantiatedConstraint;
                        }
                    }
                }
                else if (context.failedTypeParameterIndex === undefined || context.failedTypeParameterIndex > index) {
                    context.failedTypeParameterIndex = index;
                }
            }
            return inferredType;
        }
        function getInferredTypes(context) {
            for (var i = 0; i < context.inferredTypes.length; i++) {
                getInferredType(context, i);
            }
            return context.inferredTypes;
        }
        function getResolvedSymbol(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedSymbol) {
                links.resolvedSymbol = !ts.nodeIsMissing(node) && resolveName(node, node.text, 107455 | 1048576, ts.Diagnostics.Cannot_find_name_0, node) || unknownSymbol;
            }
            return links.resolvedSymbol;
        }
        function isInTypeQuery(node) {
            return !!ts.findAncestor(node, function (n) { return n.kind === 162 ? true : n.kind === 71 || n.kind === 143 ? false : "quit"; });
        }
        function getFlowCacheKey(node) {
            if (node.kind === 71) {
                var symbol = getResolvedSymbol(node);
                return symbol !== unknownSymbol ? "" + getSymbolId(symbol) : undefined;
            }
            if (node.kind === 99) {
                return "0";
            }
            if (node.kind === 179) {
                var key = getFlowCacheKey(node.expression);
                return key && key + "." + node.name.text;
            }
            return undefined;
        }
        function getLeftmostIdentifierOrThis(node) {
            switch (node.kind) {
                case 71:
                case 99:
                    return node;
                case 179:
                    return getLeftmostIdentifierOrThis(node.expression);
            }
            return undefined;
        }
        function isMatchingReference(source, target) {
            switch (source.kind) {
                case 71:
                    return target.kind === 71 && getResolvedSymbol(source) === getResolvedSymbol(target) ||
                        (target.kind === 226 || target.kind === 176) &&
                            getExportSymbolOfValueSymbolIfExported(getResolvedSymbol(source)) === getSymbolOfNode(target);
                case 99:
                    return target.kind === 99;
                case 97:
                    return target.kind === 97;
                case 179:
                    return target.kind === 179 &&
                        source.name.text === target.name.text &&
                        isMatchingReference(source.expression, target.expression);
            }
            return false;
        }
        function containsMatchingReference(source, target) {
            while (source.kind === 179) {
                source = source.expression;
                if (isMatchingReference(source, target)) {
                    return true;
                }
            }
            return false;
        }
        function containsMatchingReferenceDiscriminant(source, target) {
            return target.kind === 179 &&
                containsMatchingReference(source, target.expression) &&
                isDiscriminantProperty(getDeclaredTypeOfReference(target.expression), target.name.text);
        }
        function getDeclaredTypeOfReference(expr) {
            if (expr.kind === 71) {
                return getTypeOfSymbol(getResolvedSymbol(expr));
            }
            if (expr.kind === 179) {
                var type = getDeclaredTypeOfReference(expr.expression);
                return type && getTypeOfPropertyOfType(type, expr.name.text);
            }
            return undefined;
        }
        function isDiscriminantProperty(type, name) {
            if (type && type.flags & 65536) {
                var prop = getUnionOrIntersectionProperty(type, name);
                if (prop && getCheckFlags(prop) & 2) {
                    if (prop.isDiscriminantProperty === undefined) {
                        prop.isDiscriminantProperty = prop.checkFlags & 32 && isLiteralType(getTypeOfSymbol(prop));
                    }
                    return prop.isDiscriminantProperty;
                }
            }
            return false;
        }
        function isOrContainsMatchingReference(source, target) {
            return isMatchingReference(source, target) || containsMatchingReference(source, target);
        }
        function hasMatchingArgument(callExpression, reference) {
            if (callExpression.arguments) {
                for (var _i = 0, _a = callExpression.arguments; _i < _a.length; _i++) {
                    var argument = _a[_i];
                    if (isOrContainsMatchingReference(reference, argument)) {
                        return true;
                    }
                }
            }
            if (callExpression.expression.kind === 179 &&
                isOrContainsMatchingReference(reference, callExpression.expression.expression)) {
                return true;
            }
            return false;
        }
        function getFlowNodeId(flow) {
            if (!flow.id) {
                flow.id = nextFlowId;
                nextFlowId++;
            }
            return flow.id;
        }
        function typeMaybeAssignableTo(source, target) {
            if (!(source.flags & 65536)) {
                return isTypeAssignableTo(source, target);
            }
            for (var _i = 0, _a = source.types; _i < _a.length; _i++) {
                var t = _a[_i];
                if (isTypeAssignableTo(t, target)) {
                    return true;
                }
            }
            return false;
        }
        function getAssignmentReducedType(declaredType, assignedType) {
            if (declaredType !== assignedType) {
                if (assignedType.flags & 8192) {
                    return assignedType;
                }
                var reducedType = filterType(declaredType, function (t) { return typeMaybeAssignableTo(assignedType, t); });
                if (!(reducedType.flags & 8192)) {
                    return reducedType;
                }
            }
            return declaredType;
        }
        function getTypeFactsOfTypes(types) {
            var result = 0;
            for (var _i = 0, types_14 = types; _i < types_14.length; _i++) {
                var t = types_14[_i];
                result |= getTypeFacts(t);
            }
            return result;
        }
        function isFunctionObjectType(type) {
            var resolved = resolveStructuredTypeMembers(type);
            return !!(resolved.callSignatures.length || resolved.constructSignatures.length ||
                resolved.members.get("bind") && isTypeSubtypeOf(type, globalFunctionType));
        }
        function getTypeFacts(type) {
            var flags = type.flags;
            if (flags & 2) {
                return strictNullChecks ? 4079361 : 4194049;
            }
            if (flags & 32) {
                return strictNullChecks ?
                    type.text === "" ? 3030785 : 1982209 :
                    type.text === "" ? 3145473 : 4194049;
            }
            if (flags & (4 | 16)) {
                return strictNullChecks ? 4079234 : 4193922;
            }
            if (flags & (64 | 256)) {
                var isZero = type.text === "0";
                return strictNullChecks ?
                    isZero ? 3030658 : 1982082 :
                    isZero ? 3145346 : 4193922;
            }
            if (flags & 8) {
                return strictNullChecks ? 4078980 : 4193668;
            }
            if (flags & 136) {
                return strictNullChecks ?
                    type === falseType ? 3030404 : 1981828 :
                    type === falseType ? 3145092 : 4193668;
            }
            if (flags & 32768) {
                return isFunctionObjectType(type) ?
                    strictNullChecks ? 6164448 : 8376288 :
                    strictNullChecks ? 6166480 : 8378320;
            }
            if (flags & (1024 | 2048)) {
                return 2457472;
            }
            if (flags & 4096) {
                return 2340752;
            }
            if (flags & 512) {
                return strictNullChecks ? 1981320 : 4193160;
            }
            if (flags & 16777216) {
                return strictNullChecks ? 6166480 : 8378320;
            }
            if (flags & 540672) {
                return getTypeFacts(getBaseConstraintOfType(type) || emptyObjectType);
            }
            if (flags & 196608) {
                return getTypeFactsOfTypes(type.types);
            }
            return 8388607;
        }
        function getTypeWithFacts(type, include) {
            return filterType(type, function (t) { return (getTypeFacts(t) & include) !== 0; });
        }
        function getTypeWithDefault(type, defaultExpression) {
            if (defaultExpression) {
                var defaultType = getTypeOfExpression(defaultExpression);
                return getUnionType([getTypeWithFacts(type, 131072), defaultType]);
            }
            return type;
        }
        function getTypeOfDestructuredProperty(type, name) {
            var text = ts.getTextOfPropertyName(name);
            return getTypeOfPropertyOfType(type, text) ||
                isNumericLiteralName(text) && getIndexTypeOfType(type, 1) ||
                getIndexTypeOfType(type, 0) ||
                unknownType;
        }
        function getTypeOfDestructuredArrayElement(type, index) {
            return isTupleLikeType(type) && getTypeOfPropertyOfType(type, "" + index) ||
                checkIteratedTypeOrElementType(type, undefined, false, false) ||
                unknownType;
        }
        function getTypeOfDestructuredSpreadExpression(type) {
            return createArrayType(checkIteratedTypeOrElementType(type, undefined, false, false) || unknownType);
        }
        function getAssignedTypeOfBinaryExpression(node) {
            var isDestructuringDefaultAssignment = node.parent.kind === 177 && isDestructuringAssignmentTarget(node.parent) ||
                node.parent.kind === 261 && isDestructuringAssignmentTarget(node.parent.parent);
            return isDestructuringDefaultAssignment ?
                getTypeWithDefault(getAssignedType(node), node.right) :
                getTypeOfExpression(node.right);
        }
        function isDestructuringAssignmentTarget(parent) {
            return parent.parent.kind === 194 && parent.parent.left === parent ||
                parent.parent.kind === 216 && parent.parent.initializer === parent;
        }
        function getAssignedTypeOfArrayLiteralElement(node, element) {
            return getTypeOfDestructuredArrayElement(getAssignedType(node), ts.indexOf(node.elements, element));
        }
        function getAssignedTypeOfSpreadExpression(node) {
            return getTypeOfDestructuredSpreadExpression(getAssignedType(node.parent));
        }
        function getAssignedTypeOfPropertyAssignment(node) {
            return getTypeOfDestructuredProperty(getAssignedType(node.parent), node.name);
        }
        function getAssignedTypeOfShorthandPropertyAssignment(node) {
            return getTypeWithDefault(getAssignedTypeOfPropertyAssignment(node), node.objectAssignmentInitializer);
        }
        function getAssignedType(node) {
            var parent = node.parent;
            switch (parent.kind) {
                case 215:
                    return stringType;
                case 216:
                    return checkRightHandSideOfForOf(parent.expression, parent.awaitModifier) || unknownType;
                case 194:
                    return getAssignedTypeOfBinaryExpression(parent);
                case 188:
                    return undefinedType;
                case 177:
                    return getAssignedTypeOfArrayLiteralElement(parent, node);
                case 198:
                    return getAssignedTypeOfSpreadExpression(parent);
                case 261:
                    return getAssignedTypeOfPropertyAssignment(parent);
                case 262:
                    return getAssignedTypeOfShorthandPropertyAssignment(parent);
            }
            return unknownType;
        }
        function getInitialTypeOfBindingElement(node) {
            var pattern = node.parent;
            var parentType = getInitialType(pattern.parent);
            var type = pattern.kind === 174 ?
                getTypeOfDestructuredProperty(parentType, node.propertyName || node.name) :
                !node.dotDotDotToken ?
                    getTypeOfDestructuredArrayElement(parentType, ts.indexOf(pattern.elements, node)) :
                    getTypeOfDestructuredSpreadExpression(parentType);
            return getTypeWithDefault(type, node.initializer);
        }
        function getTypeOfInitializer(node) {
            var links = getNodeLinks(node);
            return links.resolvedType || getTypeOfExpression(node);
        }
        function getInitialTypeOfVariableDeclaration(node) {
            if (node.initializer) {
                return getTypeOfInitializer(node.initializer);
            }
            if (node.parent.parent.kind === 215) {
                return stringType;
            }
            if (node.parent.parent.kind === 216) {
                return checkRightHandSideOfForOf(node.parent.parent.expression, node.parent.parent.awaitModifier) || unknownType;
            }
            return unknownType;
        }
        function getInitialType(node) {
            return node.kind === 226 ?
                getInitialTypeOfVariableDeclaration(node) :
                getInitialTypeOfBindingElement(node);
        }
        function getInitialOrAssignedType(node) {
            return node.kind === 226 || node.kind === 176 ?
                getInitialType(node) :
                getAssignedType(node);
        }
        function isEmptyArrayAssignment(node) {
            return node.kind === 226 && node.initializer &&
                isEmptyArrayLiteral(node.initializer) ||
                node.kind !== 176 && node.parent.kind === 194 &&
                    isEmptyArrayLiteral(node.parent.right);
        }
        function getReferenceCandidate(node) {
            switch (node.kind) {
                case 185:
                    return getReferenceCandidate(node.expression);
                case 194:
                    switch (node.operatorToken.kind) {
                        case 58:
                            return getReferenceCandidate(node.left);
                        case 26:
                            return getReferenceCandidate(node.right);
                    }
            }
            return node;
        }
        function getReferenceRoot(node) {
            var parent = node.parent;
            return parent.kind === 185 ||
                parent.kind === 194 && parent.operatorToken.kind === 58 && parent.left === node ||
                parent.kind === 194 && parent.operatorToken.kind === 26 && parent.right === node ?
                getReferenceRoot(parent) : node;
        }
        function getTypeOfSwitchClause(clause) {
            if (clause.kind === 257) {
                var caseType = getRegularTypeOfLiteralType(getTypeOfExpression(clause.expression));
                return isUnitType(caseType) ? caseType : undefined;
            }
            return neverType;
        }
        function getSwitchClauseTypes(switchStatement) {
            var links = getNodeLinks(switchStatement);
            if (!links.switchTypes) {
                var types = ts.map(switchStatement.caseBlock.clauses, getTypeOfSwitchClause);
                links.switchTypes = !ts.contains(types, undefined) ? types : emptyArray;
            }
            return links.switchTypes;
        }
        function eachTypeContainedIn(source, types) {
            return source.flags & 65536 ? !ts.forEach(source.types, function (t) { return !ts.contains(types, t); }) : ts.contains(types, source);
        }
        function isTypeSubsetOf(source, target) {
            return source === target || target.flags & 65536 && isTypeSubsetOfUnion(source, target);
        }
        function isTypeSubsetOfUnion(source, target) {
            if (source.flags & 65536) {
                for (var _i = 0, _a = source.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    if (!containsType(target.types, t)) {
                        return false;
                    }
                }
                return true;
            }
            if (source.flags & 256 && target.flags & 16 && source.baseType === target) {
                return true;
            }
            return containsType(target.types, source);
        }
        function forEachType(type, f) {
            return type.flags & 65536 ? ts.forEach(type.types, f) : f(type);
        }
        function filterType(type, f) {
            if (type.flags & 65536) {
                var types = type.types;
                var filtered = ts.filter(types, f);
                return filtered === types ? type : getUnionTypeFromSortedList(filtered);
            }
            return f(type) ? type : neverType;
        }
        function mapType(type, mapper) {
            if (!(type.flags & 65536)) {
                return mapper(type);
            }
            var types = type.types;
            var mappedType;
            var mappedTypes;
            for (var _i = 0, types_15 = types; _i < types_15.length; _i++) {
                var current = types_15[_i];
                var t = mapper(current);
                if (t) {
                    if (!mappedType) {
                        mappedType = t;
                    }
                    else if (!mappedTypes) {
                        mappedTypes = [mappedType, t];
                    }
                    else {
                        mappedTypes.push(t);
                    }
                }
            }
            return mappedTypes ? getUnionType(mappedTypes) : mappedType;
        }
        function extractTypesOfKind(type, kind) {
            return filterType(type, function (t) { return (t.flags & kind) !== 0; });
        }
        function replacePrimitivesWithLiterals(typeWithPrimitives, typeWithLiterals) {
            if (isTypeSubsetOf(stringType, typeWithPrimitives) && maybeTypeOfKind(typeWithLiterals, 32) ||
                isTypeSubsetOf(numberType, typeWithPrimitives) && maybeTypeOfKind(typeWithLiterals, 64)) {
                return mapType(typeWithPrimitives, function (t) {
                    return t.flags & 2 ? extractTypesOfKind(typeWithLiterals, 2 | 32) :
                        t.flags & 4 ? extractTypesOfKind(typeWithLiterals, 4 | 64) :
                            t;
                });
            }
            return typeWithPrimitives;
        }
        function isIncomplete(flowType) {
            return flowType.flags === 0;
        }
        function getTypeFromFlowType(flowType) {
            return flowType.flags === 0 ? flowType.type : flowType;
        }
        function createFlowType(type, incomplete) {
            return incomplete ? { flags: 0, type: type } : type;
        }
        function createEvolvingArrayType(elementType) {
            var result = createObjectType(256);
            result.elementType = elementType;
            return result;
        }
        function getEvolvingArrayType(elementType) {
            return evolvingArrayTypes[elementType.id] || (evolvingArrayTypes[elementType.id] = createEvolvingArrayType(elementType));
        }
        function addEvolvingArrayElementType(evolvingArrayType, node) {
            var elementType = getBaseTypeOfLiteralType(getContextFreeTypeOfExpression(node));
            return isTypeSubsetOf(elementType, evolvingArrayType.elementType) ? evolvingArrayType : getEvolvingArrayType(getUnionType([evolvingArrayType.elementType, elementType]));
        }
        function createFinalArrayType(elementType) {
            return elementType.flags & 8192 ?
                autoArrayType :
                createArrayType(elementType.flags & 65536 ?
                    getUnionType(elementType.types, true) :
                    elementType);
        }
        function getFinalArrayType(evolvingArrayType) {
            return evolvingArrayType.finalArrayType || (evolvingArrayType.finalArrayType = createFinalArrayType(evolvingArrayType.elementType));
        }
        function finalizeEvolvingArrayType(type) {
            return getObjectFlags(type) & 256 ? getFinalArrayType(type) : type;
        }
        function getElementTypeOfEvolvingArrayType(type) {
            return getObjectFlags(type) & 256 ? type.elementType : neverType;
        }
        function isEvolvingArrayTypeList(types) {
            var hasEvolvingArrayType = false;
            for (var _i = 0, types_16 = types; _i < types_16.length; _i++) {
                var t = types_16[_i];
                if (!(t.flags & 8192)) {
                    if (!(getObjectFlags(t) & 256)) {
                        return false;
                    }
                    hasEvolvingArrayType = true;
                }
            }
            return hasEvolvingArrayType;
        }
        function getUnionOrEvolvingArrayType(types, subtypeReduction) {
            return isEvolvingArrayTypeList(types) ?
                getEvolvingArrayType(getUnionType(ts.map(types, getElementTypeOfEvolvingArrayType))) :
                getUnionType(ts.sameMap(types, finalizeEvolvingArrayType), subtypeReduction);
        }
        function isEvolvingArrayOperationTarget(node) {
            var root = getReferenceRoot(node);
            var parent = root.parent;
            var isLengthPushOrUnshift = parent.kind === 179 && (parent.name.text === "length" ||
                parent.parent.kind === 181 && ts.isPushOrUnshiftIdentifier(parent.name));
            var isElementAssignment = parent.kind === 180 &&
                parent.expression === root &&
                parent.parent.kind === 194 &&
                parent.parent.operatorToken.kind === 58 &&
                parent.parent.left === parent &&
                !ts.isAssignmentTarget(parent.parent) &&
                isTypeAnyOrAllConstituentTypesHaveKind(getTypeOfExpression(parent.argumentExpression), 340 | 2048);
            return isLengthPushOrUnshift || isElementAssignment;
        }
        function maybeTypePredicateCall(node) {
            var links = getNodeLinks(node);
            if (links.maybeTypePredicate === undefined) {
                links.maybeTypePredicate = getMaybeTypePredicate(node);
            }
            return links.maybeTypePredicate;
        }
        function getMaybeTypePredicate(node) {
            if (node.expression.kind !== 97) {
                var funcType = checkNonNullExpression(node.expression);
                if (funcType !== silentNeverType) {
                    var apparentType = getApparentType(funcType);
                    if (apparentType !== unknownType) {
                        var callSignatures = getSignaturesOfType(apparentType, 0);
                        return !!ts.forEach(callSignatures, function (sig) { return sig.typePredicate; });
                    }
                }
            }
            return false;
        }
        function getFlowTypeOfReference(reference, declaredType, initialType, flowContainer, couldBeUninitialized) {
            if (initialType === void 0) { initialType = declaredType; }
            var key;
            if (!reference.flowNode || !couldBeUninitialized && !(declaredType.flags & 17810431)) {
                return declaredType;
            }
            var visitedFlowStart = visitedFlowCount;
            var evolvedType = getTypeFromFlowType(getTypeAtFlowNode(reference.flowNode));
            visitedFlowCount = visitedFlowStart;
            var resultType = getObjectFlags(evolvedType) & 256 && isEvolvingArrayOperationTarget(reference) ? anyArrayType : finalizeEvolvingArrayType(evolvedType);
            if (reference.parent.kind === 203 && getTypeWithFacts(resultType, 524288).flags & 8192) {
                return declaredType;
            }
            return resultType;
            function getTypeAtFlowNode(flow) {
                while (true) {
                    if (flow.flags & 1024) {
                        for (var i = visitedFlowStart; i < visitedFlowCount; i++) {
                            if (visitedFlowNodes[i] === flow) {
                                return visitedFlowTypes[i];
                            }
                        }
                    }
                    var type = void 0;
                    if (flow.flags & 4096) {
                        flow.locked = true;
                        type = getTypeAtFlowNode(flow.antecedent);
                        flow.locked = false;
                    }
                    else if (flow.flags & 2048) {
                        flow = flow.antecedent;
                        continue;
                    }
                    else if (flow.flags & 16) {
                        type = getTypeAtFlowAssignment(flow);
                        if (!type) {
                            flow = flow.antecedent;
                            continue;
                        }
                    }
                    else if (flow.flags & 96) {
                        type = getTypeAtFlowCondition(flow);
                    }
                    else if (flow.flags & 128) {
                        type = getTypeAtSwitchClause(flow);
                    }
                    else if (flow.flags & 12) {
                        if (flow.antecedents.length === 1) {
                            flow = flow.antecedents[0];
                            continue;
                        }
                        type = flow.flags & 4 ?
                            getTypeAtFlowBranchLabel(flow) :
                            getTypeAtFlowLoopLabel(flow);
                    }
                    else if (flow.flags & 256) {
                        type = getTypeAtFlowArrayMutation(flow);
                        if (!type) {
                            flow = flow.antecedent;
                            continue;
                        }
                    }
                    else if (flow.flags & 2) {
                        var container = flow.container;
                        if (container && container !== flowContainer && reference.kind !== 179 && reference.kind !== 99) {
                            flow = container.flowNode;
                            continue;
                        }
                        type = initialType;
                    }
                    else {
                        type = convertAutoToAny(declaredType);
                    }
                    if (flow.flags & 1024) {
                        visitedFlowNodes[visitedFlowCount] = flow;
                        visitedFlowTypes[visitedFlowCount] = type;
                        visitedFlowCount++;
                    }
                    return type;
                }
            }
            function getTypeAtFlowAssignment(flow) {
                var node = flow.node;
                if (isMatchingReference(reference, node)) {
                    if (ts.getAssignmentTargetKind(node) === 2) {
                        var flowType = getTypeAtFlowNode(flow.antecedent);
                        return createFlowType(getBaseTypeOfLiteralType(getTypeFromFlowType(flowType)), isIncomplete(flowType));
                    }
                    if (declaredType === autoType || declaredType === autoArrayType) {
                        if (isEmptyArrayAssignment(node)) {
                            return getEvolvingArrayType(neverType);
                        }
                        var assignedType = getBaseTypeOfLiteralType(getInitialOrAssignedType(node));
                        return isTypeAssignableTo(assignedType, declaredType) ? assignedType : anyArrayType;
                    }
                    if (declaredType.flags & 65536) {
                        return getAssignmentReducedType(declaredType, getInitialOrAssignedType(node));
                    }
                    return declaredType;
                }
                if (containsMatchingReference(reference, node)) {
                    return declaredType;
                }
                return undefined;
            }
            function getTypeAtFlowArrayMutation(flow) {
                var node = flow.node;
                var expr = node.kind === 181 ?
                    node.expression.expression :
                    node.left.expression;
                if (isMatchingReference(reference, getReferenceCandidate(expr))) {
                    var flowType = getTypeAtFlowNode(flow.antecedent);
                    var type = getTypeFromFlowType(flowType);
                    if (getObjectFlags(type) & 256) {
                        var evolvedType_1 = type;
                        if (node.kind === 181) {
                            for (var _i = 0, _a = node.arguments; _i < _a.length; _i++) {
                                var arg = _a[_i];
                                evolvedType_1 = addEvolvingArrayElementType(evolvedType_1, arg);
                            }
                        }
                        else {
                            var indexType = getTypeOfExpression(node.left.argumentExpression);
                            if (isTypeAnyOrAllConstituentTypesHaveKind(indexType, 340 | 2048)) {
                                evolvedType_1 = addEvolvingArrayElementType(evolvedType_1, node.right);
                            }
                        }
                        return evolvedType_1 === type ? flowType : createFlowType(evolvedType_1, isIncomplete(flowType));
                    }
                    return flowType;
                }
                return undefined;
            }
            function getTypeAtFlowCondition(flow) {
                var flowType = getTypeAtFlowNode(flow.antecedent);
                var type = getTypeFromFlowType(flowType);
                if (type.flags & 8192) {
                    return flowType;
                }
                var assumeTrue = (flow.flags & 32) !== 0;
                var nonEvolvingType = finalizeEvolvingArrayType(type);
                var narrowedType = narrowType(nonEvolvingType, flow.expression, assumeTrue);
                if (narrowedType === nonEvolvingType) {
                    return flowType;
                }
                var incomplete = isIncomplete(flowType);
                var resultType = incomplete && narrowedType.flags & 8192 ? silentNeverType : narrowedType;
                return createFlowType(resultType, incomplete);
            }
            function getTypeAtSwitchClause(flow) {
                var flowType = getTypeAtFlowNode(flow.antecedent);
                var type = getTypeFromFlowType(flowType);
                var expr = flow.switchStatement.expression;
                if (isMatchingReference(reference, expr)) {
                    type = narrowTypeBySwitchOnDiscriminant(type, flow.switchStatement, flow.clauseStart, flow.clauseEnd);
                }
                else if (isMatchingReferenceDiscriminant(expr)) {
                    type = narrowTypeByDiscriminant(type, expr, function (t) { return narrowTypeBySwitchOnDiscriminant(t, flow.switchStatement, flow.clauseStart, flow.clauseEnd); });
                }
                return createFlowType(type, isIncomplete(flowType));
            }
            function getTypeAtFlowBranchLabel(flow) {
                var antecedentTypes = [];
                var subtypeReduction = false;
                var seenIncomplete = false;
                for (var _i = 0, _a = flow.antecedents; _i < _a.length; _i++) {
                    var antecedent = _a[_i];
                    if (antecedent.flags & 2048 && antecedent.lock.locked) {
                        continue;
                    }
                    var flowType = getTypeAtFlowNode(antecedent);
                    var type = getTypeFromFlowType(flowType);
                    if (type === declaredType && declaredType === initialType) {
                        return type;
                    }
                    if (!ts.contains(antecedentTypes, type)) {
                        antecedentTypes.push(type);
                    }
                    if (!isTypeSubsetOf(type, declaredType)) {
                        subtypeReduction = true;
                    }
                    if (isIncomplete(flowType)) {
                        seenIncomplete = true;
                    }
                }
                return createFlowType(getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction), seenIncomplete);
            }
            function getTypeAtFlowLoopLabel(flow) {
                var id = getFlowNodeId(flow);
                var cache = flowLoopCaches[id] || (flowLoopCaches[id] = ts.createMap());
                if (!key) {
                    key = getFlowCacheKey(reference);
                }
                var cached = cache.get(key);
                if (cached) {
                    return cached;
                }
                for (var i = flowLoopStart; i < flowLoopCount; i++) {
                    if (flowLoopNodes[i] === flow && flowLoopKeys[i] === key && flowLoopTypes[i].length) {
                        return createFlowType(getUnionOrEvolvingArrayType(flowLoopTypes[i], false), true);
                    }
                }
                var antecedentTypes = [];
                var subtypeReduction = false;
                var firstAntecedentType;
                flowLoopNodes[flowLoopCount] = flow;
                flowLoopKeys[flowLoopCount] = key;
                flowLoopTypes[flowLoopCount] = antecedentTypes;
                for (var _i = 0, _a = flow.antecedents; _i < _a.length; _i++) {
                    var antecedent = _a[_i];
                    flowLoopCount++;
                    var flowType = getTypeAtFlowNode(antecedent);
                    flowLoopCount--;
                    if (!firstAntecedentType) {
                        firstAntecedentType = flowType;
                    }
                    var type = getTypeFromFlowType(flowType);
                    var cached_1 = cache.get(key);
                    if (cached_1) {
                        return cached_1;
                    }
                    if (!ts.contains(antecedentTypes, type)) {
                        antecedentTypes.push(type);
                    }
                    if (!isTypeSubsetOf(type, declaredType)) {
                        subtypeReduction = true;
                    }
                    if (type === declaredType) {
                        break;
                    }
                }
                var result = getUnionOrEvolvingArrayType(antecedentTypes, subtypeReduction);
                if (isIncomplete(firstAntecedentType)) {
                    return createFlowType(result, true);
                }
                cache.set(key, result);
                return result;
            }
            function isMatchingReferenceDiscriminant(expr) {
                return expr.kind === 179 &&
                    declaredType.flags & 65536 &&
                    isMatchingReference(reference, expr.expression) &&
                    isDiscriminantProperty(declaredType, expr.name.text);
            }
            function narrowTypeByDiscriminant(type, propAccess, narrowType) {
                var propName = propAccess.name.text;
                var propType = getTypeOfPropertyOfType(type, propName);
                var narrowedPropType = propType && narrowType(propType);
                return propType === narrowedPropType ? type : filterType(type, function (t) { return isTypeComparableTo(getTypeOfPropertyOfType(t, propName), narrowedPropType); });
            }
            function narrowTypeByTruthiness(type, expr, assumeTrue) {
                if (isMatchingReference(reference, expr)) {
                    return getTypeWithFacts(type, assumeTrue ? 1048576 : 2097152);
                }
                if (isMatchingReferenceDiscriminant(expr)) {
                    return narrowTypeByDiscriminant(type, expr, function (t) { return getTypeWithFacts(t, assumeTrue ? 1048576 : 2097152); });
                }
                if (containsMatchingReferenceDiscriminant(reference, expr)) {
                    return declaredType;
                }
                return type;
            }
            function narrowTypeByBinaryExpression(type, expr, assumeTrue) {
                switch (expr.operatorToken.kind) {
                    case 58:
                        return narrowTypeByTruthiness(type, expr.left, assumeTrue);
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                        var operator_1 = expr.operatorToken.kind;
                        var left_1 = getReferenceCandidate(expr.left);
                        var right_1 = getReferenceCandidate(expr.right);
                        if (left_1.kind === 189 && right_1.kind === 9) {
                            return narrowTypeByTypeof(type, left_1, operator_1, right_1, assumeTrue);
                        }
                        if (right_1.kind === 189 && left_1.kind === 9) {
                            return narrowTypeByTypeof(type, right_1, operator_1, left_1, assumeTrue);
                        }
                        if (isMatchingReference(reference, left_1)) {
                            return narrowTypeByEquality(type, operator_1, right_1, assumeTrue);
                        }
                        if (isMatchingReference(reference, right_1)) {
                            return narrowTypeByEquality(type, operator_1, left_1, assumeTrue);
                        }
                        if (isMatchingReferenceDiscriminant(left_1)) {
                            return narrowTypeByDiscriminant(type, left_1, function (t) { return narrowTypeByEquality(t, operator_1, right_1, assumeTrue); });
                        }
                        if (isMatchingReferenceDiscriminant(right_1)) {
                            return narrowTypeByDiscriminant(type, right_1, function (t) { return narrowTypeByEquality(t, operator_1, left_1, assumeTrue); });
                        }
                        if (containsMatchingReferenceDiscriminant(reference, left_1) || containsMatchingReferenceDiscriminant(reference, right_1)) {
                            return declaredType;
                        }
                        break;
                    case 93:
                        return narrowTypeByInstanceof(type, expr, assumeTrue);
                    case 26:
                        return narrowType(type, expr.right, assumeTrue);
                }
                return type;
            }
            function narrowTypeByEquality(type, operator, value, assumeTrue) {
                if (type.flags & 1) {
                    return type;
                }
                if (operator === 33 || operator === 35) {
                    assumeTrue = !assumeTrue;
                }
                var valueType = getTypeOfExpression(value);
                if (valueType.flags & 6144) {
                    if (!strictNullChecks) {
                        return type;
                    }
                    var doubleEquals = operator === 32 || operator === 33;
                    var facts = doubleEquals ?
                        assumeTrue ? 65536 : 524288 :
                        value.kind === 95 ?
                            assumeTrue ? 32768 : 262144 :
                            assumeTrue ? 16384 : 131072;
                    return getTypeWithFacts(type, facts);
                }
                if (type.flags & 16810497) {
                    return type;
                }
                if (assumeTrue) {
                    var narrowedType = filterType(type, function (t) { return areTypesComparable(t, valueType); });
                    return narrowedType.flags & 8192 ? type : replacePrimitivesWithLiterals(narrowedType, valueType);
                }
                if (isUnitType(valueType)) {
                    var regularType_1 = getRegularTypeOfLiteralType(valueType);
                    return filterType(type, function (t) { return getRegularTypeOfLiteralType(t) !== regularType_1; });
                }
                return type;
            }
            function narrowTypeByTypeof(type, typeOfExpr, operator, literal, assumeTrue) {
                var target = getReferenceCandidate(typeOfExpr.expression);
                if (!isMatchingReference(reference, target)) {
                    if (containsMatchingReference(reference, target)) {
                        return declaredType;
                    }
                    return type;
                }
                if (operator === 33 || operator === 35) {
                    assumeTrue = !assumeTrue;
                }
                if (assumeTrue && !(type.flags & 65536)) {
                    var targetType = typeofTypesByName.get(literal.text);
                    if (targetType) {
                        if (isTypeSubtypeOf(targetType, type)) {
                            return targetType;
                        }
                        if (type.flags & 540672) {
                            var constraint = getBaseConstraintOfType(type) || anyType;
                            if (isTypeSubtypeOf(targetType, constraint)) {
                                return getIntersectionType([type, targetType]);
                            }
                        }
                    }
                }
                var facts = assumeTrue ?
                    typeofEQFacts.get(literal.text) || 64 :
                    typeofNEFacts.get(literal.text) || 8192;
                return getTypeWithFacts(type, facts);
            }
            function narrowTypeBySwitchOnDiscriminant(type, switchStatement, clauseStart, clauseEnd) {
                var switchTypes = getSwitchClauseTypes(switchStatement);
                if (!switchTypes.length) {
                    return type;
                }
                var clauseTypes = switchTypes.slice(clauseStart, clauseEnd);
                var hasDefaultClause = clauseStart === clauseEnd || ts.contains(clauseTypes, neverType);
                var discriminantType = getUnionType(clauseTypes);
                var caseType = discriminantType.flags & 8192 ? neverType :
                    replacePrimitivesWithLiterals(filterType(type, function (t) { return isTypeComparableTo(discriminantType, t); }), discriminantType);
                if (!hasDefaultClause) {
                    return caseType;
                }
                var defaultType = filterType(type, function (t) { return !(isUnitType(t) && ts.contains(switchTypes, getRegularTypeOfLiteralType(t))); });
                return caseType.flags & 8192 ? defaultType : getUnionType([caseType, defaultType]);
            }
            function narrowTypeByInstanceof(type, expr, assumeTrue) {
                var left = getReferenceCandidate(expr.left);
                if (!isMatchingReference(reference, left)) {
                    if (containsMatchingReference(reference, left)) {
                        return declaredType;
                    }
                    return type;
                }
                var rightType = getTypeOfExpression(expr.right);
                if (!isTypeSubtypeOf(rightType, globalFunctionType)) {
                    return type;
                }
                var targetType;
                var prototypeProperty = getPropertyOfType(rightType, "prototype");
                if (prototypeProperty) {
                    var prototypePropertyType = getTypeOfSymbol(prototypeProperty);
                    if (!isTypeAny(prototypePropertyType)) {
                        targetType = prototypePropertyType;
                    }
                }
                if (isTypeAny(type) && (targetType === globalObjectType || targetType === globalFunctionType)) {
                    return type;
                }
                if (!targetType) {
                    var constructSignatures = void 0;
                    if (getObjectFlags(rightType) & 2) {
                        constructSignatures = resolveDeclaredMembers(rightType).declaredConstructSignatures;
                    }
                    else if (getObjectFlags(rightType) & 16) {
                        constructSignatures = getSignaturesOfType(rightType, 1);
                    }
                    if (constructSignatures && constructSignatures.length) {
                        targetType = getUnionType(ts.map(constructSignatures, function (signature) { return getReturnTypeOfSignature(getErasedSignature(signature)); }));
                    }
                }
                if (targetType) {
                    return getNarrowedType(type, targetType, assumeTrue, isTypeInstanceOf);
                }
                return type;
            }
            function getNarrowedType(type, candidate, assumeTrue, isRelated) {
                if (!assumeTrue) {
                    return filterType(type, function (t) { return !isRelated(t, candidate); });
                }
                if (type.flags & 65536) {
                    var assignableType = filterType(type, function (t) { return isRelated(t, candidate); });
                    if (!(assignableType.flags & 8192)) {
                        return assignableType;
                    }
                }
                return isTypeSubtypeOf(candidate, type) ? candidate :
                    isTypeAssignableTo(type, candidate) ? type :
                        isTypeAssignableTo(candidate, type) ? candidate :
                            getIntersectionType([type, candidate]);
            }
            function narrowTypeByTypePredicate(type, callExpression, assumeTrue) {
                if (!hasMatchingArgument(callExpression, reference) || !maybeTypePredicateCall(callExpression)) {
                    return type;
                }
                var signature = getResolvedSignature(callExpression);
                var predicate = signature.typePredicate;
                if (!predicate) {
                    return type;
                }
                if (isTypeAny(type) && (predicate.type === globalObjectType || predicate.type === globalFunctionType)) {
                    return type;
                }
                if (ts.isIdentifierTypePredicate(predicate)) {
                    var predicateArgument = callExpression.arguments[predicate.parameterIndex - (signature.thisParameter ? 1 : 0)];
                    if (predicateArgument) {
                        if (isMatchingReference(reference, predicateArgument)) {
                            return getNarrowedType(type, predicate.type, assumeTrue, isTypeSubtypeOf);
                        }
                        if (containsMatchingReference(reference, predicateArgument)) {
                            return declaredType;
                        }
                    }
                }
                else {
                    var invokedExpression = ts.skipParentheses(callExpression.expression);
                    if (invokedExpression.kind === 180 || invokedExpression.kind === 179) {
                        var accessExpression = invokedExpression;
                        var possibleReference = ts.skipParentheses(accessExpression.expression);
                        if (isMatchingReference(reference, possibleReference)) {
                            return getNarrowedType(type, predicate.type, assumeTrue, isTypeSubtypeOf);
                        }
                        if (containsMatchingReference(reference, possibleReference)) {
                            return declaredType;
                        }
                    }
                }
                return type;
            }
            function narrowType(type, expr, assumeTrue) {
                switch (expr.kind) {
                    case 71:
                    case 99:
                    case 97:
                    case 179:
                        return narrowTypeByTruthiness(type, expr, assumeTrue);
                    case 181:
                        return narrowTypeByTypePredicate(type, expr, assumeTrue);
                    case 185:
                        return narrowType(type, expr.expression, assumeTrue);
                    case 194:
                        return narrowTypeByBinaryExpression(type, expr, assumeTrue);
                    case 192:
                        if (expr.operator === 51) {
                            return narrowType(type, expr.operand, !assumeTrue);
                        }
                        break;
                }
                return type;
            }
        }
        function getTypeOfSymbolAtLocation(symbol, location) {
            if (location.kind === 71) {
                if (ts.isRightSideOfQualifiedNameOrPropertyAccess(location)) {
                    location = location.parent;
                }
                if (ts.isPartOfExpression(location) && !ts.isAssignmentTarget(location)) {
                    var type = getTypeOfExpression(location);
                    if (getExportSymbolOfValueSymbolIfExported(getNodeLinks(location).resolvedSymbol) === symbol) {
                        return type;
                    }
                }
            }
            return getTypeOfSymbol(symbol);
        }
        function getControlFlowContainer(node) {
            return ts.findAncestor(node.parent, function (node) {
                return ts.isFunctionLike(node) && !ts.getImmediatelyInvokedFunctionExpression(node) ||
                    node.kind === 234 ||
                    node.kind === 265 ||
                    node.kind === 149;
            });
        }
        function isParameterAssigned(symbol) {
            var func = ts.getRootDeclaration(symbol.valueDeclaration).parent;
            var links = getNodeLinks(func);
            if (!(links.flags & 4194304)) {
                links.flags |= 4194304;
                if (!hasParentWithAssignmentsMarked(func)) {
                    markParameterAssignments(func);
                }
            }
            return symbol.isAssigned || false;
        }
        function hasParentWithAssignmentsMarked(node) {
            return !!ts.findAncestor(node.parent, function (node) { return ts.isFunctionLike(node) && !!(getNodeLinks(node).flags & 4194304); });
        }
        function markParameterAssignments(node) {
            if (node.kind === 71) {
                if (ts.isAssignmentTarget(node)) {
                    var symbol = getResolvedSymbol(node);
                    if (symbol.valueDeclaration && ts.getRootDeclaration(symbol.valueDeclaration).kind === 146) {
                        symbol.isAssigned = true;
                    }
                }
            }
            else {
                ts.forEachChild(node, markParameterAssignments);
            }
        }
        function isConstVariable(symbol) {
            return symbol.flags & 3 && (getDeclarationNodeFlagsFromSymbol(symbol) & 2) !== 0 && getTypeOfSymbol(symbol) !== autoArrayType;
        }
        function removeOptionalityFromDeclaredType(declaredType, declaration) {
            var annotationIncludesUndefined = strictNullChecks &&
                declaration.kind === 146 &&
                declaration.initializer &&
                getFalsyFlags(declaredType) & 2048 &&
                !(getFalsyFlags(checkExpression(declaration.initializer)) & 2048);
            return annotationIncludesUndefined ? getTypeWithFacts(declaredType, 131072) : declaredType;
        }
        function checkIdentifier(node) {
            var symbol = getResolvedSymbol(node);
            if (symbol === unknownSymbol) {
                return unknownType;
            }
            if (symbol === argumentsSymbol) {
                var container = ts.getContainingFunction(node);
                if (languageVersion < 2) {
                    if (container.kind === 187) {
                        error(node, ts.Diagnostics.The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression);
                    }
                    else if (ts.hasModifier(container, 256)) {
                        error(node, ts.Diagnostics.The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method);
                    }
                }
                getNodeLinks(container).flags |= 8192;
                return getTypeOfSymbol(symbol);
            }
            if (symbol.flags & 8388608 && !isInTypeQuery(node) && !isConstEnumOrConstEnumOnlyModule(resolveAlias(symbol))) {
                markAliasSymbolAsReferenced(symbol);
            }
            var localOrExportSymbol = getExportSymbolOfValueSymbolIfExported(symbol);
            if (localOrExportSymbol.flags & 32) {
                var declaration_1 = localOrExportSymbol.valueDeclaration;
                if (declaration_1.kind === 229
                    && ts.nodeIsDecorated(declaration_1)) {
                    var container = ts.getContainingClass(node);
                    while (container !== undefined) {
                        if (container === declaration_1 && container.name !== node) {
                            getNodeLinks(declaration_1).flags |= 8388608;
                            getNodeLinks(node).flags |= 16777216;
                            break;
                        }
                        container = ts.getContainingClass(container);
                    }
                }
                else if (declaration_1.kind === 199) {
                    var container = ts.getThisContainer(node, false);
                    while (container !== undefined) {
                        if (container.parent === declaration_1) {
                            if (container.kind === 149 && ts.hasModifier(container, 32)) {
                                getNodeLinks(declaration_1).flags |= 8388608;
                                getNodeLinks(node).flags |= 16777216;
                            }
                            break;
                        }
                        container = ts.getThisContainer(container, false);
                    }
                }
            }
            checkCollisionWithCapturedSuperVariable(node, node);
            checkCollisionWithCapturedThisVariable(node, node);
            checkCollisionWithCapturedNewTargetVariable(node, node);
            checkNestedBlockScopedBinding(node, symbol);
            var type = getTypeOfSymbol(localOrExportSymbol);
            var declaration = localOrExportSymbol.valueDeclaration;
            var assignmentKind = ts.getAssignmentTargetKind(node);
            if (assignmentKind) {
                if (!(localOrExportSymbol.flags & 3)) {
                    error(node, ts.Diagnostics.Cannot_assign_to_0_because_it_is_not_a_variable, symbolToString(symbol));
                    return unknownType;
                }
                if (isReadonlySymbol(localOrExportSymbol)) {
                    error(node, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, symbolToString(symbol));
                    return unknownType;
                }
            }
            if (!(localOrExportSymbol.flags & 3) || assignmentKind === 1 || !declaration) {
                return type;
            }
            var isParameter = ts.getRootDeclaration(declaration).kind === 146;
            var declarationContainer = getControlFlowContainer(declaration);
            var flowContainer = getControlFlowContainer(node);
            var isOuterVariable = flowContainer !== declarationContainer;
            while (flowContainer !== declarationContainer && (flowContainer.kind === 186 ||
                flowContainer.kind === 187 || ts.isObjectLiteralOrClassExpressionMethod(flowContainer)) &&
                (isConstVariable(localOrExportSymbol) || isParameter && !isParameterAssigned(localOrExportSymbol))) {
                flowContainer = getControlFlowContainer(flowContainer);
            }
            var assumeInitialized = isParameter || isOuterVariable ||
                type !== autoType && type !== autoArrayType && (!strictNullChecks || (type.flags & 1) !== 0 || isInTypeQuery(node) || node.parent.kind === 246) ||
                ts.isInAmbientContext(declaration);
            var initialType = assumeInitialized ? (isParameter ? removeOptionalityFromDeclaredType(type, ts.getRootDeclaration(declaration)) : type) :
                type === autoType || type === autoArrayType ? undefinedType :
                    includeFalsyTypes(type, 2048);
            var flowType = getFlowTypeOfReference(node, type, initialType, flowContainer, !assumeInitialized);
            if (type === autoType || type === autoArrayType) {
                if (flowType === autoType || flowType === autoArrayType) {
                    if (noImplicitAny) {
                        error(ts.getNameOfDeclaration(declaration), ts.Diagnostics.Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined, symbolToString(symbol), typeToString(flowType));
                        error(node, ts.Diagnostics.Variable_0_implicitly_has_an_1_type, symbolToString(symbol), typeToString(flowType));
                    }
                    return convertAutoToAny(flowType);
                }
            }
            else if (!assumeInitialized && !(getFalsyFlags(type) & 2048) && getFalsyFlags(flowType) & 2048) {
                error(node, ts.Diagnostics.Variable_0_is_used_before_being_assigned, symbolToString(symbol));
                return type;
            }
            return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
        }
        function isInsideFunction(node, threshold) {
            return !!ts.findAncestor(node, function (n) { return n === threshold ? "quit" : ts.isFunctionLike(n); });
        }
        function checkNestedBlockScopedBinding(node, symbol) {
            if (languageVersion >= 2 ||
                (symbol.flags & (2 | 32)) === 0 ||
                symbol.valueDeclaration.parent.kind === 260) {
                return;
            }
            var container = ts.getEnclosingBlockScopeContainer(symbol.valueDeclaration);
            var usedInFunction = isInsideFunction(node.parent, container);
            var current = container;
            var containedInIterationStatement = false;
            while (current && !ts.nodeStartsNewLexicalEnvironment(current)) {
                if (ts.isIterationStatement(current, false)) {
                    containedInIterationStatement = true;
                    break;
                }
                current = current.parent;
            }
            if (containedInIterationStatement) {
                if (usedInFunction) {
                    getNodeLinks(current).flags |= 65536;
                }
                if (container.kind === 214 &&
                    ts.getAncestor(symbol.valueDeclaration, 227).parent === container &&
                    isAssignedInBodyOfForStatement(node, container)) {
                    getNodeLinks(symbol.valueDeclaration).flags |= 2097152;
                }
                getNodeLinks(symbol.valueDeclaration).flags |= 262144;
            }
            if (usedInFunction) {
                getNodeLinks(symbol.valueDeclaration).flags |= 131072;
            }
        }
        function isAssignedInBodyOfForStatement(node, container) {
            var current = node;
            while (current.parent.kind === 185) {
                current = current.parent;
            }
            var isAssigned = false;
            if (ts.isAssignmentTarget(current)) {
                isAssigned = true;
            }
            else if ((current.parent.kind === 192 || current.parent.kind === 193)) {
                var expr = current.parent;
                isAssigned = expr.operator === 43 || expr.operator === 44;
            }
            if (!isAssigned) {
                return false;
            }
            return !!ts.findAncestor(current, function (n) { return n === container ? "quit" : n === container.statement; });
        }
        function captureLexicalThis(node, container) {
            getNodeLinks(node).flags |= 2;
            if (container.kind === 149 || container.kind === 152) {
                var classNode = container.parent;
                getNodeLinks(classNode).flags |= 4;
            }
            else {
                getNodeLinks(container).flags |= 4;
            }
        }
        function findFirstSuperCall(n) {
            if (ts.isSuperCall(n)) {
                return n;
            }
            else if (ts.isFunctionLike(n)) {
                return undefined;
            }
            return ts.forEachChild(n, findFirstSuperCall);
        }
        function getSuperCallInConstructor(constructor) {
            var links = getNodeLinks(constructor);
            if (links.hasSuperCall === undefined) {
                links.superCall = findFirstSuperCall(constructor.body);
                links.hasSuperCall = links.superCall ? true : false;
            }
            return links.superCall;
        }
        function classDeclarationExtendsNull(classDecl) {
            var classSymbol = getSymbolOfNode(classDecl);
            var classInstanceType = getDeclaredTypeOfSymbol(classSymbol);
            var baseConstructorType = getBaseConstructorTypeOfClass(classInstanceType);
            return baseConstructorType === nullWideningType;
        }
        function checkThisBeforeSuper(node, container, diagnosticMessage) {
            var containingClassDecl = container.parent;
            var baseTypeNode = ts.getClassExtendsHeritageClauseElement(containingClassDecl);
            if (baseTypeNode && !classDeclarationExtendsNull(containingClassDecl)) {
                var superCall = getSuperCallInConstructor(container);
                if (!superCall || superCall.end > node.pos) {
                    error(node, diagnosticMessage);
                }
            }
        }
        function checkThisExpression(node) {
            var container = ts.getThisContainer(node, true);
            var needToCaptureLexicalThis = false;
            if (container.kind === 152) {
                checkThisBeforeSuper(node, container, ts.Diagnostics.super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class);
            }
            if (container.kind === 187) {
                container = ts.getThisContainer(container, false);
                needToCaptureLexicalThis = (languageVersion < 2);
            }
            switch (container.kind) {
                case 233:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_module_or_namespace_body);
                    break;
                case 232:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_current_location);
                    break;
                case 152:
                    if (isInConstructorArgumentInitializer(node, container)) {
                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_constructor_arguments);
                    }
                    break;
                case 149:
                case 148:
                    if (ts.getModifierFlags(container) & 32) {
                        error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_static_property_initializer);
                    }
                    break;
                case 144:
                    error(node, ts.Diagnostics.this_cannot_be_referenced_in_a_computed_property_name);
                    break;
            }
            if (needToCaptureLexicalThis) {
                captureLexicalThis(node, container);
            }
            if (ts.isFunctionLike(container) &&
                (!isInParameterInitializerBeforeContainingFunction(node) || ts.getThisParameter(container))) {
                if (container.kind === 186 &&
                    container.parent.kind === 194 &&
                    ts.getSpecialPropertyAssignmentKind(container.parent) === 3) {
                    var className = container.parent
                        .left
                        .expression
                        .expression;
                    var classSymbol = checkExpression(className).symbol;
                    if (classSymbol && classSymbol.members && (classSymbol.flags & 16)) {
                        return getInferredClassType(classSymbol);
                    }
                }
                var thisType = getThisTypeOfDeclaration(container) || getContextualThisParameterType(container);
                if (thisType) {
                    return thisType;
                }
            }
            if (ts.isClassLike(container.parent)) {
                var symbol = getSymbolOfNode(container.parent);
                var type = ts.hasModifier(container, 32) ? getTypeOfSymbol(symbol) : getDeclaredTypeOfSymbol(symbol).thisType;
                return getFlowTypeOfReference(node, type);
            }
            if (ts.isInJavaScriptFile(node)) {
                var type = getTypeForThisExpressionFromJSDoc(container);
                if (type && type !== unknownType) {
                    return type;
                }
            }
            if (noImplicitThis) {
                error(node, ts.Diagnostics.this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation);
            }
            return anyType;
        }
        function getTypeForThisExpressionFromJSDoc(node) {
            var jsdocType = ts.getJSDocType(node);
            if (jsdocType && jsdocType.kind === 279) {
                var jsDocFunctionType = jsdocType;
                if (jsDocFunctionType.parameters.length > 0 && jsDocFunctionType.parameters[0].type.kind === 282) {
                    return getTypeFromTypeNode(jsDocFunctionType.parameters[0].type);
                }
            }
        }
        function isInConstructorArgumentInitializer(node, constructorDecl) {
            return !!ts.findAncestor(node, function (n) { return n === constructorDecl ? "quit" : n.kind === 146; });
        }
        function checkSuperExpression(node) {
            var isCallExpression = node.parent.kind === 181 && node.parent.expression === node;
            var container = ts.getSuperContainer(node, true);
            var needToCaptureLexicalThis = false;
            if (!isCallExpression) {
                while (container && container.kind === 187) {
                    container = ts.getSuperContainer(container, true);
                    needToCaptureLexicalThis = languageVersion < 2;
                }
            }
            var canUseSuperExpression = isLegalUsageOfSuperExpression(container);
            var nodeCheckFlag = 0;
            if (!canUseSuperExpression) {
                var current = ts.findAncestor(node, function (n) { return n === container ? "quit" : n.kind === 144; });
                if (current && current.kind === 144) {
                    error(node, ts.Diagnostics.super_cannot_be_referenced_in_a_computed_property_name);
                }
                else if (isCallExpression) {
                    error(node, ts.Diagnostics.Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors);
                }
                else if (!container || !container.parent || !(ts.isClassLike(container.parent) || container.parent.kind === 178)) {
                    error(node, ts.Diagnostics.super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions);
                }
                else {
                    error(node, ts.Diagnostics.super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class);
                }
                return unknownType;
            }
            if (!isCallExpression && container.kind === 152) {
                checkThisBeforeSuper(node, container, ts.Diagnostics.super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class);
            }
            if ((ts.getModifierFlags(container) & 32) || isCallExpression) {
                nodeCheckFlag = 512;
            }
            else {
                nodeCheckFlag = 256;
            }
            getNodeLinks(node).flags |= nodeCheckFlag;
            if (container.kind === 151 && ts.getModifierFlags(container) & 256) {
                if (ts.isSuperProperty(node.parent) && ts.isAssignmentTarget(node.parent)) {
                    getNodeLinks(container).flags |= 4096;
                }
                else {
                    getNodeLinks(container).flags |= 2048;
                }
            }
            if (needToCaptureLexicalThis) {
                captureLexicalThis(node.parent, container);
            }
            if (container.parent.kind === 178) {
                if (languageVersion < 2) {
                    error(node, ts.Diagnostics.super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher);
                    return unknownType;
                }
                else {
                    return anyType;
                }
            }
            var classLikeDeclaration = container.parent;
            var classType = getDeclaredTypeOfSymbol(getSymbolOfNode(classLikeDeclaration));
            var baseClassType = classType && getBaseTypes(classType)[0];
            if (!baseClassType) {
                if (!ts.getClassExtendsHeritageClauseElement(classLikeDeclaration)) {
                    error(node, ts.Diagnostics.super_can_only_be_referenced_in_a_derived_class);
                }
                return unknownType;
            }
            if (container.kind === 152 && isInConstructorArgumentInitializer(node, container)) {
                error(node, ts.Diagnostics.super_cannot_be_referenced_in_constructor_arguments);
                return unknownType;
            }
            return nodeCheckFlag === 512
                ? getBaseConstructorTypeOfClass(classType)
                : getTypeWithThisArgument(baseClassType, classType.thisType);
            function isLegalUsageOfSuperExpression(container) {
                if (!container) {
                    return false;
                }
                if (isCallExpression) {
                    return container.kind === 152;
                }
                else {
                    if (ts.isClassLike(container.parent) || container.parent.kind === 178) {
                        if (ts.getModifierFlags(container) & 32) {
                            return container.kind === 151 ||
                                container.kind === 150 ||
                                container.kind === 153 ||
                                container.kind === 154;
                        }
                        else {
                            return container.kind === 151 ||
                                container.kind === 150 ||
                                container.kind === 153 ||
                                container.kind === 154 ||
                                container.kind === 149 ||
                                container.kind === 148 ||
                                container.kind === 152;
                        }
                    }
                }
                return false;
            }
        }
        function getContainingObjectLiteral(func) {
            return (func.kind === 151 ||
                func.kind === 153 ||
                func.kind === 154) && func.parent.kind === 178 ? func.parent :
                func.kind === 186 && func.parent.kind === 261 ? func.parent.parent :
                    undefined;
        }
        function getThisTypeArgument(type) {
            return getObjectFlags(type) & 4 && type.target === globalThisType ? type.typeArguments[0] : undefined;
        }
        function getThisTypeFromContextualType(type) {
            return mapType(type, function (t) {
                return t.flags & 131072 ? ts.forEach(t.types, getThisTypeArgument) : getThisTypeArgument(t);
            });
        }
        function getContextualThisParameterType(func) {
            if (func.kind === 187) {
                return undefined;
            }
            if (isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
                var contextualSignature = getContextualSignature(func);
                if (contextualSignature) {
                    var thisParameter = contextualSignature.thisParameter;
                    if (thisParameter) {
                        return getTypeOfSymbol(thisParameter);
                    }
                }
            }
            if (noImplicitThis) {
                var containingLiteral = getContainingObjectLiteral(func);
                if (containingLiteral) {
                    var contextualType = getApparentTypeOfContextualType(containingLiteral);
                    var literal = containingLiteral;
                    var type = contextualType;
                    while (type) {
                        var thisType = getThisTypeFromContextualType(type);
                        if (thisType) {
                            return instantiateType(thisType, getContextualMapper(containingLiteral));
                        }
                        if (literal.parent.kind !== 261) {
                            break;
                        }
                        literal = literal.parent.parent;
                        type = getApparentTypeOfContextualType(literal);
                    }
                    return contextualType ? getNonNullableType(contextualType) : checkExpressionCached(containingLiteral);
                }
                if (func.parent.kind === 194 && func.parent.operatorToken.kind === 58) {
                    var target = func.parent.left;
                    if (target.kind === 179 || target.kind === 180) {
                        return checkExpressionCached(target.expression);
                    }
                }
            }
            return undefined;
        }
        function getContextuallyTypedParameterType(parameter) {
            var func = parameter.parent;
            if (isContextSensitiveFunctionOrObjectLiteralMethod(func)) {
                var iife = ts.getImmediatelyInvokedFunctionExpression(func);
                if (iife && iife.arguments) {
                    var indexOfParameter = ts.indexOf(func.parameters, parameter);
                    if (parameter.dotDotDotToken) {
                        var restTypes = [];
                        for (var i = indexOfParameter; i < iife.arguments.length; i++) {
                            restTypes.push(getWidenedLiteralType(checkExpression(iife.arguments[i])));
                        }
                        return restTypes.length ? createArrayType(getUnionType(restTypes)) : undefined;
                    }
                    var links = getNodeLinks(iife);
                    var cached = links.resolvedSignature;
                    links.resolvedSignature = anySignature;
                    var type = indexOfParameter < iife.arguments.length ?
                        getWidenedLiteralType(checkExpression(iife.arguments[indexOfParameter])) :
                        parameter.initializer ? undefined : undefinedWideningType;
                    links.resolvedSignature = cached;
                    return type;
                }
                var contextualSignature = getContextualSignature(func);
                if (contextualSignature) {
                    var funcHasRestParameters = ts.hasRestParameter(func);
                    var len = func.parameters.length - (funcHasRestParameters ? 1 : 0);
                    var indexOfParameter = ts.indexOf(func.parameters, parameter);
                    if (indexOfParameter < len) {
                        return getTypeAtPosition(contextualSignature, indexOfParameter);
                    }
                    if (funcHasRestParameters &&
                        indexOfParameter === (func.parameters.length - 1) &&
                        isRestParameterIndex(contextualSignature, func.parameters.length - 1)) {
                        return getTypeOfSymbol(ts.lastOrUndefined(contextualSignature.parameters));
                    }
                }
            }
            return undefined;
        }
        function getContextualTypeForInitializerExpression(node) {
            var declaration = node.parent;
            if (node === declaration.initializer) {
                if (declaration.type) {
                    return getTypeFromTypeNode(declaration.type);
                }
                if (declaration.kind === 146) {
                    var type = getContextuallyTypedParameterType(declaration);
                    if (type) {
                        return type;
                    }
                }
                if (ts.isBindingPattern(declaration.name)) {
                    return getTypeFromBindingPattern(declaration.name, true, false);
                }
                if (ts.isBindingPattern(declaration.parent)) {
                    var parentDeclaration = declaration.parent.parent;
                    var name = declaration.propertyName || declaration.name;
                    if (parentDeclaration.kind !== 176 &&
                        parentDeclaration.type &&
                        !ts.isBindingPattern(name)) {
                        var text = ts.getTextOfPropertyName(name);
                        if (text) {
                            return getTypeOfPropertyOfType(getTypeFromTypeNode(parentDeclaration.type), text);
                        }
                    }
                }
            }
            return undefined;
        }
        function getContextualTypeForReturnExpression(node) {
            var func = ts.getContainingFunction(node);
            if (func) {
                var functionFlags = ts.getFunctionFlags(func);
                if (functionFlags & 1) {
                    return undefined;
                }
                var contextualReturnType = getContextualReturnType(func);
                return functionFlags & 2
                    ? contextualReturnType && getAwaitedTypeOfPromise(contextualReturnType)
                    : contextualReturnType;
            }
            return undefined;
        }
        function getContextualTypeForYieldOperand(node) {
            var func = ts.getContainingFunction(node);
            if (func) {
                var functionFlags = ts.getFunctionFlags(func);
                var contextualReturnType = getContextualReturnType(func);
                if (contextualReturnType) {
                    return node.asteriskToken
                        ? contextualReturnType
                        : getIteratedTypeOfGenerator(contextualReturnType, (functionFlags & 2) !== 0);
                }
            }
            return undefined;
        }
        function isInParameterInitializerBeforeContainingFunction(node) {
            while (node.parent && !ts.isFunctionLike(node.parent)) {
                if (node.parent.kind === 146 && node.parent.initializer === node) {
                    return true;
                }
                node = node.parent;
            }
            return false;
        }
        function getContextualReturnType(functionDecl) {
            if (functionDecl.type ||
                functionDecl.kind === 152 ||
                functionDecl.kind === 153 && ts.getSetAccessorTypeAnnotationNode(ts.getDeclarationOfKind(functionDecl.symbol, 154))) {
                return getReturnTypeOfSignature(getSignatureFromDeclaration(functionDecl));
            }
            var signature = getContextualSignatureForFunctionLikeDeclaration(functionDecl);
            if (signature) {
                return getReturnTypeOfSignature(signature);
            }
            return undefined;
        }
        function getContextualTypeForArgument(callTarget, arg) {
            var args = getEffectiveCallArguments(callTarget);
            var argIndex = ts.indexOf(args, arg);
            if (argIndex >= 0) {
                var signature = getResolvedOrAnySignature(callTarget);
                return getTypeAtPosition(signature, argIndex);
            }
            return undefined;
        }
        function getContextualTypeForSubstitutionExpression(template, substitutionExpression) {
            if (template.parent.kind === 183) {
                return getContextualTypeForArgument(template.parent, substitutionExpression);
            }
            return undefined;
        }
        function getContextualTypeForBinaryOperand(node) {
            var binaryExpression = node.parent;
            var operator = binaryExpression.operatorToken.kind;
            if (operator >= 58 && operator <= 70) {
                if (ts.getSpecialPropertyAssignmentKind(binaryExpression) !== 0) {
                    return undefined;
                }
                if (node === binaryExpression.right) {
                    return getTypeOfExpression(binaryExpression.left);
                }
            }
            else if (operator === 54) {
                var type = getContextualType(binaryExpression);
                if (!type && node === binaryExpression.right) {
                    type = getTypeOfExpression(binaryExpression.left);
                }
                return type;
            }
            else if (operator === 53 || operator === 26) {
                if (node === binaryExpression.right) {
                    return getContextualType(binaryExpression);
                }
            }
            return undefined;
        }
        function getTypeOfPropertyOfContextualType(type, name) {
            return mapType(type, function (t) {
                var prop = t.flags & 229376 ? getPropertyOfType(t, name) : undefined;
                return prop ? getTypeOfSymbol(prop) : undefined;
            });
        }
        function getIndexTypeOfContextualType(type, kind) {
            return mapType(type, function (t) { return getIndexTypeOfStructuredType(t, kind); });
        }
        function contextualTypeIsTupleLikeType(type) {
            return !!(type.flags & 65536 ? ts.forEach(type.types, isTupleLikeType) : isTupleLikeType(type));
        }
        function getContextualTypeForObjectLiteralMethod(node) {
            ts.Debug.assert(ts.isObjectLiteralMethod(node));
            if (isInsideWithStatementBody(node)) {
                return undefined;
            }
            return getContextualTypeForObjectLiteralElement(node);
        }
        function getContextualTypeForObjectLiteralElement(element) {
            var objectLiteral = element.parent;
            var type = getApparentTypeOfContextualType(objectLiteral);
            if (type) {
                if (!ts.hasDynamicName(element)) {
                    var symbolName = getSymbolOfNode(element).name;
                    var propertyType = getTypeOfPropertyOfContextualType(type, symbolName);
                    if (propertyType) {
                        return propertyType;
                    }
                }
                return isNumericName(element.name) && getIndexTypeOfContextualType(type, 1) ||
                    getIndexTypeOfContextualType(type, 0);
            }
            return undefined;
        }
        function getContextualTypeForElementExpression(node) {
            var arrayLiteral = node.parent;
            var type = getApparentTypeOfContextualType(arrayLiteral);
            if (type) {
                var index = ts.indexOf(arrayLiteral.elements, node);
                return getTypeOfPropertyOfContextualType(type, "" + index)
                    || getIndexTypeOfContextualType(type, 1)
                    || getIteratedTypeOrElementType(type, undefined, false, false, false);
            }
            return undefined;
        }
        function getContextualTypeForConditionalOperand(node) {
            var conditional = node.parent;
            return node === conditional.whenTrue || node === conditional.whenFalse ? getContextualType(conditional) : undefined;
        }
        function getContextualTypeForJsxExpression(node) {
            var jsxAttributes = ts.isJsxAttributeLike(node.parent) ?
                node.parent.parent :
                node.parent.openingElement.attributes;
            var attributesType = getContextualType(jsxAttributes);
            if (!attributesType || isTypeAny(attributesType)) {
                return undefined;
            }
            if (ts.isJsxAttribute(node.parent)) {
                return getTypeOfPropertyOfType(attributesType, node.parent.name.text);
            }
            else if (node.parent.kind === 249) {
                var jsxChildrenPropertyName = getJsxElementChildrenPropertyname();
                return jsxChildrenPropertyName && jsxChildrenPropertyName !== "" ? getTypeOfPropertyOfType(attributesType, jsxChildrenPropertyName) : anyType;
            }
            else {
                return attributesType;
            }
        }
        function getContextualTypeForJsxAttribute(attribute) {
            var attributesType = getContextualType(attribute.parent);
            if (ts.isJsxAttribute(attribute)) {
                if (!attributesType || isTypeAny(attributesType)) {
                    return undefined;
                }
                return getTypeOfPropertyOfType(attributesType, attribute.name.text);
            }
            else {
                return attributesType;
            }
        }
        function getApparentTypeOfContextualType(node) {
            var type = getContextualType(node);
            return type && getApparentType(type);
        }
        function getContextualType(node) {
            if (isInsideWithStatementBody(node)) {
                return undefined;
            }
            if (node.contextualType) {
                return node.contextualType;
            }
            var parent = node.parent;
            switch (parent.kind) {
                case 226:
                case 146:
                case 149:
                case 148:
                case 176:
                    return getContextualTypeForInitializerExpression(node);
                case 187:
                case 219:
                    return getContextualTypeForReturnExpression(node);
                case 197:
                    return getContextualTypeForYieldOperand(parent);
                case 181:
                case 182:
                    return getContextualTypeForArgument(parent, node);
                case 184:
                case 202:
                    return getTypeFromTypeNode(parent.type);
                case 194:
                    return getContextualTypeForBinaryOperand(node);
                case 261:
                case 262:
                    return getContextualTypeForObjectLiteralElement(parent);
                case 177:
                    return getContextualTypeForElementExpression(node);
                case 195:
                    return getContextualTypeForConditionalOperand(node);
                case 205:
                    ts.Debug.assert(parent.parent.kind === 196);
                    return getContextualTypeForSubstitutionExpression(parent.parent, node);
                case 185:
                    return getContextualType(parent);
                case 256:
                    return getContextualTypeForJsxExpression(parent);
                case 253:
                case 255:
                    return getContextualTypeForJsxAttribute(parent);
                case 251:
                case 250:
                    return getAttributesTypeFromJsxOpeningLikeElement(parent);
            }
            return undefined;
        }
        function getContextualMapper(node) {
            node = ts.findAncestor(node, function (n) { return !!n.contextualMapper; });
            return node ? node.contextualMapper : identityMapper;
        }
        function getNonGenericSignature(type, node) {
            var signatures = getSignaturesOfStructuredType(type, 0);
            if (signatures.length === 1) {
                var signature = signatures[0];
                if (!signature.typeParameters && !isAritySmaller(signature, node)) {
                    return signature;
                }
            }
        }
        function isAritySmaller(signature, target) {
            var targetParameterCount = 0;
            for (; targetParameterCount < target.parameters.length; targetParameterCount++) {
                var param = target.parameters[targetParameterCount];
                if (param.initializer || param.questionToken || param.dotDotDotToken || isJSDocOptionalParameter(param)) {
                    break;
                }
            }
            if (target.parameters.length && ts.parameterIsThisKeyword(target.parameters[0])) {
                targetParameterCount--;
            }
            var sourceLength = signature.hasRestParameter ? Number.MAX_VALUE : signature.parameters.length;
            return sourceLength < targetParameterCount;
        }
        function isFunctionExpressionOrArrowFunction(node) {
            return node.kind === 186 || node.kind === 187;
        }
        function getContextualSignatureForFunctionLikeDeclaration(node) {
            return isFunctionExpressionOrArrowFunction(node) || ts.isObjectLiteralMethod(node)
                ? getContextualSignature(node)
                : undefined;
        }
        function getContextualTypeForFunctionLikeDeclaration(node) {
            return ts.isObjectLiteralMethod(node) ?
                getContextualTypeForObjectLiteralMethod(node) :
                getApparentTypeOfContextualType(node);
        }
        function getContextualSignature(node) {
            ts.Debug.assert(node.kind !== 151 || ts.isObjectLiteralMethod(node));
            var type = getContextualTypeForFunctionLikeDeclaration(node);
            if (!type) {
                return undefined;
            }
            if (!(type.flags & 65536)) {
                return getNonGenericSignature(type, node);
            }
            var signatureList;
            var types = type.types;
            for (var _i = 0, types_17 = types; _i < types_17.length; _i++) {
                var current = types_17[_i];
                var signature = getNonGenericSignature(current, node);
                if (signature) {
                    if (!signatureList) {
                        signatureList = [signature];
                    }
                    else if (!compareSignaturesIdentical(signatureList[0], signature, false, true, true, compareTypesIdentical)) {
                        return undefined;
                    }
                    else {
                        signatureList.push(signature);
                    }
                }
            }
            var result;
            if (signatureList) {
                result = cloneSignature(signatureList[0]);
                result.resolvedReturnType = undefined;
                result.unionSignatures = signatureList;
            }
            return result;
        }
        function checkSpreadExpression(node, checkMode) {
            if (languageVersion < 2 && compilerOptions.downlevelIteration) {
                checkExternalEmitHelpers(node, 1536);
            }
            var arrayOrIterableType = checkExpression(node.expression, checkMode);
            return checkIteratedTypeOrElementType(arrayOrIterableType, node.expression, false, false);
        }
        function hasDefaultValue(node) {
            return (node.kind === 176 && !!node.initializer) ||
                (node.kind === 194 && node.operatorToken.kind === 58);
        }
        function checkArrayLiteral(node, checkMode) {
            var elements = node.elements;
            var hasSpreadElement = false;
            var elementTypes = [];
            var inDestructuringPattern = ts.isAssignmentTarget(node);
            for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                var e = elements_1[_i];
                if (inDestructuringPattern && e.kind === 198) {
                    var restArrayType = checkExpression(e.expression, checkMode);
                    var restElementType = getIndexTypeOfType(restArrayType, 1) ||
                        getIteratedTypeOrElementType(restArrayType, undefined, false, false, false);
                    if (restElementType) {
                        elementTypes.push(restElementType);
                    }
                }
                else {
                    var type = checkExpressionForMutableLocation(e, checkMode);
                    elementTypes.push(type);
                }
                hasSpreadElement = hasSpreadElement || e.kind === 198;
            }
            if (!hasSpreadElement) {
                if (inDestructuringPattern && elementTypes.length) {
                    var type = cloneTypeReference(createTupleType(elementTypes));
                    type.pattern = node;
                    return type;
                }
                var contextualType = getApparentTypeOfContextualType(node);
                if (contextualType && contextualTypeIsTupleLikeType(contextualType)) {
                    var pattern = contextualType.pattern;
                    if (pattern && (pattern.kind === 175 || pattern.kind === 177)) {
                        var patternElements = pattern.elements;
                        for (var i = elementTypes.length; i < patternElements.length; i++) {
                            var patternElement = patternElements[i];
                            if (hasDefaultValue(patternElement)) {
                                elementTypes.push(contextualType.typeArguments[i]);
                            }
                            else {
                                if (patternElement.kind !== 200) {
                                    error(patternElement, ts.Diagnostics.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);
                                }
                                elementTypes.push(unknownType);
                            }
                        }
                    }
                    if (elementTypes.length) {
                        return createTupleType(elementTypes);
                    }
                }
            }
            return createArrayType(elementTypes.length ?
                getUnionType(elementTypes, true) :
                strictNullChecks ? neverType : undefinedWideningType);
        }
        function isNumericName(name) {
            return name.kind === 144 ? isNumericComputedName(name) : isNumericLiteralName(name.text);
        }
        function isNumericComputedName(name) {
            return isTypeAnyOrAllConstituentTypesHaveKind(checkComputedPropertyName(name), 340);
        }
        function isTypeAnyOrAllConstituentTypesHaveKind(type, kind) {
            return isTypeAny(type) || isTypeOfKind(type, kind);
        }
        function isInfinityOrNaNString(name) {
            return name === "Infinity" || name === "-Infinity" || name === "NaN";
        }
        function isNumericLiteralName(name) {
            return (+name).toString() === name;
        }
        function checkComputedPropertyName(node) {
            var links = getNodeLinks(node.expression);
            if (!links.resolvedType) {
                links.resolvedType = checkExpression(node.expression);
                if (!isTypeAnyOrAllConstituentTypesHaveKind(links.resolvedType, 340 | 262178 | 512)) {
                    error(node, ts.Diagnostics.A_computed_property_name_must_be_of_type_string_number_symbol_or_any);
                }
                else {
                    checkThatExpressionIsProperSymbolReference(node.expression, links.resolvedType, true);
                }
            }
            return links.resolvedType;
        }
        function getObjectLiteralIndexInfo(propertyNodes, offset, properties, kind) {
            var propTypes = [];
            for (var i = 0; i < properties.length; i++) {
                if (kind === 0 || isNumericName(propertyNodes[i + offset].name)) {
                    propTypes.push(getTypeOfSymbol(properties[i]));
                }
            }
            var unionType = propTypes.length ? getUnionType(propTypes, true) : undefinedType;
            return createIndexInfo(unionType, false);
        }
        function checkObjectLiteral(node, checkMode) {
            var inDestructuringPattern = ts.isAssignmentTarget(node);
            checkGrammarObjectLiteralExpression(node, inDestructuringPattern);
            var propertiesTable = ts.createMap();
            var propertiesArray = [];
            var spread = emptyObjectType;
            var propagatedFlags = 0;
            var contextualType = getApparentTypeOfContextualType(node);
            var contextualTypeHasPattern = contextualType && contextualType.pattern &&
                (contextualType.pattern.kind === 174 || contextualType.pattern.kind === 178);
            var isJSObjectLiteral = !contextualType && ts.isInJavaScriptFile(node);
            var typeFlags = 0;
            var patternWithComputedProperties = false;
            var hasComputedStringProperty = false;
            var hasComputedNumberProperty = false;
            var offset = 0;
            for (var i = 0; i < node.properties.length; i++) {
                var memberDecl = node.properties[i];
                var member = memberDecl.symbol;
                if (memberDecl.kind === 261 ||
                    memberDecl.kind === 262 ||
                    ts.isObjectLiteralMethod(memberDecl)) {
                    var type = void 0;
                    if (memberDecl.kind === 261) {
                        type = checkPropertyAssignment(memberDecl, checkMode);
                    }
                    else if (memberDecl.kind === 151) {
                        type = checkObjectLiteralMethod(memberDecl, checkMode);
                    }
                    else {
                        ts.Debug.assert(memberDecl.kind === 262);
                        type = checkExpressionForMutableLocation(memberDecl.name, checkMode);
                    }
                    typeFlags |= type.flags;
                    var prop = createSymbol(4 | member.flags, member.name);
                    if (inDestructuringPattern) {
                        var isOptional = (memberDecl.kind === 261 && hasDefaultValue(memberDecl.initializer)) ||
                            (memberDecl.kind === 262 && memberDecl.objectAssignmentInitializer);
                        if (isOptional) {
                            prop.flags |= 67108864;
                        }
                        if (ts.hasDynamicName(memberDecl)) {
                            patternWithComputedProperties = true;
                        }
                    }
                    else if (contextualTypeHasPattern && !(getObjectFlags(contextualType) & 512)) {
                        var impliedProp = getPropertyOfType(contextualType, member.name);
                        if (impliedProp) {
                            prop.flags |= impliedProp.flags & 67108864;
                        }
                        else if (!compilerOptions.suppressExcessPropertyErrors && !getIndexInfoOfType(contextualType, 0)) {
                            error(memberDecl.name, ts.Diagnostics.Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1, symbolToString(member), typeToString(contextualType));
                        }
                    }
                    prop.declarations = member.declarations;
                    prop.parent = member.parent;
                    if (member.valueDeclaration) {
                        prop.valueDeclaration = member.valueDeclaration;
                    }
                    prop.type = type;
                    prop.target = member;
                    member = prop;
                }
                else if (memberDecl.kind === 263) {
                    if (languageVersion < 2) {
                        checkExternalEmitHelpers(memberDecl, 2);
                    }
                    if (propertiesArray.length > 0) {
                        spread = getSpreadType(spread, createObjectLiteralType());
                        propertiesArray = [];
                        propertiesTable = ts.createMap();
                        hasComputedStringProperty = false;
                        hasComputedNumberProperty = false;
                        typeFlags = 0;
                    }
                    var type = checkExpression(memberDecl.expression);
                    if (!isValidSpreadType(type)) {
                        error(memberDecl, ts.Diagnostics.Spread_types_may_only_be_created_from_object_types);
                        return unknownType;
                    }
                    spread = getSpreadType(spread, type);
                    offset = i + 1;
                    continue;
                }
                else {
                    ts.Debug.assert(memberDecl.kind === 153 || memberDecl.kind === 154);
                    checkNodeDeferred(memberDecl);
                }
                if (ts.hasDynamicName(memberDecl)) {
                    if (isNumericName(memberDecl.name)) {
                        hasComputedNumberProperty = true;
                    }
                    else {
                        hasComputedStringProperty = true;
                    }
                }
                else {
                    propertiesTable.set(member.name, member);
                }
                propertiesArray.push(member);
            }
            if (contextualTypeHasPattern) {
                for (var _i = 0, _a = getPropertiesOfType(contextualType); _i < _a.length; _i++) {
                    var prop = _a[_i];
                    if (!propertiesTable.get(prop.name)) {
                        if (!(prop.flags & 67108864)) {
                            error(prop.valueDeclaration || prop.bindingElement, ts.Diagnostics.Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value);
                        }
                        propertiesTable.set(prop.name, prop);
                        propertiesArray.push(prop);
                    }
                }
            }
            if (spread !== emptyObjectType) {
                if (propertiesArray.length > 0) {
                    spread = getSpreadType(spread, createObjectLiteralType());
                }
                if (spread.flags & 32768) {
                    spread.flags |= propagatedFlags;
                    spread.symbol = node.symbol;
                }
                return spread;
            }
            return createObjectLiteralType();
            function createObjectLiteralType() {
                var stringIndexInfo = isJSObjectLiteral ? jsObjectLiteralIndexInfo : hasComputedStringProperty ? getObjectLiteralIndexInfo(node.properties, offset, propertiesArray, 0) : undefined;
                var numberIndexInfo = hasComputedNumberProperty && !isJSObjectLiteral ? getObjectLiteralIndexInfo(node.properties, offset, propertiesArray, 1) : undefined;
                var result = createAnonymousType(node.symbol, propertiesTable, emptyArray, emptyArray, stringIndexInfo, numberIndexInfo);
                var freshObjectLiteralFlag = compilerOptions.suppressExcessPropertyErrors ? 0 : 1048576;
                result.flags |= 4194304 | freshObjectLiteralFlag | (typeFlags & 14680064);
                result.objectFlags |= 128;
                if (patternWithComputedProperties) {
                    result.objectFlags |= 512;
                }
                if (inDestructuringPattern) {
                    result.pattern = node;
                }
                if (!(result.flags & 6144)) {
                    propagatedFlags |= (result.flags & 14680064);
                }
                return result;
            }
        }
        function isValidSpreadType(type) {
            return !!(type.flags & (1 | 4096 | 2048 | 16777216) ||
                type.flags & 32768 && !isGenericMappedType(type) ||
                type.flags & 196608 && !ts.forEach(type.types, function (t) { return !isValidSpreadType(t); }));
        }
        function checkJsxSelfClosingElement(node) {
            checkJsxOpeningLikeElement(node);
            return getJsxGlobalElementType() || anyType;
        }
        function checkJsxElement(node) {
            checkJsxOpeningLikeElement(node.openingElement);
            if (isJsxIntrinsicIdentifier(node.closingElement.tagName)) {
                getIntrinsicTagSymbol(node.closingElement);
            }
            else {
                checkExpression(node.closingElement.tagName);
            }
            return getJsxGlobalElementType() || anyType;
        }
        function isUnhyphenatedJsxName(name) {
            return name.indexOf("-") < 0;
        }
        function isJsxIntrinsicIdentifier(tagName) {
            if (tagName.kind === 179 || tagName.kind === 99) {
                return false;
            }
            else {
                return ts.isIntrinsicJsxName(tagName.text);
            }
        }
        function createJsxAttributesTypeFromAttributesProperty(openingLikeElement, filter, checkMode) {
            var attributes = openingLikeElement.attributes;
            var attributesTable = ts.createMap();
            var spread = emptyObjectType;
            var attributesArray = [];
            var hasSpreadAnyType = false;
            var typeToIntersect;
            var explicitlySpecifyChildrenAttribute = false;
            var jsxChildrenPropertyName = getJsxElementChildrenPropertyname();
            for (var _i = 0, _a = attributes.properties; _i < _a.length; _i++) {
                var attributeDecl = _a[_i];
                var member = attributeDecl.symbol;
                if (ts.isJsxAttribute(attributeDecl)) {
                    var exprType = attributeDecl.initializer ?
                        checkExpression(attributeDecl.initializer, checkMode) :
                        trueType;
                    var attributeSymbol = createSymbol(4 | 134217728 | member.flags, member.name);
                    attributeSymbol.declarations = member.declarations;
                    attributeSymbol.parent = member.parent;
                    if (member.valueDeclaration) {
                        attributeSymbol.valueDeclaration = member.valueDeclaration;
                    }
                    attributeSymbol.type = exprType;
                    attributeSymbol.target = member;
                    attributesTable.set(attributeSymbol.name, attributeSymbol);
                    attributesArray.push(attributeSymbol);
                    if (attributeDecl.name.text === jsxChildrenPropertyName) {
                        explicitlySpecifyChildrenAttribute = true;
                    }
                }
                else {
                    ts.Debug.assert(attributeDecl.kind === 255);
                    if (attributesArray.length > 0) {
                        spread = getSpreadType(spread, createJsxAttributesType(attributes.symbol, attributesTable));
                        attributesArray = [];
                        attributesTable = ts.createMap();
                    }
                    var exprType = checkExpression(attributeDecl.expression);
                    if (isTypeAny(exprType)) {
                        hasSpreadAnyType = true;
                    }
                    if (isValidSpreadType(exprType)) {
                        spread = getSpreadType(spread, exprType);
                    }
                    else {
                        typeToIntersect = typeToIntersect ? getIntersectionType([typeToIntersect, exprType]) : exprType;
                    }
                }
            }
            if (!hasSpreadAnyType) {
                if (spread !== emptyObjectType) {
                    if (attributesArray.length > 0) {
                        spread = getSpreadType(spread, createJsxAttributesType(attributes.symbol, attributesTable));
                        attributesArray = [];
                        attributesTable = ts.createMap();
                    }
                    attributesArray = getPropertiesOfType(spread);
                }
                attributesTable = ts.createMap();
                if (attributesArray) {
                    ts.forEach(attributesArray, function (attr) {
                        if (!filter || filter(attr)) {
                            attributesTable.set(attr.name, attr);
                        }
                    });
                }
            }
            var parent = openingLikeElement.parent.kind === 249 ? openingLikeElement.parent : undefined;
            if (parent && parent.openingElement === openingLikeElement && parent.children.length > 0) {
                var childrenTypes = [];
                for (var _b = 0, _c = parent.children; _b < _c.length; _b++) {
                    var child = _c[_b];
                    if (child.kind === 10) {
                        if (!child.containsOnlyWhiteSpaces) {
                            childrenTypes.push(stringType);
                        }
                    }
                    else {
                        childrenTypes.push(checkExpression(child, checkMode));
                    }
                }
                if (!hasSpreadAnyType && jsxChildrenPropertyName && jsxChildrenPropertyName !== "") {
                    if (explicitlySpecifyChildrenAttribute) {
                        error(attributes, ts.Diagnostics._0_are_specified_twice_The_attribute_named_0_will_be_overwritten, jsxChildrenPropertyName);
                    }
                    var childrenPropSymbol = createSymbol(4 | 134217728, jsxChildrenPropertyName);
                    childrenPropSymbol.type = childrenTypes.length === 1 ?
                        childrenTypes[0] :
                        createArrayType(getUnionType(childrenTypes, false));
                    attributesTable.set(jsxChildrenPropertyName, childrenPropSymbol);
                }
            }
            if (hasSpreadAnyType) {
                return anyType;
            }
            var attributeType = createJsxAttributesType(attributes.symbol, attributesTable);
            return typeToIntersect && attributesTable.size ? getIntersectionType([typeToIntersect, attributeType]) :
                typeToIntersect ? typeToIntersect : attributeType;
            function createJsxAttributesType(symbol, attributesTable) {
                var result = createAnonymousType(symbol, attributesTable, emptyArray, emptyArray, undefined, undefined);
                result.flags |= 33554432 | 4194304;
                result.objectFlags |= 128;
                return result;
            }
        }
        function checkJsxAttributes(node, checkMode) {
            return createJsxAttributesTypeFromAttributesProperty(node.parent, undefined, checkMode);
        }
        function getJsxType(name) {
            var jsxType = jsxTypes.get(name);
            if (jsxType === undefined) {
                jsxTypes.set(name, jsxType = getExportedTypeFromNamespace(JsxNames.JSX, name) || unknownType);
            }
            return jsxType;
        }
        function getIntrinsicTagSymbol(node) {
            var links = getNodeLinks(node);
            if (!links.resolvedSymbol) {
                var intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements);
                if (intrinsicElementsType !== unknownType) {
                    var intrinsicProp = getPropertyOfType(intrinsicElementsType, node.tagName.text);
                    if (intrinsicProp) {
                        links.jsxFlags |= 1;
                        return links.resolvedSymbol = intrinsicProp;
                    }
                    var indexSignatureType = getIndexTypeOfType(intrinsicElementsType, 0);
                    if (indexSignatureType) {
                        links.jsxFlags |= 2;
                        return links.resolvedSymbol = intrinsicElementsType.symbol;
                    }
                    error(node, ts.Diagnostics.Property_0_does_not_exist_on_type_1, node.tagName.text, "JSX." + JsxNames.IntrinsicElements);
                    return links.resolvedSymbol = unknownSymbol;
                }
                else {
                    if (noImplicitAny) {
                        error(node, ts.Diagnostics.JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists, JsxNames.IntrinsicElements);
                    }
                    return links.resolvedSymbol = unknownSymbol;
                }
            }
            return links.resolvedSymbol;
        }
        function getJsxElementInstanceType(node, valueType) {
            ts.Debug.assert(!(valueType.flags & 65536));
            if (isTypeAny(valueType)) {
                return anyType;
            }
            var signatures = getSignaturesOfType(valueType, 1);
            if (signatures.length === 0) {
                signatures = getSignaturesOfType(valueType, 0);
                if (signatures.length === 0) {
                    error(node.tagName, ts.Diagnostics.JSX_element_type_0_does_not_have_any_construct_or_call_signatures, ts.getTextOfNode(node.tagName));
                    return unknownType;
                }
            }
            var instantiatedSignatures = [];
            for (var _i = 0, signatures_3 = signatures; _i < signatures_3.length; _i++) {
                var signature = signatures_3[_i];
                if (signature.typeParameters) {
                    var typeArguments = fillMissingTypeArguments(undefined, signature.typeParameters, 0);
                    instantiatedSignatures.push(getSignatureInstantiation(signature, typeArguments));
                }
                else {
                    instantiatedSignatures.push(signature);
                }
            }
            return getUnionType(ts.map(instantiatedSignatures, getReturnTypeOfSignature), true);
        }
        function getNameFromJsxElementAttributesContainer(nameOfAttribPropContainer) {
            var jsxNamespace = getGlobalSymbol(JsxNames.JSX, 1920, undefined);
            var jsxElementAttribPropInterfaceSym = jsxNamespace && getSymbol(jsxNamespace.exports, nameOfAttribPropContainer, 793064);
            var jsxElementAttribPropInterfaceType = jsxElementAttribPropInterfaceSym && getDeclaredTypeOfSymbol(jsxElementAttribPropInterfaceSym);
            var propertiesOfJsxElementAttribPropInterface = jsxElementAttribPropInterfaceType && getPropertiesOfType(jsxElementAttribPropInterfaceType);
            if (propertiesOfJsxElementAttribPropInterface) {
                if (propertiesOfJsxElementAttribPropInterface.length === 0) {
                    return "";
                }
                else if (propertiesOfJsxElementAttribPropInterface.length === 1) {
                    return propertiesOfJsxElementAttribPropInterface[0].name;
                }
                else if (propertiesOfJsxElementAttribPropInterface.length > 1) {
                    error(jsxElementAttribPropInterfaceSym.declarations[0], ts.Diagnostics.The_global_type_JSX_0_may_not_have_more_than_one_property, nameOfAttribPropContainer);
                }
            }
            return undefined;
        }
        function getJsxElementPropertiesName() {
            if (!_hasComputedJsxElementPropertiesName) {
                _hasComputedJsxElementPropertiesName = true;
                _jsxElementPropertiesName = getNameFromJsxElementAttributesContainer(JsxNames.ElementAttributesPropertyNameContainer);
            }
            return _jsxElementPropertiesName;
        }
        function getJsxElementChildrenPropertyname() {
            if (!_hasComputedJsxElementChildrenPropertyName) {
                _hasComputedJsxElementChildrenPropertyName = true;
                _jsxElementChildrenPropertyName = getNameFromJsxElementAttributesContainer(JsxNames.ElementChildrenAttributeNameContainer);
            }
            return _jsxElementChildrenPropertyName;
        }
        function getApparentTypeOfJsxPropsType(propsType) {
            if (!propsType) {
                return undefined;
            }
            if (propsType.flags & 131072) {
                var propsApparentType = [];
                for (var _i = 0, _a = propsType.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    propsApparentType.push(getApparentType(t));
                }
                return getIntersectionType(propsApparentType);
            }
            return getApparentType(propsType);
        }
        function defaultTryGetJsxStatelessFunctionAttributesType(openingLikeElement, elementType, elemInstanceType, elementClassType) {
            ts.Debug.assert(!(elementType.flags & 65536));
            if (!elementClassType || !isTypeAssignableTo(elemInstanceType, elementClassType)) {
                var jsxStatelessElementType = getJsxGlobalStatelessElementType();
                if (jsxStatelessElementType) {
                    var callSignature = getResolvedJsxStatelessFunctionSignature(openingLikeElement, elementType, undefined);
                    if (callSignature !== unknownSignature) {
                        var callReturnType = callSignature && getReturnTypeOfSignature(callSignature);
                        var paramType = callReturnType && (callSignature.parameters.length === 0 ? emptyObjectType : getTypeOfSymbol(callSignature.parameters[0]));
                        paramType = getApparentTypeOfJsxPropsType(paramType);
                        if (callReturnType && isTypeAssignableTo(callReturnType, jsxStatelessElementType)) {
                            var intrinsicAttributes = getJsxType(JsxNames.IntrinsicAttributes);
                            if (intrinsicAttributes !== unknownType) {
                                paramType = intersectTypes(intrinsicAttributes, paramType);
                            }
                            return paramType;
                        }
                    }
                }
            }
            return undefined;
        }
        function tryGetAllJsxStatelessFunctionAttributesType(openingLikeElement, elementType, elemInstanceType, elementClassType) {
            ts.Debug.assert(!(elementType.flags & 65536));
            if (!elementClassType || !isTypeAssignableTo(elemInstanceType, elementClassType)) {
                var jsxStatelessElementType = getJsxGlobalStatelessElementType();
                if (jsxStatelessElementType) {
                    var candidatesOutArray = [];
                    getResolvedJsxStatelessFunctionSignature(openingLikeElement, elementType, candidatesOutArray);
                    var result = void 0;
                    var allMatchingAttributesType = void 0;
                    for (var _i = 0, candidatesOutArray_1 = candidatesOutArray; _i < candidatesOutArray_1.length; _i++) {
                        var candidate = candidatesOutArray_1[_i];
                        var callReturnType = getReturnTypeOfSignature(candidate);
                        var paramType = callReturnType && (candidate.parameters.length === 0 ? emptyObjectType : getTypeOfSymbol(candidate.parameters[0]));
                        paramType = getApparentTypeOfJsxPropsType(paramType);
                        if (callReturnType && isTypeAssignableTo(callReturnType, jsxStatelessElementType)) {
                            var shouldBeCandidate = true;
                            for (var _a = 0, _b = openingLikeElement.attributes.properties; _a < _b.length; _a++) {
                                var attribute = _b[_a];
                                if (ts.isJsxAttribute(attribute) &&
                                    isUnhyphenatedJsxName(attribute.name.text) &&
                                    !getPropertyOfType(paramType, attribute.name.text)) {
                                    shouldBeCandidate = false;
                                    break;
                                }
                            }
                            if (shouldBeCandidate) {
                                result = intersectTypes(result, paramType);
                            }
                            allMatchingAttributesType = intersectTypes(allMatchingAttributesType, paramType);
                        }
                    }
                    if (!result) {
                        result = allMatchingAttributesType;
                    }
                    var intrinsicAttributes = getJsxType(JsxNames.IntrinsicAttributes);
                    if (intrinsicAttributes !== unknownType) {
                        result = intersectTypes(intrinsicAttributes, result);
                    }
                    return result;
                }
            }
            return undefined;
        }
        function resolveCustomJsxElementAttributesType(openingLikeElement, shouldIncludeAllStatelessAttributesType, elementType, elementClassType) {
            if (!elementType) {
                elementType = checkExpression(openingLikeElement.tagName);
            }
            if (elementType.flags & 65536) {
                var types = elementType.types;
                return getUnionType(types.map(function (type) {
                    return resolveCustomJsxElementAttributesType(openingLikeElement, shouldIncludeAllStatelessAttributesType, type, elementClassType);
                }), true);
            }
            if (elementType.flags & 2) {
                return anyType;
            }
            else if (elementType.flags & 32) {
                var intrinsicElementsType = getJsxType(JsxNames.IntrinsicElements);
                if (intrinsicElementsType !== unknownType) {
                    var stringLiteralTypeName = elementType.text;
                    var intrinsicProp = getPropertyOfType(intrinsicElementsType, stringLiteralTypeName);
                    if (intrinsicProp) {
                        return getTypeOfSymbol(intrinsicProp);
                    }
                    var indexSignatureType = getIndexTypeOfType(intrinsicElementsType, 0);
                    if (indexSignatureType) {
                        return indexSignatureType;
                    }
                    error(openingLikeElement, ts.Diagnostics.Property_0_does_not_exist_on_type_1, stringLiteralTypeName, "JSX." + JsxNames.IntrinsicElements);
                }
                return anyType;
            }
            var elemInstanceType = getJsxElementInstanceType(openingLikeElement, elementType);
            var statelessAttributesType = shouldIncludeAllStatelessAttributesType ?
                tryGetAllJsxStatelessFunctionAttributesType(openingLikeElement, elementType, elemInstanceType, elementClassType) :
                defaultTryGetJsxStatelessFunctionAttributesType(openingLikeElement, elementType, elemInstanceType, elementClassType);
            if (statelessAttributesType) {
                return statelessAttributesType;
            }
            if (elementClassType) {
                checkTypeRelatedTo(elemInstanceType, elementClassType, assignableRelation, openingLikeElement, ts.Diagnostics.JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements);
            }
            if (isTypeAny(elemInstanceType)) {
                return elemInstanceType;
            }
            var propsName = getJsxElementPropertiesName();
            if (propsName === undefined) {
                return anyType;
            }
            else if (propsName === "") {
                return elemInstanceType;
            }
            else {
                var attributesType = getTypeOfPropertyOfType(elemInstanceType, propsName);
                if (!attributesType) {
                    return emptyObjectType;
                }
                else if (isTypeAny(attributesType) || (attributesType === unknownType)) {
                    return attributesType;
                }
                else {
                    var apparentAttributesType = attributesType;
                    var intrinsicClassAttribs = getJsxType(JsxNames.IntrinsicClassAttributes);
                    if (intrinsicClassAttribs !== unknownType) {
                        var typeParams = getLocalTypeParametersOfClassOrInterfaceOrTypeAlias(intrinsicClassAttribs.symbol);
                        if (typeParams) {
                            if (typeParams.length === 1) {
                                apparentAttributesType = intersectTypes(createTypeReference(intrinsicClassAttribs, [elemInstanceType]), apparentAttributesType);
                            }
                        }
                        else {
                            apparentAttributesType = intersectTypes(attributesType, intrinsicClassAttribs);
                        }
                    }
                    var intrinsicAttribs = getJsxType(JsxNames.IntrinsicAttributes);
                    if (intrinsicAttribs !== unknownType) {
                        apparentAttributesType = intersectTypes(intrinsicAttribs, apparentAttributesType);
                    }
                    return apparentAttributesType;
                }
            }
        }
        function getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node) {
            ts.Debug.assert(isJsxIntrinsicIdentifier(node.tagName));
            var links = getNodeLinks(node);
            if (!links.resolvedJsxElementAttributesType) {
                var symbol = getIntrinsicTagSymbol(node);
                if (links.jsxFlags & 1) {
                    return links.resolvedJsxElementAttributesType = getTypeOfSymbol(symbol);
                }
                else if (links.jsxFlags & 2) {
                    return links.resolvedJsxElementAttributesType = getIndexInfoOfSymbol(symbol, 0).type;
                }
                else {
                    return links.resolvedJsxElementAttributesType = unknownType;
                }
            }
            return links.resolvedJsxElementAttributesType;
        }
        function getCustomJsxElementAttributesType(node, shouldIncludeAllStatelessAttributesType) {
            var links = getNodeLinks(node);
            if (!links.resolvedJsxElementAttributesType) {
                var elemClassType = getJsxGlobalElementClassType();
                return links.resolvedJsxElementAttributesType = resolveCustomJsxElementAttributesType(node, shouldIncludeAllStatelessAttributesType, undefined, elemClassType);
            }
            return links.resolvedJsxElementAttributesType;
        }
        function getAllAttributesTypeFromJsxOpeningLikeElement(node) {
            if (isJsxIntrinsicIdentifier(node.tagName)) {
                return getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
            }
            else {
                return getCustomJsxElementAttributesType(node, true);
            }
        }
        function getAttributesTypeFromJsxOpeningLikeElement(node) {
            if (isJsxIntrinsicIdentifier(node.tagName)) {
                return getIntrinsicAttributesTypeFromJsxOpeningLikeElement(node);
            }
            else {
                return getCustomJsxElementAttributesType(node, false);
            }
        }
        function getJsxAttributePropertySymbol(attrib) {
            var attributesType = getAttributesTypeFromJsxOpeningLikeElement(attrib.parent.parent);
            var prop = getPropertyOfType(attributesType, attrib.name.text);
            return prop || unknownSymbol;
        }
        function getJsxGlobalElementClassType() {
            if (!deferredJsxElementClassType) {
                deferredJsxElementClassType = getExportedTypeFromNamespace(JsxNames.JSX, JsxNames.ElementClass);
            }
            return deferredJsxElementClassType;
        }
        function getJsxGlobalElementType() {
            if (!deferredJsxElementType) {
                deferredJsxElementType = getExportedTypeFromNamespace(JsxNames.JSX, JsxNames.Element);
            }
            return deferredJsxElementType;
        }
        function getJsxGlobalStatelessElementType() {
            if (!deferredJsxStatelessElementType) {
                var jsxElementType = getJsxGlobalElementType();
                if (jsxElementType) {
                    deferredJsxStatelessElementType = getUnionType([jsxElementType, nullType]);
                }
            }
            return deferredJsxStatelessElementType;
        }
        function getJsxIntrinsicTagNames() {
            var intrinsics = getJsxType(JsxNames.IntrinsicElements);
            return intrinsics ? getPropertiesOfType(intrinsics) : emptyArray;
        }
        function checkJsxPreconditions(errorNode) {
            if ((compilerOptions.jsx || 0) === 0) {
                error(errorNode, ts.Diagnostics.Cannot_use_JSX_unless_the_jsx_flag_is_provided);
            }
            if (getJsxGlobalElementType() === undefined) {
                if (noImplicitAny) {
                    error(errorNode, ts.Diagnostics.JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist);
                }
            }
        }
        function checkJsxOpeningLikeElement(node) {
            checkGrammarJsxElement(node);
            checkJsxPreconditions(node);
            var reactRefErr = compilerOptions.jsx === 2 ? ts.Diagnostics.Cannot_find_name_0 : undefined;
            var reactNamespace = getJsxNamespace();
            var reactSym = resolveName(node.tagName, reactNamespace, 107455, reactRefErr, reactNamespace);
            if (reactSym) {
                reactSym.isReferenced = true;
                if (reactSym.flags & 8388608 && !isConstEnumOrConstEnumOnlyModule(resolveAlias(reactSym))) {
                    markAliasSymbolAsReferenced(reactSym);
                }
            }
            checkJsxAttributesAssignableToTagNameAttributes(node);
        }
        function isKnownProperty(targetType, name, isComparingJsxAttributes) {
            if (targetType.flags & 32768) {
                var resolved = resolveStructuredTypeMembers(targetType);
                if (resolved.stringIndexInfo || resolved.numberIndexInfo && isNumericLiteralName(name) ||
                    getPropertyOfType(targetType, name) || isComparingJsxAttributes && !isUnhyphenatedJsxName(name)) {
                    return true;
                }
            }
            else if (targetType.flags & 196608) {
                for (var _i = 0, _a = targetType.types; _i < _a.length; _i++) {
                    var t = _a[_i];
                    if (isKnownProperty(t, name, isComparingJsxAttributes)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function checkJsxAttributesAssignableToTagNameAttributes(openingLikeElement) {
            var targetAttributesType = isJsxIntrinsicIdentifier(openingLikeElement.tagName) ?
                getIntrinsicAttributesTypeFromJsxOpeningLikeElement(openingLikeElement) :
                getCustomJsxElementAttributesType(openingLikeElement, false);
            var sourceAttributesType = createJsxAttributesTypeFromAttributesProperty(openingLikeElement, function (attribute) {
                return isUnhyphenatedJsxName(attribute.name) || !!(getPropertyOfType(targetAttributesType, attribute.name));
            });
            if (targetAttributesType === emptyObjectType && (isTypeAny(sourceAttributesType) || sourceAttributesType.properties.length > 0)) {
                error(openingLikeElement, ts.Diagnostics.JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property, getJsxElementPropertiesName());
            }
            else {
                var isSourceAttributeTypeAssignableToTarget = checkTypeAssignableTo(sourceAttributesType, targetAttributesType, openingLikeElement.attributes.properties.length > 0 ? openingLikeElement.attributes : openingLikeElement);
                if (isSourceAttributeTypeAssignableToTarget && !isTypeAny(sourceAttributesType) && !isTypeAny(targetAttributesType)) {
                    for (var _i = 0, _a = openingLikeElement.attributes.properties; _i < _a.length; _i++) {
                        var attribute = _a[_i];
                        if (ts.isJsxAttribute(attribute) && !isKnownProperty(targetAttributesType, attribute.name.text, true)) {
                            error(attribute, ts.Diagnostics.Property_0_does_not_exist_on_type_1, attribute.name.text, typeToString(targetAttributesType));
                            break;
                        }
                    }
                }
            }
        }
        function checkJsxExpression(node, checkMode) {
            if (node.expression) {
                var type = checkExpression(node.expression, checkMode);
                if (node.dotDotDotToken && type !== anyType && !isArrayType(type)) {
                    error(node, ts.Diagnostics.JSX_spread_child_must_be_an_array_type, node.toString(), typeToString(type));
                }
                return type;
            }
            else {
                return unknownType;
            }
        }
        function getDeclarationKindFromSymbol(s) {
            return s.valueDeclaration ? s.valueDeclaration.kind : 149;
        }
        function getDeclarationModifierFlagsFromSymbol(s) {
            if (s.valueDeclaration) {
                var flags = ts.getCombinedModifierFlags(s.valueDeclaration);
                return s.parent && s.parent.flags & 32 ? flags : flags & ~28;
            }
            if (getCheckFlags(s) & 6) {
                var checkFlags = s.checkFlags;
                var accessModifier = checkFlags & 256 ? 8 :
                    checkFlags & 64 ? 4 :
                        16;
                var staticModifier = checkFlags & 512 ? 32 : 0;
                return accessModifier | staticModifier;
            }
            if (s.flags & 16777216) {
                return 4 | 32;
            }
            return 0;
        }
        function getDeclarationNodeFlagsFromSymbol(s) {
            return s.valueDeclaration ? ts.getCombinedNodeFlags(s.valueDeclaration) : 0;
        }
        function isMethodLike(symbol) {
            return !!(symbol.flags & 8192 || getCheckFlags(symbol) & 4);
        }
        function checkPropertyAccessibility(node, left, type, prop) {
            var flags = getDeclarationModifierFlagsFromSymbol(prop);
            var errorNode = node.kind === 179 || node.kind === 226 ?
                node.name :
                node.right;
            if (getCheckFlags(prop) & 256) {
                error(errorNode, ts.Diagnostics.Property_0_has_conflicting_declarations_and_is_inaccessible_in_type_1, symbolToString(prop), typeToString(type));
                return false;
            }
            if (left.kind === 97) {
                if (languageVersion < 2) {
                    var hasNonMethodDeclaration = forEachProperty(prop, function (p) {
                        var propKind = getDeclarationKindFromSymbol(p);
                        return propKind !== 151 && propKind !== 150;
                    });
                    if (hasNonMethodDeclaration) {
                        error(errorNode, ts.Diagnostics.Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword);
                        return false;
                    }
                }
                if (flags & 128) {
                    error(errorNode, ts.Diagnostics.Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression, symbolToString(prop), typeToString(getDeclaringClass(prop)));
                    return false;
                }
            }
            if (!(flags & 24)) {
                return true;
            }
            if (flags & 8) {
                var declaringClassDeclaration = getClassLikeDeclarationOfSymbol(getParentOfSymbol(prop));
                if (!isNodeWithinClass(node, declaringClassDeclaration)) {
                    error(errorNode, ts.Diagnostics.Property_0_is_private_and_only_accessible_within_class_1, symbolToString(prop), typeToString(getDeclaringClass(prop)));
                    return false;
                }
                return true;
            }
            if (left.kind === 97) {
                return true;
            }
            var enclosingClass = forEachEnclosingClass(node, function (enclosingDeclaration) {
                var enclosingClass = getDeclaredTypeOfSymbol(getSymbolOfNode(enclosingDeclaration));
                return isClassDerivedFromDeclaringClasses(enclosingClass, prop) ? enclosingClass : undefined;
            });
            if (!enclosingClass) {
                error(errorNode, ts.Diagnostics.Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses, symbolToString(prop), typeToString(getDeclaringClass(prop) || type));
                return false;
            }
            if (flags & 32) {
                return true;
            }
            if (type.flags & 16384 && type.isThisType) {
                type = getConstraintOfTypeParameter(type);
            }
            if (!(getObjectFlags(getTargetType(type)) & 3 && hasBaseType(type, enclosingClass))) {
                error(errorNode, ts.Diagnostics.Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1, symbolToString(prop), typeToString(enclosingClass));
                return false;
            }
            return true;
        }
        function checkNonNullExpression(node) {
            return checkNonNullType(checkExpression(node), node);
        }
        function checkNonNullType(type, errorNode) {
            var kind = (strictNullChecks ? getFalsyFlags(type) : type.flags) & 6144;
            if (kind) {
                error(errorNode, kind & 2048 ? kind & 4096 ?
                    ts.Diagnostics.Object_is_possibly_null_or_undefined :
                    ts.Diagnostics.Object_is_possibly_undefined :
                    ts.Diagnostics.Object_is_possibly_null);
                var t = getNonNullableType(type);
                return t.flags & (6144 | 8192) ? unknownType : t;
            }
            return type;
        }
        function checkPropertyAccessExpression(node) {
            return checkPropertyAccessExpressionOrQualifiedName(node, node.expression, node.name);
        }
        function checkQualifiedName(node) {
            return checkPropertyAccessExpressionOrQualifiedName(node, node.left, node.right);
        }
        function reportNonexistentProperty(propNode, containingType) {
            var errorInfo;
            if (containingType.flags & 65536 && !(containingType.flags & 8190)) {
                for (var _i = 0, _a = containingType.types; _i < _a.length; _i++) {
                    var subtype = _a[_i];
                    if (!getPropertyOfType(subtype, propNode.text)) {
                        errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(propNode), typeToString(subtype));
                        break;
                    }
                }
            }
            errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Property_0_does_not_exist_on_type_1, ts.declarationNameToString(propNode), typeToString(containingType));
            diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(propNode, errorInfo));
        }
        function markPropertyAsReferenced(prop) {
            if (prop &&
                noUnusedIdentifiers &&
                (prop.flags & 106500) &&
                prop.valueDeclaration && (ts.getModifierFlags(prop.valueDeclaration) & 8)) {
                if (getCheckFlags(prop) & 1) {
                    getSymbolLinks(prop).target.isReferenced = true;
                }
                else {
                    prop.isReferenced = true;
                }
            }
        }
        function isInPropertyInitializer(node) {
            while (node) {
                if (node.parent && node.parent.kind === 149 && node.parent.initializer === node) {
                    return true;
                }
                node = node.parent;
            }
            return false;
        }
        function checkPropertyAccessExpressionOrQualifiedName(node, left, right) {
            var type = checkNonNullExpression(left);
            if (isTypeAny(type) || type === silentNeverType) {
                return type;
            }
            var apparentType = getApparentType(getWidenedType(type));
            if (apparentType === unknownType || (type.flags & 16384 && isTypeAny(apparentType))) {
                return apparentType;
            }
            var prop = getPropertyOfType(apparentType, right.text);
            if (!prop) {
                var stringIndexType = getIndexTypeOfType(apparentType, 0);
                if (stringIndexType) {
                    return stringIndexType;
                }
                if (right.text && !checkAndReportErrorForExtendingInterface(node)) {
                    reportNonexistentProperty(right, type.flags & 16384 && type.isThisType ? apparentType : type);
                }
                return unknownType;
            }
            if (prop.valueDeclaration) {
                if (isInPropertyInitializer(node) &&
                    !isBlockScopedNameDeclaredBeforeUse(prop.valueDeclaration, right)) {
                    error(right, ts.Diagnostics.Block_scoped_variable_0_used_before_its_declaration, right.text);
                }
                if (prop.valueDeclaration.kind === 229 &&
                    node.parent && node.parent.kind !== 159 &&
                    !ts.isInAmbientContext(prop.valueDeclaration) &&
                    !isBlockScopedNameDeclaredBeforeUse(prop.valueDeclaration, right)) {
                    error(right, ts.Diagnostics.Class_0_used_before_its_declaration, right.text);
                }
            }
            markPropertyAsReferenced(prop);
            getNodeLinks(node).resolvedSymbol = prop;
            checkPropertyAccessibility(node, left, apparentType, prop);
            var propType = getTypeOfSymbol(prop);
            var assignmentKind = ts.getAssignmentTargetKind(node);
            if (assignmentKind) {
                if (isReferenceToReadonlyEntity(node, prop) || isReferenceThroughNamespaceImport(node)) {
                    error(right, ts.Diagnostics.Cannot_assign_to_0_because_it_is_a_constant_or_a_read_only_property, right.text);
                    return unknownType;
                }
            }
            if (node.kind !== 179 || assignmentKind === 1 ||
                !(prop.flags & (3 | 4 | 98304)) &&
                    !(prop.flags & 8192 && propType.flags & 65536)) {
                return propType;
            }
            var flowType = getFlowTypeOfReference(node, propType);
            return assignmentKind ? getBaseTypeOfLiteralType(flowType) : flowType;
        }
        function isValidPropertyAccess(node, propertyName) {
            var left = node.kind === 179
                ? node.expression
                : node.left;
            var type = checkExpression(left);
            if (type !== unknownType && !isTypeAny(type)) {
                var prop = getPropertyOfType(getWidenedType(type), propertyName);
                if (prop) {
                    return checkPropertyAccessibility(node, left, type, prop);
                }
            }
            return true;
        }
        function getForInVariableSymbol(node) {
            var initializer = node.initializer;
            if (initializer.kind === 227) {
                var variable = initializer.declarations[0];
                if (variable && !ts.isBindingPattern(variable.name)) {
                    return getSymbolOfNode(variable);
                }
            }
            else if (initializer.kind === 71) {
                return getResolvedSymbol(initializer);
            }
            return undefined;
        }
        function hasNumericPropertyNames(type) {
            return getIndexTypeOfType(type, 1) && !getIndexTypeOfType(type, 0);
        }
        function isForInVariableForNumericPropertyNames(expr) {
            var e = ts.skipParentheses(expr);
            if (e.kind === 71) {
                var symbol = getResolvedSymbol(e);
                if (symbol.flags & 3) {
                    var child = expr;
                    var node = expr.parent;
                    while (node) {
                        if (node.kind === 215 &&
                            child === node.statement &&
                            getForInVariableSymbol(node) === symbol &&
                            hasNumericPropertyNames(getTypeOfExpression(node.expression))) {
                            return true;
                        }
                        child = node;
                        node = node.parent;
                    }
                }
            }
            return false;
        }
        function checkIndexedAccess(node) {
            var objectType = checkNonNullExpression(node.expression);
            var indexExpression = node.argumentExpression;
            if (!indexExpression) {
                var sourceFile = ts.getSourceFileOfNode(node);
                if (node.parent.kind === 182 && node.parent.expression === node) {
                    var start = ts.skipTrivia(sourceFile.text, node.expression.end);
                    var end = node.end;
                    grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead);
                }
                else {
                    var start = node.end - "]".length;
                    var end = node.end;
                    grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.Expression_expected);
                }
                return unknownType;
            }
            var indexType = isForInVariableForNumericPropertyNames(indexExpression) ? numberType : checkExpression(indexExpression);
            if (objectType === unknownType || objectType === silentNeverType) {
                return objectType;
            }
            if (isConstEnumObjectType(objectType) && indexExpression.kind !== 9) {
                error(indexExpression, ts.Diagnostics.A_const_enum_member_can_only_be_accessed_using_a_string_literal);
                return unknownType;
            }
            return checkIndexedAccessIndexType(getIndexedAccessType(objectType, indexType, node), node);
        }
        function checkThatExpressionIsProperSymbolReference(expression, expressionType, reportError) {
            if (expressionType === unknownType) {
                return false;
            }
            if (!ts.isWellKnownSymbolSyntactically(expression)) {
                return false;
            }
            if ((expressionType.flags & 512) === 0) {
                if (reportError) {
                    error(expression, ts.Diagnostics.A_computed_property_name_of_the_form_0_must_be_of_type_symbol, ts.getTextOfNode(expression));
                }
                return false;
            }
            var leftHandSide = expression.expression;
            var leftHandSideSymbol = getResolvedSymbol(leftHandSide);
            if (!leftHandSideSymbol) {
                return false;
            }
            var globalESSymbol = getGlobalESSymbolConstructorSymbol(true);
            if (!globalESSymbol) {
                return false;
            }
            if (leftHandSideSymbol !== globalESSymbol) {
                if (reportError) {
                    error(leftHandSide, ts.Diagnostics.Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object);
                }
                return false;
            }
            return true;
        }
        function resolveUntypedCall(node) {
            if (node.kind === 183) {
                checkExpression(node.template);
            }
            else if (node.kind !== 147) {
                ts.forEach(node.arguments, function (argument) {
                    checkExpression(argument);
                });
            }
            return anySignature;
        }
        function resolveErrorCall(node) {
            resolveUntypedCall(node);
            return unknownSignature;
        }
        function reorderCandidates(signatures, result) {
            var lastParent;
            var lastSymbol;
            var cutoffIndex = 0;
            var index;
            var specializedIndex = -1;
            var spliceIndex;
            ts.Debug.assert(!result.length);
            for (var _i = 0, signatures_4 = signatures; _i < signatures_4.length; _i++) {
                var signature = signatures_4[_i];
                var symbol = signature.declaration && getSymbolOfNode(signature.declaration);
                var parent = signature.declaration && signature.declaration.parent;
                if (!lastSymbol || symbol === lastSymbol) {
                    if (lastParent && parent === lastParent) {
                        index++;
                    }
                    else {
                        lastParent = parent;
                        index = cutoffIndex;
                    }
                }
                else {
                    index = cutoffIndex = result.length;
                    lastParent = parent;
                }
                lastSymbol = symbol;
                if (signature.hasLiteralTypes) {
                    specializedIndex++;
                    spliceIndex = specializedIndex;
                    cutoffIndex++;
                }
                else {
                    spliceIndex = index;
                }
                result.splice(spliceIndex, 0, signature);
            }
        }
        function getSpreadArgumentIndex(args) {
            for (var i = 0; i < args.length; i++) {
                var arg = args[i];
                if (arg && arg.kind === 198) {
                    return i;
                }
            }
            return -1;
        }
        function hasCorrectArity(node, args, signature, signatureHelpTrailingComma) {
            if (signatureHelpTrailingComma === void 0) { signatureHelpTrailingComma = false; }
            var argCount;
            var typeArguments;
            var callIsIncomplete;
            var isDecorator;
            var spreadArgIndex = -1;
            if (ts.isJsxOpeningLikeElement(node)) {
                return true;
            }
            if (node.kind === 183) {
                var tagExpression = node;
                argCount = args.length;
                typeArguments = undefined;
                if (tagExpression.template.kind === 196) {
                    var templateExpression = tagExpression.template;
                    var lastSpan = ts.lastOrUndefined(templateExpression.templateSpans);
                    ts.Debug.assert(lastSpan !== undefined);
                    callIsIncomplete = ts.nodeIsMissing(lastSpan.literal) || !!lastSpan.literal.isUnterminated;
                }
                else {
                    var templateLiteral = tagExpression.template;
                    ts.Debug.assert(templateLiteral.kind === 13);
                    callIsIncomplete = !!templateLiteral.isUnterminated;
                }
            }
            else if (node.kind === 147) {
                isDecorator = true;
                typeArguments = undefined;
                argCount = getEffectiveArgumentCount(node, undefined, signature);
            }
            else {
                var callExpression = node;
                if (!callExpression.arguments) {
                    ts.Debug.assert(callExpression.kind === 182);
                    return signature.minArgumentCount === 0;
                }
                argCount = signatureHelpTrailingComma ? args.length + 1 : args.length;
                callIsIncomplete = callExpression.arguments.end === callExpression.end;
                typeArguments = callExpression.typeArguments;
                spreadArgIndex = getSpreadArgumentIndex(args);
            }
            var numTypeParameters = ts.length(signature.typeParameters);
            var minTypeArgumentCount = getMinTypeArgumentCount(signature.typeParameters);
            var hasRightNumberOfTypeArgs = !typeArguments ||
                (typeArguments.length >= minTypeArgumentCount && typeArguments.length <= numTypeParameters);
            if (!hasRightNumberOfTypeArgs) {
                return false;
            }
            if (spreadArgIndex >= 0) {
                return isRestParameterIndex(signature, spreadArgIndex);
            }
            if (!signature.hasRestParameter && argCount > signature.parameters.length) {
                return false;
            }
            var hasEnoughArguments = argCount >= signature.minArgumentCount;
            return callIsIncomplete || hasEnoughArguments;
        }
        function getSingleCallSignature(type) {
            if (type.flags & 32768) {
                var resolved = resolveStructuredTypeMembers(type);
                if (resolved.callSignatures.length === 1 && resolved.constructSignatures.length === 0 &&
                    resolved.properties.length === 0 && !resolved.stringIndexInfo && !resolved.numberIndexInfo) {
                    return resolved.callSignatures[0];
                }
            }
            return undefined;
        }
        function instantiateSignatureInContextOf(signature, contextualSignature, contextualMapper) {
            var context = createInferenceContext(signature, true, false);
            forEachMatchingParameterType(contextualSignature, signature, function (source, target) {
                inferTypesWithContext(context, instantiateType(source, contextualMapper), target);
            });
            return getSignatureInstantiation(signature, getInferredTypes(context));
        }
        function inferTypeArguments(node, signature, args, excludeArgument, context) {
            var typeParameters = signature.typeParameters;
            var inferenceMapper = getInferenceMapper(context);
            for (var i = 0; i < typeParameters.length; i++) {
                if (!context.inferences[i].isFixed) {
                    context.inferredTypes[i] = undefined;
                }
            }
            if (context.failedTypeParameterIndex !== undefined && !context.inferences[context.failedTypeParameterIndex].isFixed) {
                context.failedTypeParameterIndex = undefined;
            }
            var thisType = getThisTypeOfSignature(signature);
            if (thisType) {
                var thisArgumentNode = getThisArgumentOfCall(node);
                var thisArgumentType = thisArgumentNode ? checkExpression(thisArgumentNode) : voidType;
                inferTypesWithContext(context, thisArgumentType, thisType);
            }
            var argCount = getEffectiveArgumentCount(node, args, signature);
            for (var i = 0; i < argCount; i++) {
                var arg = getEffectiveArgument(node, args, i);
                if (arg === undefined || arg.kind !== 200) {
                    var paramType = getTypeAtPosition(signature, i);
                    var argType = getEffectiveArgumentType(node, i);
                    if (argType === undefined) {
                        var mapper = excludeArgument && excludeArgument[i] !== undefined ? identityMapper : inferenceMapper;
                        argType = checkExpressionWithContextualType(arg, paramType, mapper);
                    }
                    inferTypesWithContext(context, argType, paramType);
                }
            }
            if (excludeArgument) {
                for (var i = 0; i < argCount; i++) {
                    if (excludeArgument[i] === false) {
                        var arg = args[i];
                        var paramType = getTypeAtPosition(signature, i);
                        inferTypesWithContext(context, checkExpressionWithContextualType(arg, paramType, inferenceMapper), paramType);
                    }
                }
            }
            getInferredTypes(context);
        }
        function checkTypeArguments(signature, typeArgumentNodes, typeArgumentTypes, reportErrors, headMessage) {
            var typeParameters = signature.typeParameters;
            var typeArgumentsAreAssignable = true;
            var mapper;
            for (var i = 0; i < typeArgumentNodes.length; i++) {
                if (typeArgumentsAreAssignable) {
                    var constraint = getConstraintOfTypeParameter(typeParameters[i]);
                    if (constraint) {
                        var errorInfo = void 0;
                        var typeArgumentHeadMessage = ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1;
                        if (reportErrors && headMessage) {
                            errorInfo = ts.chainDiagnosticMessages(errorInfo, typeArgumentHeadMessage);
                            typeArgumentHeadMessage = headMessage;
                        }
                        if (!mapper) {
                            mapper = createTypeMapper(typeParameters, typeArgumentTypes);
                        }
                        var typeArgument = typeArgumentTypes[i];
                        typeArgumentsAreAssignable = checkTypeAssignableTo(typeArgument, getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument), reportErrors ? typeArgumentNodes[i] : undefined, typeArgumentHeadMessage, errorInfo);
                    }
                }
            }
            return typeArgumentsAreAssignable;
        }
        function checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation) {
            var callIsIncomplete = node.attributes.end === node.end;
            if (callIsIncomplete) {
                return true;
            }
            var headMessage = ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
            var paramType = getTypeAtPosition(signature, 0);
            var attributesType = checkExpressionWithContextualType(node.attributes, paramType, undefined);
            var argProperties = getPropertiesOfType(attributesType);
            for (var _i = 0, argProperties_1 = argProperties; _i < argProperties_1.length; _i++) {
                var arg = argProperties_1[_i];
                if (!getPropertyOfType(paramType, arg.name) && isUnhyphenatedJsxName(arg.name)) {
                    return false;
                }
            }
            return checkTypeRelatedTo(attributesType, paramType, relation, undefined, headMessage);
        }
        function checkApplicableSignature(node, args, signature, relation, excludeArgument, reportErrors) {
            if (ts.isJsxOpeningLikeElement(node)) {
                return checkApplicableSignatureForJsxOpeningLikeElement(node, signature, relation);
            }
            var thisType = getThisTypeOfSignature(signature);
            if (thisType && thisType !== voidType && node.kind !== 182) {
                var thisArgumentNode = getThisArgumentOfCall(node);
                var thisArgumentType = thisArgumentNode ? checkExpression(thisArgumentNode) : voidType;
                var errorNode = reportErrors ? (thisArgumentNode || node) : undefined;
                var headMessage_1 = ts.Diagnostics.The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1;
                if (!checkTypeRelatedTo(thisArgumentType, getThisTypeOfSignature(signature), relation, errorNode, headMessage_1)) {
                    return false;
                }
            }
            var headMessage = ts.Diagnostics.Argument_of_type_0_is_not_assignable_to_parameter_of_type_1;
            var argCount = getEffectiveArgumentCount(node, args, signature);
            for (var i = 0; i < argCount; i++) {
                var arg = getEffectiveArgument(node, args, i);
                if (arg === undefined || arg.kind !== 200) {
                    var paramType = getTypeAtPosition(signature, i);
                    var argType = getEffectiveArgumentType(node, i);
                    if (argType === undefined) {
                        argType = checkExpressionWithContextualType(arg, paramType, excludeArgument && excludeArgument[i] ? identityMapper : undefined);
                    }
                    var errorNode = reportErrors ? getEffectiveArgumentErrorNode(node, i, arg) : undefined;
                    if (!checkTypeRelatedTo(argType, paramType, relation, errorNode, headMessage)) {
                        return false;
                    }
                }
            }
            return true;
        }
        function getThisArgumentOfCall(node) {
            if (node.kind === 181) {
                var callee = node.expression;
                if (callee.kind === 179) {
                    return callee.expression;
                }
                else if (callee.kind === 180) {
                    return callee.expression;
                }
            }
        }
        function getEffectiveCallArguments(node) {
            var args;
            if (node.kind === 183) {
                var template = node.template;
                args = [undefined];
                if (template.kind === 196) {
                    ts.forEach(template.templateSpans, function (span) {
                        args.push(span.expression);
                    });
                }
            }
            else if (node.kind === 147) {
                return undefined;
            }
            else if (ts.isJsxOpeningLikeElement(node)) {
                args = node.attributes.properties.length > 0 ? [node.attributes] : emptyArray;
            }
            else {
                args = node.arguments || emptyArray;
            }
            return args;
        }
        function getEffectiveArgumentCount(node, args, signature) {
            if (node.kind === 147) {
                switch (node.parent.kind) {
                    case 229:
                    case 199:
                        return 1;
                    case 149:
                        return 2;
                    case 151:
                    case 153:
                    case 154:
                        if (languageVersion === 0) {
                            return 2;
                        }
                        return signature.parameters.length >= 3 ? 3 : 2;
                    case 146:
                        return 3;
                }
            }
            else {
                return args.length;
            }
        }
        function getEffectiveDecoratorFirstArgumentType(node) {
            if (node.kind === 229) {
                var classSymbol = getSymbolOfNode(node);
                return getTypeOfSymbol(classSymbol);
            }
            if (node.kind === 146) {
                node = node.parent;
                if (node.kind === 152) {
                    var classSymbol = getSymbolOfNode(node);
                    return getTypeOfSymbol(classSymbol);
                }
            }
            if (node.kind === 149 ||
                node.kind === 151 ||
                node.kind === 153 ||
                node.kind === 154) {
                return getParentTypeOfClassElement(node);
            }
            ts.Debug.fail("Unsupported decorator target.");
            return unknownType;
        }
        function getEffectiveDecoratorSecondArgumentType(node) {
            if (node.kind === 229) {
                ts.Debug.fail("Class decorators should not have a second synthetic argument.");
                return unknownType;
            }
            if (node.kind === 146) {
                node = node.parent;
                if (node.kind === 152) {
                    return anyType;
                }
            }
            if (node.kind === 149 ||
                node.kind === 151 ||
                node.kind === 153 ||
                node.kind === 154) {
                var element = node;
                switch (element.name.kind) {
                    case 71:
                    case 8:
                    case 9:
                        return getLiteralTypeForText(32, element.name.text);
                    case 144:
                        var nameType = checkComputedPropertyName(element.name);
                        if (isTypeOfKind(nameType, 512)) {
                            return nameType;
                        }
                        else {
                            return stringType;
                        }
                    default:
                        ts.Debug.fail("Unsupported property name.");
                        return unknownType;
                }
            }
            ts.Debug.fail("Unsupported decorator target.");
            return unknownType;
        }
        function getEffectiveDecoratorThirdArgumentType(node) {
            if (node.kind === 229) {
                ts.Debug.fail("Class decorators should not have a third synthetic argument.");
                return unknownType;
            }
            if (node.kind === 146) {
                return numberType;
            }
            if (node.kind === 149) {
                ts.Debug.fail("Property decorators should not have a third synthetic argument.");
                return unknownType;
            }
            if (node.kind === 151 ||
                node.kind === 153 ||
                node.kind === 154) {
                var propertyType = getTypeOfNode(node);
                return createTypedPropertyDescriptorType(propertyType);
            }
            ts.Debug.fail("Unsupported decorator target.");
            return unknownType;
        }
        function getEffectiveDecoratorArgumentType(node, argIndex) {
            if (argIndex === 0) {
                return getEffectiveDecoratorFirstArgumentType(node.parent);
            }
            else if (argIndex === 1) {
                return getEffectiveDecoratorSecondArgumentType(node.parent);
            }
            else if (argIndex === 2) {
                return getEffectiveDecoratorThirdArgumentType(node.parent);
            }
            ts.Debug.fail("Decorators should not have a fourth synthetic argument.");
            return unknownType;
        }
        function getEffectiveArgumentType(node, argIndex) {
            if (node.kind === 147) {
                return getEffectiveDecoratorArgumentType(node, argIndex);
            }
            else if (argIndex === 0 && node.kind === 183) {
                return getGlobalTemplateStringsArrayType();
            }
            return undefined;
        }
        function getEffectiveArgument(node, args, argIndex) {
            if (node.kind === 147 ||
                (argIndex === 0 && node.kind === 183)) {
                return undefined;
            }
            return args[argIndex];
        }
        function getEffectiveArgumentErrorNode(node, argIndex, arg) {
            if (node.kind === 147) {
                return node.expression;
            }
            else if (argIndex === 0 && node.kind === 183) {
                return node.template;
            }
            else {
                return arg;
            }
        }
        function resolveCall(node, signatures, candidatesOutArray, headMessage) {
            var isTaggedTemplate = node.kind === 183;
            var isDecorator = node.kind === 147;
            var isJsxOpeningOrSelfClosingElement = ts.isJsxOpeningLikeElement(node);
            var typeArguments;
            if (!isTaggedTemplate && !isDecorator && !isJsxOpeningOrSelfClosingElement) {
                typeArguments = node.typeArguments;
                if (node.expression.kind !== 97) {
                    ts.forEach(typeArguments, checkSourceElement);
                }
            }
            if (signatures.length === 1) {
                var declaration = signatures[0].declaration;
                if (declaration && ts.isInJavaScriptFile(declaration) && !ts.hasJSDocParameterTags(declaration)) {
                    if (containsArgumentsReference(declaration)) {
                        var signatureWithRest = cloneSignature(signatures[0]);
                        var syntheticArgsSymbol = createSymbol(3, "args");
                        syntheticArgsSymbol.type = anyArrayType;
                        syntheticArgsSymbol.isRestParameter = true;
                        signatureWithRest.parameters = ts.concatenate(signatureWithRest.parameters, [syntheticArgsSymbol]);
                        signatureWithRest.hasRestParameter = true;
                        signatures = [signatureWithRest];
                    }
                }
            }
            var candidates = candidatesOutArray || [];
            reorderCandidates(signatures, candidates);
            if (!candidates.length) {
                reportError(ts.Diagnostics.Supplied_parameters_do_not_match_any_signature_of_call_target);
                return resolveErrorCall(node);
            }
            var args = getEffectiveCallArguments(node);
            var excludeArgument;
            if (!isDecorator) {
                for (var i = isTaggedTemplate ? 1 : 0; i < args.length; i++) {
                    if (isContextSensitive(args[i])) {
                        if (!excludeArgument) {
                            excludeArgument = new Array(args.length);
                        }
                        excludeArgument[i] = true;
                    }
                }
            }
            var candidateForArgumentError;
            var candidateForTypeArgumentError;
            var resultOfFailedInference;
            var result;
            var signatureHelpTrailingComma = candidatesOutArray && node.kind === 181 && node.arguments.hasTrailingComma;
            if (candidates.length > 1) {
                result = chooseOverload(candidates, subtypeRelation, signatureHelpTrailingComma);
            }
            if (!result) {
                candidateForArgumentError = undefined;
                candidateForTypeArgumentError = undefined;
                resultOfFailedInference = undefined;
                result = chooseOverload(candidates, assignableRelation, signatureHelpTrailingComma);
            }
            if (result) {
                return result;
            }
            if (candidateForArgumentError) {
                if (isJsxOpeningOrSelfClosingElement) {
                    return candidateForArgumentError;
                }
                checkApplicableSignature(node, args, candidateForArgumentError, assignableRelation, undefined, true);
            }
            else if (candidateForTypeArgumentError) {
                if (!isTaggedTemplate && !isDecorator && typeArguments) {
                    var typeArguments_2 = node.typeArguments;
                    checkTypeArguments(candidateForTypeArgumentError, typeArguments_2, ts.map(typeArguments_2, getTypeFromTypeNode), true, headMessage);
                }
                else {
                    ts.Debug.assert(resultOfFailedInference.failedTypeParameterIndex >= 0);
                    var failedTypeParameter = candidateForTypeArgumentError.typeParameters[resultOfFailedInference.failedTypeParameterIndex];
                    var inferenceCandidates = getInferenceCandidates(resultOfFailedInference, resultOfFailedInference.failedTypeParameterIndex);
                    var diagnosticChainHead = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly, typeToString(failedTypeParameter));
                    if (headMessage) {
                        diagnosticChainHead = ts.chainDiagnosticMessages(diagnosticChainHead, headMessage);
                    }
                    reportNoCommonSupertypeError(inferenceCandidates, node.tagName || node.expression || node.tag, diagnosticChainHead);
                }
            }
            else {
                reportError(ts.Diagnostics.Supplied_parameters_do_not_match_any_signature_of_call_target);
            }
            if (!produceDiagnostics) {
                for (var _i = 0, candidates_1 = candidates; _i < candidates_1.length; _i++) {
                    var candidate = candidates_1[_i];
                    if (hasCorrectArity(node, args, candidate)) {
                        if (candidate.typeParameters && typeArguments) {
                            candidate = getSignatureInstantiation(candidate, ts.map(typeArguments, getTypeFromTypeNode));
                        }
                        return candidate;
                    }
                }
            }
            return resolveErrorCall(node);
            function reportError(message, arg0, arg1, arg2) {
                var errorInfo;
                errorInfo = ts.chainDiagnosticMessages(errorInfo, message, arg0, arg1, arg2);
                if (headMessage) {
                    errorInfo = ts.chainDiagnosticMessages(errorInfo, headMessage);
                }
                diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(node, errorInfo));
            }
            function chooseOverload(candidates, relation, signatureHelpTrailingComma) {
                if (signatureHelpTrailingComma === void 0) { signatureHelpTrailingComma = false; }
                for (var _i = 0, candidates_2 = candidates; _i < candidates_2.length; _i++) {
                    var originalCandidate = candidates_2[_i];
                    if (!hasCorrectArity(node, args, originalCandidate, signatureHelpTrailingComma)) {
                        continue;
                    }
                    var candidate = void 0;
                    var typeArgumentsAreValid = void 0;
                    var inferenceContext = originalCandidate.typeParameters
                        ? createInferenceContext(originalCandidate, false, ts.isInJavaScriptFile(node))
                        : undefined;
                    while (true) {
                        candidate = originalCandidate;
                        if (candidate.typeParameters) {
                            var typeArgumentTypes = void 0;
                            if (typeArguments) {
                                typeArgumentTypes = fillMissingTypeArguments(ts.map(typeArguments, getTypeFromTypeNode), candidate.typeParameters, getMinTypeArgumentCount(candidate.typeParameters));
                                typeArgumentsAreValid = checkTypeArguments(candidate, typeArguments, typeArgumentTypes, false);
                            }
                            else {
                                inferTypeArguments(node, candidate, args, excludeArgument, inferenceContext);
                                typeArgumentTypes = inferenceContext.inferredTypes;
                                typeArgumentsAreValid = inferenceContext.failedTypeParameterIndex === undefined;
                            }
                            if (!typeArgumentsAreValid) {
                                break;
                            }
                            candidate = getSignatureInstantiation(candidate, typeArgumentTypes);
                        }
                        if (!checkApplicableSignature(node, args, candidate, relation, excludeArgument, false)) {
                            break;
                        }
                        var index = excludeArgument ? ts.indexOf(excludeArgument, true) : -1;
                        if (index < 0) {
                            return candidate;
                        }
                        excludeArgument[index] = false;
                    }
                    if (originalCandidate.typeParameters) {
                        var instantiatedCandidate = candidate;
                        if (typeArgumentsAreValid) {
                            candidateForArgumentError = instantiatedCandidate;
                        }
                        else {
                            candidateForTypeArgumentError = originalCandidate;
                            if (!typeArguments) {
                                resultOfFailedInference = inferenceContext;
                            }
                        }
                    }
                    else {
                        ts.Debug.assert(originalCandidate === candidate);
                        candidateForArgumentError = originalCandidate;
                    }
                }
                return undefined;
            }
        }
        function resolveCallExpression(node, candidatesOutArray) {
            if (node.expression.kind === 97) {
                var superType = checkSuperExpression(node.expression);
                if (superType !== unknownType) {
                    var baseTypeNode = ts.getClassExtendsHeritageClauseElement(ts.getContainingClass(node));
                    if (baseTypeNode) {
                        var baseConstructors = getInstantiatedConstructorsForTypeArguments(superType, baseTypeNode.typeArguments, baseTypeNode);
                        return resolveCall(node, baseConstructors, candidatesOutArray);
                    }
                }
                return resolveUntypedCall(node);
            }
            var funcType = checkNonNullExpression(node.expression);
            if (funcType === silentNeverType) {
                return silentNeverSignature;
            }
            var apparentType = getApparentType(funcType);
            if (apparentType === unknownType) {
                return resolveErrorCall(node);
            }
            var callSignatures = getSignaturesOfType(apparentType, 0);
            var constructSignatures = getSignaturesOfType(apparentType, 1);
            if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, constructSignatures.length)) {
                if (funcType !== unknownType && node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            if (!callSignatures.length) {
                if (constructSignatures.length) {
                    error(node, ts.Diagnostics.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, typeToString(funcType));
                }
                else {
                    error(node, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, typeToString(apparentType));
                }
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures, candidatesOutArray);
        }
        function isUntypedFunctionCall(funcType, apparentFuncType, numCallSignatures, numConstructSignatures) {
            if (isTypeAny(funcType)) {
                return true;
            }
            if (isTypeAny(apparentFuncType) && funcType.flags & 16384) {
                return true;
            }
            if (!numCallSignatures && !numConstructSignatures) {
                if (funcType.flags & 65536) {
                    return false;
                }
                return isTypeAssignableTo(funcType, globalFunctionType);
            }
            return false;
        }
        function resolveNewExpression(node, candidatesOutArray) {
            if (node.arguments && languageVersion < 1) {
                var spreadIndex = getSpreadArgumentIndex(node.arguments);
                if (spreadIndex >= 0) {
                    error(node.arguments[spreadIndex], ts.Diagnostics.Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher);
                }
            }
            var expressionType = checkNonNullExpression(node.expression);
            if (expressionType === silentNeverType) {
                return silentNeverSignature;
            }
            expressionType = getApparentType(expressionType);
            if (expressionType === unknownType) {
                return resolveErrorCall(node);
            }
            var valueDecl = expressionType.symbol && getClassLikeDeclarationOfSymbol(expressionType.symbol);
            if (valueDecl && ts.getModifierFlags(valueDecl) & 128) {
                error(node, ts.Diagnostics.Cannot_create_an_instance_of_the_abstract_class_0, ts.declarationNameToString(ts.getNameOfDeclaration(valueDecl)));
                return resolveErrorCall(node);
            }
            if (isTypeAny(expressionType)) {
                if (node.typeArguments) {
                    error(node, ts.Diagnostics.Untyped_function_calls_may_not_accept_type_arguments);
                }
                return resolveUntypedCall(node);
            }
            var constructSignatures = getSignaturesOfType(expressionType, 1);
            if (constructSignatures.length) {
                if (!isConstructorAccessible(node, constructSignatures[0])) {
                    return resolveErrorCall(node);
                }
                return resolveCall(node, constructSignatures, candidatesOutArray);
            }
            var callSignatures = getSignaturesOfType(expressionType, 0);
            if (callSignatures.length) {
                var signature = resolveCall(node, callSignatures, candidatesOutArray);
                if (getReturnTypeOfSignature(signature) !== voidType) {
                    error(node, ts.Diagnostics.Only_a_void_function_can_be_called_with_the_new_keyword);
                }
                if (getThisTypeOfSignature(signature) === voidType) {
                    error(node, ts.Diagnostics.A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void);
                }
                return signature;
            }
            error(node, ts.Diagnostics.Cannot_use_new_with_an_expression_whose_type_lacks_a_call_or_construct_signature);
            return resolveErrorCall(node);
        }
        function isConstructorAccessible(node, signature) {
            if (!signature || !signature.declaration) {
                return true;
            }
            var declaration = signature.declaration;
            var modifiers = ts.getModifierFlags(declaration);
            if (!(modifiers & 24)) {
                return true;
            }
            var declaringClassDeclaration = getClassLikeDeclarationOfSymbol(declaration.parent.symbol);
            var declaringClass = getDeclaredTypeOfSymbol(declaration.parent.symbol);
            if (!isNodeWithinClass(node, declaringClassDeclaration)) {
                var containingClass = ts.getContainingClass(node);
                if (containingClass) {
                    var containingType = getTypeOfNode(containingClass);
                    var baseTypes = getBaseTypes(containingType);
                    while (baseTypes.length) {
                        var baseType = baseTypes[0];
                        if (modifiers & 16 &&
                            baseType.symbol === declaration.parent.symbol) {
                            return true;
                        }
                        baseTypes = getBaseTypes(baseType);
                    }
                }
                if (modifiers & 8) {
                    error(node, ts.Diagnostics.Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
                }
                if (modifiers & 16) {
                    error(node, ts.Diagnostics.Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration, typeToString(declaringClass));
                }
                return false;
            }
            return true;
        }
        function resolveTaggedTemplateExpression(node, candidatesOutArray) {
            var tagType = checkExpression(node.tag);
            var apparentType = getApparentType(tagType);
            if (apparentType === unknownType) {
                return resolveErrorCall(node);
            }
            var callSignatures = getSignaturesOfType(apparentType, 0);
            var constructSignatures = getSignaturesOfType(apparentType, 1);
            if (isUntypedFunctionCall(tagType, apparentType, callSignatures.length, constructSignatures.length)) {
                return resolveUntypedCall(node);
            }
            if (!callSignatures.length) {
                error(node, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, typeToString(apparentType));
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures, candidatesOutArray);
        }
        function getDiagnosticHeadMessageForDecoratorResolution(node) {
            switch (node.parent.kind) {
                case 229:
                case 199:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression;
                case 146:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression;
                case 149:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression;
                case 151:
                case 153:
                case 154:
                    return ts.Diagnostics.Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression;
            }
        }
        function resolveDecorator(node, candidatesOutArray) {
            var funcType = checkExpression(node.expression);
            var apparentType = getApparentType(funcType);
            if (apparentType === unknownType) {
                return resolveErrorCall(node);
            }
            var callSignatures = getSignaturesOfType(apparentType, 0);
            var constructSignatures = getSignaturesOfType(apparentType, 1);
            if (isUntypedFunctionCall(funcType, apparentType, callSignatures.length, constructSignatures.length)) {
                return resolveUntypedCall(node);
            }
            var headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
            if (!callSignatures.length) {
                var errorInfo = void 0;
                errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature_Type_0_has_no_compatible_call_signatures, typeToString(apparentType));
                errorInfo = ts.chainDiagnosticMessages(errorInfo, headMessage);
                diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(node, errorInfo));
                return resolveErrorCall(node);
            }
            return resolveCall(node, callSignatures, candidatesOutArray, headMessage);
        }
        function getResolvedJsxStatelessFunctionSignature(openingLikeElement, elementType, candidatesOutArray) {
            ts.Debug.assert(!(elementType.flags & 65536));
            var callSignature = resolveStatelessJsxOpeningLikeElement(openingLikeElement, elementType, candidatesOutArray);
            return callSignature;
        }
        function resolveStatelessJsxOpeningLikeElement(openingLikeElement, elementType, candidatesOutArray) {
            if (elementType.flags & 65536) {
                var types = elementType.types;
                var result = void 0;
                for (var _i = 0, types_18 = types; _i < types_18.length; _i++) {
                    var type = types_18[_i];
                    result = result || resolveStatelessJsxOpeningLikeElement(openingLikeElement, type, candidatesOutArray);
                }
                return result;
            }
            var callSignatures = elementType && getSignaturesOfType(elementType, 0);
            if (callSignatures && callSignatures.length > 0) {
                var callSignature = void 0;
                callSignature = resolveCall(openingLikeElement, callSignatures, candidatesOutArray);
                return callSignature;
            }
            return undefined;
        }
        function resolveSignature(node, candidatesOutArray) {
            switch (node.kind) {
                case 181:
                    return resolveCallExpression(node, candidatesOutArray);
                case 182:
                    return resolveNewExpression(node, candidatesOutArray);
                case 183:
                    return resolveTaggedTemplateExpression(node, candidatesOutArray);
                case 147:
                    return resolveDecorator(node, candidatesOutArray);
                case 251:
                case 250:
                    return resolveStatelessJsxOpeningLikeElement(node, checkExpression(node.tagName), candidatesOutArray);
            }
            ts.Debug.fail("Branch in 'resolveSignature' should be unreachable.");
        }
        function getResolvedSignature(node, candidatesOutArray) {
            var links = getNodeLinks(node);
            var cached = links.resolvedSignature;
            if (cached && cached !== resolvingSignature && !candidatesOutArray) {
                return cached;
            }
            links.resolvedSignature = resolvingSignature;
            var result = resolveSignature(node, candidatesOutArray);
            links.resolvedSignature = flowLoopStart === flowLoopCount ? result : cached;
            return result;
        }
        function getResolvedOrAnySignature(node) {
            return getNodeLinks(node).resolvedSignature === resolvingSignature ? resolvingSignature : getResolvedSignature(node);
        }
        function getInferredClassType(symbol) {
            var links = getSymbolLinks(symbol);
            if (!links.inferredClassType) {
                links.inferredClassType = createAnonymousType(symbol, symbol.members, emptyArray, emptyArray, undefined, undefined);
            }
            return links.inferredClassType;
        }
        function checkCallExpression(node) {
            checkGrammarTypeArguments(node, node.typeArguments) || checkGrammarArguments(node, node.arguments);
            var signature = getResolvedSignature(node);
            if (node.expression.kind === 97) {
                return voidType;
            }
            if (node.kind === 182) {
                var declaration = signature.declaration;
                if (declaration &&
                    declaration.kind !== 152 &&
                    declaration.kind !== 156 &&
                    declaration.kind !== 161 &&
                    !ts.isJSDocConstructSignature(declaration)) {
                    var funcSymbol = node.expression.kind === 71 ?
                        getResolvedSymbol(node.expression) :
                        checkExpression(node.expression).symbol;
                    if (funcSymbol && ts.isDeclarationOfFunctionOrClassExpression(funcSymbol)) {
                        funcSymbol = getSymbolOfNode(funcSymbol.valueDeclaration.initializer);
                    }
                    if (funcSymbol && funcSymbol.members && funcSymbol.flags & 16) {
                        return getInferredClassType(funcSymbol);
                    }
                    else if (noImplicitAny) {
                        error(node, ts.Diagnostics.new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type);
                    }
                    return anyType;
                }
            }
            if (ts.isInJavaScriptFile(node) && isCommonJsRequire(node)) {
                return resolveExternalModuleTypeByLiteral(node.arguments[0]);
            }
            return getReturnTypeOfSignature(signature);
        }
        function isCommonJsRequire(node) {
            if (!ts.isRequireCall(node, true)) {
                return false;
            }
            var resolvedRequire = resolveName(node.expression, node.expression.text, 107455, undefined, undefined);
            if (!resolvedRequire) {
                return true;
            }
            if (resolvedRequire.flags & 8388608) {
                return false;
            }
            var targetDeclarationKind = resolvedRequire.flags & 16
                ? 228
                : resolvedRequire.flags & 3
                    ? 226
                    : 0;
            if (targetDeclarationKind !== 0) {
                var decl = ts.getDeclarationOfKind(resolvedRequire, targetDeclarationKind);
                return ts.isInAmbientContext(decl);
            }
            return false;
        }
        function checkTaggedTemplateExpression(node) {
            return getReturnTypeOfSignature(getResolvedSignature(node));
        }
        function checkAssertion(node) {
            var exprType = getRegularTypeOfObjectLiteral(getBaseTypeOfLiteralType(checkExpression(node.expression)));
            checkSourceElement(node.type);
            var targetType = getTypeFromTypeNode(node.type);
            if (produceDiagnostics && targetType !== unknownType) {
                var widenedType = getWidenedType(exprType);
                if (!isTypeComparableTo(targetType, widenedType)) {
                    checkTypeComparableTo(exprType, targetType, node, ts.Diagnostics.Type_0_cannot_be_converted_to_type_1);
                }
            }
            return targetType;
        }
        function checkNonNullAssertion(node) {
            return getNonNullableType(checkExpression(node.expression));
        }
        function checkMetaProperty(node) {
            checkGrammarMetaProperty(node);
            var container = ts.getNewTargetContainer(node);
            if (!container) {
                error(node, ts.Diagnostics.Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor, "new.target");
                return unknownType;
            }
            else if (container.kind === 152) {
                var symbol = getSymbolOfNode(container.parent);
                return getTypeOfSymbol(symbol);
            }
            else {
                var symbol = getSymbolOfNode(container);
                return getTypeOfSymbol(symbol);
            }
        }
        function getTypeOfParameter(symbol) {
            var type = getTypeOfSymbol(symbol);
            if (strictNullChecks) {
                var declaration = symbol.valueDeclaration;
                if (declaration && declaration.initializer) {
                    return includeFalsyTypes(type, 2048);
                }
            }
            return type;
        }
        function getTypeAtPosition(signature, pos) {
            return signature.hasRestParameter ?
                pos < signature.parameters.length - 1 ? getTypeOfParameter(signature.parameters[pos]) : getRestTypeOfSignature(signature) :
                pos < signature.parameters.length ? getTypeOfParameter(signature.parameters[pos]) : anyType;
        }
        function getTypeOfFirstParameterOfSignature(signature) {
            return signature.parameters.length > 0 ? getTypeAtPosition(signature, 0) : neverType;
        }
        function assignContextualParameterTypes(signature, context, mapper, checkMode) {
            var len = signature.parameters.length - (signature.hasRestParameter ? 1 : 0);
            if (checkMode === 2) {
                for (var i = 0; i < len; i++) {
                    var declaration = signature.parameters[i].valueDeclaration;
                    if (declaration.type) {
                        inferTypesWithContext(mapper.context, getTypeFromTypeNode(declaration.type), getTypeAtPosition(context, i));
                    }
                }
            }
            if (context.thisParameter) {
                var parameter = signature.thisParameter;
                if (!parameter || parameter.valueDeclaration && !parameter.valueDeclaration.type) {
                    if (!parameter) {
                        signature.thisParameter = createSymbolWithType(context.thisParameter, undefined);
                    }
                    assignTypeToParameterAndFixTypeParameters(signature.thisParameter, getTypeOfSymbol(context.thisParameter), mapper, checkMode);
                }
            }
            for (var i = 0; i < len; i++) {
                var parameter = signature.parameters[i];
                if (!parameter.valueDeclaration.type) {
                    var contextualParameterType = getTypeAtPosition(context, i);
                    assignTypeToParameterAndFixTypeParameters(parameter, contextualParameterType, mapper, checkMode);
                }
            }
            if (signature.hasRestParameter && isRestParameterIndex(context, signature.parameters.length - 1)) {
                var parameter = ts.lastOrUndefined(signature.parameters);
                if (!parameter.valueDeclaration.type) {
                    var contextualParameterType = getTypeOfSymbol(ts.lastOrUndefined(context.parameters));
                    assignTypeToParameterAndFixTypeParameters(parameter, contextualParameterType, mapper, checkMode);
                }
            }
        }
        function assignBindingElementTypes(node) {
            if (ts.isBindingPattern(node.name)) {
                for (var _i = 0, _a = node.name.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (!ts.isOmittedExpression(element)) {
                        if (element.name.kind === 71) {
                            getSymbolLinks(getSymbolOfNode(element)).type = getTypeForBindingElement(element);
                        }
                        assignBindingElementTypes(element);
                    }
                }
            }
        }
        function assignTypeToParameterAndFixTypeParameters(parameter, contextualType, mapper, checkMode) {
            var links = getSymbolLinks(parameter);
            if (!links.type) {
                links.type = instantiateType(contextualType, mapper);
                var name = ts.getNameOfDeclaration(parameter.valueDeclaration);
                if (links.type === emptyObjectType &&
                    (name.kind === 174 || name.kind === 175)) {
                    links.type = getTypeFromBindingPattern(name);
                }
                assignBindingElementTypes(parameter.valueDeclaration);
            }
            else if (checkMode === 2) {
                inferTypesWithContext(mapper.context, links.type, instantiateType(contextualType, mapper));
            }
        }
        function getReturnTypeFromJSDocComment(func) {
            var returnTag = ts.getJSDocReturnTag(func);
            if (returnTag && returnTag.typeExpression) {
                return getTypeFromTypeNode(returnTag.typeExpression.type);
            }
            return undefined;
        }
        function createPromiseType(promisedType) {
            var globalPromiseType = getGlobalPromiseType(true);
            if (globalPromiseType !== emptyGenericType) {
                promisedType = getAwaitedType(promisedType) || emptyObjectType;
                return createTypeReference(globalPromiseType, [promisedType]);
            }
            return emptyObjectType;
        }
        function createPromiseReturnType(func, promisedType) {
            var promiseType = createPromiseType(promisedType);
            if (promiseType === emptyObjectType) {
                error(func, ts.Diagnostics.An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option);
                return unknownType;
            }
            else if (!getGlobalPromiseConstructorSymbol(true)) {
                error(func, ts.Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
            }
            return promiseType;
        }
        function getReturnTypeFromBody(func, checkMode) {
            var contextualSignature = getContextualSignatureForFunctionLikeDeclaration(func);
            if (!func.body) {
                return unknownType;
            }
            var functionFlags = ts.getFunctionFlags(func);
            var type;
            if (func.body.kind !== 207) {
                type = checkExpressionCached(func.body, checkMode);
                if (functionFlags & 2) {
                    type = checkAwaitedType(type, func, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                }
            }
            else {
                var types = void 0;
                if (functionFlags & 1) {
                    types = ts.concatenate(checkAndAggregateYieldOperandTypes(func, checkMode), checkAndAggregateReturnExpressionTypes(func, checkMode));
                    if (!types || types.length === 0) {
                        var iterableIteratorAny = functionFlags & 2
                            ? createAsyncIterableIteratorType(anyType)
                            : createIterableIteratorType(anyType);
                        if (noImplicitAny) {
                            error(func.asteriskToken, ts.Diagnostics.Generator_implicitly_has_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type, typeToString(iterableIteratorAny));
                        }
                        return iterableIteratorAny;
                    }
                }
                else {
                    types = checkAndAggregateReturnExpressionTypes(func, checkMode);
                    if (!types) {
                        return functionFlags & 2
                            ? createPromiseReturnType(func, neverType)
                            : neverType;
                    }
                    if (types.length === 0) {
                        return functionFlags & 2
                            ? createPromiseReturnType(func, voidType)
                            : voidType;
                    }
                }
                type = getUnionType(types, true);
                if (functionFlags & 1) {
                    type = functionFlags & 2
                        ? createAsyncIterableIteratorType(type)
                        : createIterableIteratorType(type);
                }
            }
            if (!contextualSignature) {
                reportErrorsFromWidening(func, type);
            }
            if (isUnitType(type) &&
                !(contextualSignature &&
                    isLiteralContextualType(contextualSignature === getSignatureFromDeclaration(func) ? type : getReturnTypeOfSignature(contextualSignature)))) {
                type = getWidenedLiteralType(type);
            }
            var widenedType = getWidenedType(type);
            return (functionFlags & 3) === 2
                ? createPromiseReturnType(func, widenedType)
                : widenedType;
        }
        function checkAndAggregateYieldOperandTypes(func, checkMode) {
            var aggregatedTypes = [];
            var functionFlags = ts.getFunctionFlags(func);
            ts.forEachYieldExpression(func.body, function (yieldExpression) {
                var expr = yieldExpression.expression;
                if (expr) {
                    var type = checkExpressionCached(expr, checkMode);
                    if (yieldExpression.asteriskToken) {
                        type = checkIteratedTypeOrElementType(type, yieldExpression.expression, false, (functionFlags & 2) !== 0);
                    }
                    if (functionFlags & 2) {
                        type = checkAwaitedType(type, expr, yieldExpression.asteriskToken
                            ? ts.Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member
                            : ts.Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                    }
                    if (!ts.contains(aggregatedTypes, type)) {
                        aggregatedTypes.push(type);
                    }
                }
            });
            return aggregatedTypes;
        }
        function isExhaustiveSwitchStatement(node) {
            if (!node.possiblyExhaustive) {
                return false;
            }
            var type = getTypeOfExpression(node.expression);
            if (!isLiteralType(type)) {
                return false;
            }
            var switchTypes = getSwitchClauseTypes(node);
            if (!switchTypes.length) {
                return false;
            }
            return eachTypeContainedIn(mapType(type, getRegularTypeOfLiteralType), switchTypes);
        }
        function functionHasImplicitReturn(func) {
            if (!(func.flags & 128)) {
                return false;
            }
            var lastStatement = ts.lastOrUndefined(func.body.statements);
            if (lastStatement && lastStatement.kind === 221 && isExhaustiveSwitchStatement(lastStatement)) {
                return false;
            }
            return true;
        }
        function checkAndAggregateReturnExpressionTypes(func, checkMode) {
            var functionFlags = ts.getFunctionFlags(func);
            var aggregatedTypes = [];
            var hasReturnWithNoExpression = functionHasImplicitReturn(func);
            var hasReturnOfTypeNever = false;
            ts.forEachReturnStatement(func.body, function (returnStatement) {
                var expr = returnStatement.expression;
                if (expr) {
                    var type = checkExpressionCached(expr, checkMode);
                    if (functionFlags & 2) {
                        type = checkAwaitedType(type, func, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                    }
                    if (type.flags & 8192) {
                        hasReturnOfTypeNever = true;
                    }
                    else if (!ts.contains(aggregatedTypes, type)) {
                        aggregatedTypes.push(type);
                    }
                }
                else {
                    hasReturnWithNoExpression = true;
                }
            });
            if (aggregatedTypes.length === 0 && !hasReturnWithNoExpression && (hasReturnOfTypeNever ||
                func.kind === 186 || func.kind === 187)) {
                return undefined;
            }
            if (strictNullChecks && aggregatedTypes.length && hasReturnWithNoExpression) {
                if (!ts.contains(aggregatedTypes, undefinedType)) {
                    aggregatedTypes.push(undefinedType);
                }
            }
            return aggregatedTypes;
        }
        function checkAllCodePathsInNonVoidFunctionReturnOrThrow(func, returnType) {
            if (!produceDiagnostics) {
                return;
            }
            if (returnType && maybeTypeOfKind(returnType, 1 | 1024)) {
                return;
            }
            if (ts.nodeIsMissing(func.body) || func.body.kind !== 207 || !functionHasImplicitReturn(func)) {
                return;
            }
            var hasExplicitReturn = func.flags & 256;
            if (returnType && returnType.flags & 8192) {
                error(func.type, ts.Diagnostics.A_function_returning_never_cannot_have_a_reachable_end_point);
            }
            else if (returnType && !hasExplicitReturn) {
                error(func.type, ts.Diagnostics.A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value);
            }
            else if (returnType && strictNullChecks && !isTypeAssignableTo(undefinedType, returnType)) {
                error(func.type, ts.Diagnostics.Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined);
            }
            else if (compilerOptions.noImplicitReturns) {
                if (!returnType) {
                    if (!hasExplicitReturn) {
                        return;
                    }
                    var inferredReturnType = getReturnTypeOfSignature(getSignatureFromDeclaration(func));
                    if (isUnwrappedReturnTypeVoidOrAny(func, inferredReturnType)) {
                        return;
                    }
                }
                error(func.type || func, ts.Diagnostics.Not_all_code_paths_return_a_value);
            }
        }
        function checkFunctionExpressionOrObjectLiteralMethod(node, checkMode) {
            ts.Debug.assert(node.kind !== 151 || ts.isObjectLiteralMethod(node));
            var hasGrammarError = checkGrammarFunctionLikeDeclaration(node);
            if (!hasGrammarError && node.kind === 186) {
                checkGrammarForGenerator(node);
            }
            if (checkMode === 1 && isContextSensitive(node)) {
                checkNodeDeferred(node);
                return anyFunctionType;
            }
            var links = getNodeLinks(node);
            var type = getTypeOfSymbol(node.symbol);
            var contextSensitive = isContextSensitive(node);
            var mightFixTypeParameters = contextSensitive && checkMode === 2;
            if (mightFixTypeParameters || !(links.flags & 1024)) {
                var contextualSignature = getContextualSignature(node);
                var contextChecked = !!(links.flags & 1024);
                if (mightFixTypeParameters || !contextChecked) {
                    links.flags |= 1024;
                    if (contextualSignature) {
                        var signature = getSignaturesOfType(type, 0)[0];
                        if (contextSensitive) {
                            assignContextualParameterTypes(signature, contextualSignature, getContextualMapper(node), checkMode);
                        }
                        if (mightFixTypeParameters || !node.type && !signature.resolvedReturnType) {
                            var returnType = getReturnTypeFromBody(node, checkMode);
                            if (!signature.resolvedReturnType) {
                                signature.resolvedReturnType = returnType;
                            }
                        }
                    }
                    if (!contextChecked) {
                        checkSignatureDeclaration(node);
                        checkNodeDeferred(node);
                    }
                }
            }
            if (produceDiagnostics && node.kind !== 151) {
                checkCollisionWithCapturedSuperVariable(node, node.name);
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollisionWithCapturedNewTargetVariable(node, node.name);
            }
            return type;
        }
        function checkFunctionExpressionOrObjectLiteralMethodDeferred(node) {
            ts.Debug.assert(node.kind !== 151 || ts.isObjectLiteralMethod(node));
            var functionFlags = ts.getFunctionFlags(node);
            var returnOrPromisedType = node.type &&
                ((functionFlags & 3) === 2 ?
                    checkAsyncFunctionReturnType(node) :
                    getTypeFromTypeNode(node.type));
            if ((functionFlags & 1) === 0) {
                checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnOrPromisedType);
            }
            if (node.body) {
                if (!node.type) {
                    getReturnTypeOfSignature(getSignatureFromDeclaration(node));
                }
                if (node.body.kind === 207) {
                    checkSourceElement(node.body);
                }
                else {
                    var exprType = checkExpression(node.body);
                    if (returnOrPromisedType) {
                        if ((functionFlags & 3) === 2) {
                            var awaitedType = checkAwaitedType(exprType, node.body, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                            checkTypeAssignableTo(awaitedType, returnOrPromisedType, node.body);
                        }
                        else {
                            checkTypeAssignableTo(exprType, returnOrPromisedType, node.body);
                        }
                    }
                }
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkArithmeticOperandType(operand, type, diagnostic) {
            if (!isTypeAnyOrAllConstituentTypesHaveKind(type, 340)) {
                error(operand, diagnostic);
                return false;
            }
            return true;
        }
        function isReadonlySymbol(symbol) {
            return !!(getCheckFlags(symbol) & 8 ||
                symbol.flags & 4 && getDeclarationModifierFlagsFromSymbol(symbol) & 64 ||
                symbol.flags & 3 && getDeclarationNodeFlagsFromSymbol(symbol) & 2 ||
                symbol.flags & 98304 && !(symbol.flags & 65536) ||
                symbol.flags & 8);
        }
        function isReferenceToReadonlyEntity(expr, symbol) {
            if (isReadonlySymbol(symbol)) {
                if (symbol.flags & 4 &&
                    (expr.kind === 179 || expr.kind === 180) &&
                    expr.expression.kind === 99) {
                    var func = ts.getContainingFunction(expr);
                    if (!(func && func.kind === 152))
                        return true;
                    return !(func.parent === symbol.valueDeclaration.parent || func === symbol.valueDeclaration.parent);
                }
                return true;
            }
            return false;
        }
        function isReferenceThroughNamespaceImport(expr) {
            if (expr.kind === 179 || expr.kind === 180) {
                var node = ts.skipParentheses(expr.expression);
                if (node.kind === 71) {
                    var symbol = getNodeLinks(node).resolvedSymbol;
                    if (symbol.flags & 8388608) {
                        var declaration = getDeclarationOfAliasSymbol(symbol);
                        return declaration && declaration.kind === 240;
                    }
                }
            }
            return false;
        }
        function checkReferenceExpression(expr, invalidReferenceMessage) {
            var node = ts.skipParentheses(expr);
            if (node.kind !== 71 && node.kind !== 179 && node.kind !== 180) {
                error(expr, invalidReferenceMessage);
                return false;
            }
            return true;
        }
        function checkDeleteExpression(node) {
            checkExpression(node.expression);
            var expr = ts.skipParentheses(node.expression);
            if (expr.kind !== 179 && expr.kind !== 180) {
                error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_must_be_a_property_reference);
                return booleanType;
            }
            var links = getNodeLinks(expr);
            var symbol = getExportSymbolOfValueSymbolIfExported(links.resolvedSymbol);
            if (symbol && isReadonlySymbol(symbol)) {
                error(expr, ts.Diagnostics.The_operand_of_a_delete_operator_cannot_be_a_read_only_property);
            }
            return booleanType;
        }
        function checkTypeOfExpression(node) {
            checkExpression(node.expression);
            return typeofType;
        }
        function checkVoidExpression(node) {
            checkExpression(node.expression);
            return undefinedWideningType;
        }
        function checkAwaitExpression(node) {
            if (produceDiagnostics) {
                if (!(node.flags & 16384)) {
                    grammarErrorOnFirstToken(node, ts.Diagnostics.await_expression_is_only_allowed_within_an_async_function);
                }
                if (isInParameterInitializerBeforeContainingFunction(node)) {
                    error(node, ts.Diagnostics.await_expressions_cannot_be_used_in_a_parameter_initializer);
                }
            }
            var operandType = checkExpression(node.expression);
            return checkAwaitedType(operandType, node, ts.Diagnostics.Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
        }
        function checkPrefixUnaryExpression(node) {
            var operandType = checkExpression(node.operand);
            if (operandType === silentNeverType) {
                return silentNeverType;
            }
            if (node.operator === 38 && node.operand.kind === 8) {
                return getFreshTypeOfLiteralType(getLiteralTypeForText(64, "" + -node.operand.text));
            }
            switch (node.operator) {
                case 37:
                case 38:
                case 52:
                    checkNonNullType(operandType, node.operand);
                    if (maybeTypeOfKind(operandType, 512)) {
                        error(node.operand, ts.Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, ts.tokenToString(node.operator));
                    }
                    return numberType;
                case 51:
                    var facts = getTypeFacts(operandType) & (1048576 | 2097152);
                    return facts === 1048576 ? falseType :
                        facts === 2097152 ? trueType :
                            booleanType;
                case 43:
                case 44:
                    var ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
                    if (ok) {
                        checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access);
                    }
                    return numberType;
            }
            return unknownType;
        }
        function checkPostfixUnaryExpression(node) {
            var operandType = checkExpression(node.operand);
            if (operandType === silentNeverType) {
                return silentNeverType;
            }
            var ok = checkArithmeticOperandType(node.operand, checkNonNullType(operandType, node.operand), ts.Diagnostics.An_arithmetic_operand_must_be_of_type_any_number_or_an_enum_type);
            if (ok) {
                checkReferenceExpression(node.operand, ts.Diagnostics.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access);
            }
            return numberType;
        }
        function maybeTypeOfKind(type, kind) {
            if (type.flags & kind) {
                return true;
            }
            if (type.flags & 196608) {
                var types = type.types;
                for (var _i = 0, types_19 = types; _i < types_19.length; _i++) {
                    var t = types_19[_i];
                    if (maybeTypeOfKind(t, kind)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function isTypeOfKind(type, kind) {
            if (type.flags & kind) {
                return true;
            }
            if (type.flags & 65536) {
                var types = type.types;
                for (var _i = 0, types_20 = types; _i < types_20.length; _i++) {
                    var t = types_20[_i];
                    if (!isTypeOfKind(t, kind)) {
                        return false;
                    }
                }
                return true;
            }
            if (type.flags & 131072) {
                var types = type.types;
                for (var _a = 0, types_21 = types; _a < types_21.length; _a++) {
                    var t = types_21[_a];
                    if (isTypeOfKind(t, kind)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function isConstEnumObjectType(type) {
            return getObjectFlags(type) & 16 && type.symbol && isConstEnumSymbol(type.symbol);
        }
        function isConstEnumSymbol(symbol) {
            return (symbol.flags & 128) !== 0;
        }
        function checkInstanceOfExpression(left, right, leftType, rightType) {
            if (leftType === silentNeverType || rightType === silentNeverType) {
                return silentNeverType;
            }
            if (isTypeOfKind(leftType, 8190)) {
                error(left, ts.Diagnostics.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            if (!(isTypeAny(rightType) ||
                getSignaturesOfType(rightType, 0).length ||
                getSignaturesOfType(rightType, 1).length ||
                isTypeSubtypeOf(rightType, globalFunctionType))) {
                error(right, ts.Diagnostics.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type);
            }
            return booleanType;
        }
        function checkInExpression(left, right, leftType, rightType) {
            if (leftType === silentNeverType || rightType === silentNeverType) {
                return silentNeverType;
            }
            leftType = checkNonNullType(leftType, left);
            rightType = checkNonNullType(rightType, right);
            if (!(isTypeComparableTo(leftType, stringType) || isTypeOfKind(leftType, 340 | 512))) {
                error(left, ts.Diagnostics.The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol);
            }
            if (!isTypeAnyOrAllConstituentTypesHaveKind(rightType, 32768 | 540672 | 16777216)) {
                error(right, ts.Diagnostics.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            return booleanType;
        }
        function checkObjectLiteralAssignment(node, sourceType) {
            var properties = node.properties;
            for (var _i = 0, properties_7 = properties; _i < properties_7.length; _i++) {
                var p = properties_7[_i];
                checkObjectLiteralDestructuringPropertyAssignment(sourceType, p, properties);
            }
            return sourceType;
        }
        function checkObjectLiteralDestructuringPropertyAssignment(objectLiteralType, property, allProperties) {
            if (property.kind === 261 || property.kind === 262) {
                var name = property.name;
                if (name.kind === 144) {
                    checkComputedPropertyName(name);
                }
                if (isComputedNonLiteralName(name)) {
                    return undefined;
                }
                var text = ts.getTextOfPropertyName(name);
                var type = isTypeAny(objectLiteralType)
                    ? objectLiteralType
                    : getTypeOfPropertyOfType(objectLiteralType, text) ||
                        isNumericLiteralName(text) && getIndexTypeOfType(objectLiteralType, 1) ||
                        getIndexTypeOfType(objectLiteralType, 0);
                if (type) {
                    if (property.kind === 262) {
                        return checkDestructuringAssignment(property, type);
                    }
                    else {
                        return checkDestructuringAssignment(property.initializer, type);
                    }
                }
                else {
                    error(name, ts.Diagnostics.Type_0_has_no_property_1_and_no_string_index_signature, typeToString(objectLiteralType), ts.declarationNameToString(name));
                }
            }
            else if (property.kind === 263) {
                if (languageVersion < 5) {
                    checkExternalEmitHelpers(property, 4);
                }
                var nonRestNames = [];
                if (allProperties) {
                    for (var i = 0; i < allProperties.length - 1; i++) {
                        nonRestNames.push(allProperties[i].name);
                    }
                }
                var type = getRestType(objectLiteralType, nonRestNames, objectLiteralType.symbol);
                return checkDestructuringAssignment(property.expression, type);
            }
            else {
                error(property, ts.Diagnostics.Property_assignment_expected);
            }
        }
        function checkArrayLiteralAssignment(node, sourceType, checkMode) {
            if (languageVersion < 2 && compilerOptions.downlevelIteration) {
                checkExternalEmitHelpers(node, 512);
            }
            var elementType = checkIteratedTypeOrElementType(sourceType, node, false, false) || unknownType;
            var elements = node.elements;
            for (var i = 0; i < elements.length; i++) {
                checkArrayLiteralDestructuringElementAssignment(node, sourceType, i, elementType, checkMode);
            }
            return sourceType;
        }
        function checkArrayLiteralDestructuringElementAssignment(node, sourceType, elementIndex, elementType, checkMode) {
            var elements = node.elements;
            var element = elements[elementIndex];
            if (element.kind !== 200) {
                if (element.kind !== 198) {
                    var propName = "" + elementIndex;
                    var type = isTypeAny(sourceType)
                        ? sourceType
                        : isTupleLikeType(sourceType)
                            ? getTypeOfPropertyOfType(sourceType, propName)
                            : elementType;
                    if (type) {
                        return checkDestructuringAssignment(element, type, checkMode);
                    }
                    else {
                        checkExpression(element);
                        if (isTupleType(sourceType)) {
                            error(element, ts.Diagnostics.Tuple_type_0_with_length_1_cannot_be_assigned_to_tuple_with_length_2, typeToString(sourceType), getTypeReferenceArity(sourceType), elements.length);
                        }
                        else {
                            error(element, ts.Diagnostics.Type_0_has_no_property_1, typeToString(sourceType), propName);
                        }
                    }
                }
                else {
                    if (elementIndex < elements.length - 1) {
                        error(element, ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
                    }
                    else {
                        var restExpression = element.expression;
                        if (restExpression.kind === 194 && restExpression.operatorToken.kind === 58) {
                            error(restExpression.operatorToken, ts.Diagnostics.A_rest_element_cannot_have_an_initializer);
                        }
                        else {
                            return checkDestructuringAssignment(restExpression, createArrayType(elementType), checkMode);
                        }
                    }
                }
            }
            return undefined;
        }
        function checkDestructuringAssignment(exprOrAssignment, sourceType, checkMode) {
            var target;
            if (exprOrAssignment.kind === 262) {
                var prop = exprOrAssignment;
                if (prop.objectAssignmentInitializer) {
                    if (strictNullChecks &&
                        !(getFalsyFlags(checkExpression(prop.objectAssignmentInitializer)) & 2048)) {
                        sourceType = getTypeWithFacts(sourceType, 131072);
                    }
                    checkBinaryLikeExpression(prop.name, prop.equalsToken, prop.objectAssignmentInitializer, checkMode);
                }
                target = exprOrAssignment.name;
            }
            else {
                target = exprOrAssignment;
            }
            if (target.kind === 194 && target.operatorToken.kind === 58) {
                checkBinaryExpression(target, checkMode);
                target = target.left;
            }
            if (target.kind === 178) {
                return checkObjectLiteralAssignment(target, sourceType);
            }
            if (target.kind === 177) {
                return checkArrayLiteralAssignment(target, sourceType, checkMode);
            }
            return checkReferenceAssignment(target, sourceType, checkMode);
        }
        function checkReferenceAssignment(target, sourceType, checkMode) {
            var targetType = checkExpression(target, checkMode);
            var error = target.parent.kind === 263 ?
                ts.Diagnostics.The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access :
                ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access;
            if (checkReferenceExpression(target, error)) {
                checkTypeAssignableTo(sourceType, targetType, target, undefined);
            }
            return sourceType;
        }
        function isSideEffectFree(node) {
            node = ts.skipParentheses(node);
            switch (node.kind) {
                case 71:
                case 9:
                case 12:
                case 183:
                case 196:
                case 13:
                case 8:
                case 101:
                case 86:
                case 95:
                case 139:
                case 186:
                case 199:
                case 187:
                case 177:
                case 178:
                case 189:
                case 203:
                case 250:
                case 249:
                    return true;
                case 195:
                    return isSideEffectFree(node.whenTrue) &&
                        isSideEffectFree(node.whenFalse);
                case 194:
                    if (ts.isAssignmentOperator(node.operatorToken.kind)) {
                        return false;
                    }
                    return isSideEffectFree(node.left) &&
                        isSideEffectFree(node.right);
                case 192:
                case 193:
                    switch (node.operator) {
                        case 51:
                        case 37:
                        case 38:
                        case 52:
                            return true;
                    }
                    return false;
                case 190:
                case 184:
                case 202:
                default:
                    return false;
            }
        }
        function isTypeEqualityComparableTo(source, target) {
            return (target.flags & 6144) !== 0 || isTypeComparableTo(source, target);
        }
        function getBestChoiceType(type1, type2) {
            var firstAssignableToSecond = isTypeAssignableTo(type1, type2);
            var secondAssignableToFirst = isTypeAssignableTo(type2, type1);
            return secondAssignableToFirst && !firstAssignableToSecond ? type1 :
                firstAssignableToSecond && !secondAssignableToFirst ? type2 :
                    getUnionType([type1, type2], true);
        }
        function checkBinaryExpression(node, checkMode) {
            return checkBinaryLikeExpression(node.left, node.operatorToken, node.right, checkMode, node);
        }
        function checkBinaryLikeExpression(left, operatorToken, right, checkMode, errorNode) {
            var operator = operatorToken.kind;
            if (operator === 58 && (left.kind === 178 || left.kind === 177)) {
                return checkDestructuringAssignment(left, checkExpression(right, checkMode), checkMode);
            }
            var leftType = checkExpression(left, checkMode);
            var rightType = checkExpression(right, checkMode);
            switch (operator) {
                case 39:
                case 40:
                case 61:
                case 62:
                case 41:
                case 63:
                case 42:
                case 64:
                case 38:
                case 60:
                case 45:
                case 65:
                case 46:
                case 66:
                case 47:
                case 67:
                case 49:
                case 69:
                case 50:
                case 70:
                case 48:
                case 68:
                    if (leftType === silentNeverType || rightType === silentNeverType) {
                        return silentNeverType;
                    }
                    leftType = checkNonNullType(leftType, left);
                    rightType = checkNonNullType(rightType, right);
                    var suggestedOperator = void 0;
                    if ((leftType.flags & 136) &&
                        (rightType.flags & 136) &&
                        (suggestedOperator = getSuggestedBooleanOperator(operatorToken.kind)) !== undefined) {
                        error(errorNode || operatorToken, ts.Diagnostics.The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead, ts.tokenToString(operatorToken.kind), ts.tokenToString(suggestedOperator));
                    }
                    else {
                        var leftOk = checkArithmeticOperandType(left, leftType, ts.Diagnostics.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);
                        var rightOk = checkArithmeticOperandType(right, rightType, ts.Diagnostics.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type);
                        if (leftOk && rightOk) {
                            checkAssignmentOperator(numberType);
                        }
                    }
                    return numberType;
                case 37:
                case 59:
                    if (leftType === silentNeverType || rightType === silentNeverType) {
                        return silentNeverType;
                    }
                    if (!isTypeOfKind(leftType, 1 | 262178) && !isTypeOfKind(rightType, 1 | 262178)) {
                        leftType = checkNonNullType(leftType, left);
                        rightType = checkNonNullType(rightType, right);
                    }
                    var resultType = void 0;
                    if (isTypeOfKind(leftType, 340) && isTypeOfKind(rightType, 340)) {
                        resultType = numberType;
                    }
                    else {
                        if (isTypeOfKind(leftType, 262178) || isTypeOfKind(rightType, 262178)) {
                            resultType = stringType;
                        }
                        else if (isTypeAny(leftType) || isTypeAny(rightType)) {
                            resultType = leftType === unknownType || rightType === unknownType ? unknownType : anyType;
                        }
                        if (resultType && !checkForDisallowedESSymbolOperand(operator)) {
                            return resultType;
                        }
                    }
                    if (!resultType) {
                        reportOperatorError();
                        return anyType;
                    }
                    if (operator === 59) {
                        checkAssignmentOperator(resultType);
                    }
                    return resultType;
                case 27:
                case 29:
                case 30:
                case 31:
                    if (checkForDisallowedESSymbolOperand(operator)) {
                        leftType = getBaseTypeOfLiteralType(checkNonNullType(leftType, left));
                        rightType = getBaseTypeOfLiteralType(checkNonNullType(rightType, right));
                        if (!isTypeComparableTo(leftType, rightType) && !isTypeComparableTo(rightType, leftType)) {
                            reportOperatorError();
                        }
                    }
                    return booleanType;
                case 32:
                case 33:
                case 34:
                case 35:
                    var leftIsLiteral = isLiteralType(leftType);
                    var rightIsLiteral = isLiteralType(rightType);
                    if (!leftIsLiteral || !rightIsLiteral) {
                        leftType = leftIsLiteral ? getBaseTypeOfLiteralType(leftType) : leftType;
                        rightType = rightIsLiteral ? getBaseTypeOfLiteralType(rightType) : rightType;
                    }
                    if (!isTypeEqualityComparableTo(leftType, rightType) && !isTypeEqualityComparableTo(rightType, leftType)) {
                        reportOperatorError();
                    }
                    return booleanType;
                case 93:
                    return checkInstanceOfExpression(left, right, leftType, rightType);
                case 92:
                    return checkInExpression(left, right, leftType, rightType);
                case 53:
                    return getTypeFacts(leftType) & 1048576 ?
                        includeFalsyTypes(rightType, getFalsyFlags(strictNullChecks ? leftType : getBaseTypeOfLiteralType(rightType))) :
                        leftType;
                case 54:
                    return getTypeFacts(leftType) & 2097152 ?
                        getBestChoiceType(removeDefinitelyFalsyTypes(leftType), rightType) :
                        leftType;
                case 58:
                    checkAssignmentOperator(rightType);
                    return getRegularTypeOfObjectLiteral(rightType);
                case 26:
                    if (!compilerOptions.allowUnreachableCode && isSideEffectFree(left) && !isEvalNode(right)) {
                        error(left, ts.Diagnostics.Left_side_of_comma_operator_is_unused_and_has_no_side_effects);
                    }
                    return rightType;
            }
            function isEvalNode(node) {
                return node.kind === 71 && node.text === "eval";
            }
            function checkForDisallowedESSymbolOperand(operator) {
                var offendingSymbolOperand = maybeTypeOfKind(leftType, 512) ? left :
                    maybeTypeOfKind(rightType, 512) ? right :
                        undefined;
                if (offendingSymbolOperand) {
                    error(offendingSymbolOperand, ts.Diagnostics.The_0_operator_cannot_be_applied_to_type_symbol, ts.tokenToString(operator));
                    return false;
                }
                return true;
            }
            function getSuggestedBooleanOperator(operator) {
                switch (operator) {
                    case 49:
                    case 69:
                        return 54;
                    case 50:
                    case 70:
                        return 35;
                    case 48:
                    case 68:
                        return 53;
                    default:
                        return undefined;
                }
            }
            function checkAssignmentOperator(valueType) {
                if (produceDiagnostics && operator >= 58 && operator <= 70) {
                    if (checkReferenceExpression(left, ts.Diagnostics.The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access)) {
                        checkTypeAssignableTo(valueType, leftType, left, undefined);
                    }
                }
            }
            function reportOperatorError() {
                error(errorNode || operatorToken, ts.Diagnostics.Operator_0_cannot_be_applied_to_types_1_and_2, ts.tokenToString(operatorToken.kind), typeToString(leftType), typeToString(rightType));
            }
        }
        function isYieldExpressionInClass(node) {
            var current = node;
            var parent = node.parent;
            while (parent) {
                if (ts.isFunctionLike(parent) && current === parent.body) {
                    return false;
                }
                else if (ts.isClassLike(current)) {
                    return true;
                }
                current = parent;
                parent = parent.parent;
            }
            return false;
        }
        function checkYieldExpression(node) {
            if (produceDiagnostics) {
                if (!(node.flags & 4096) || isYieldExpressionInClass(node)) {
                    grammarErrorOnFirstToken(node, ts.Diagnostics.A_yield_expression_is_only_allowed_in_a_generator_body);
                }
                if (isInParameterInitializerBeforeContainingFunction(node)) {
                    error(node, ts.Diagnostics.yield_expressions_cannot_be_used_in_a_parameter_initializer);
                }
            }
            if (node.expression) {
                var func = ts.getContainingFunction(node);
                var functionFlags = func && ts.getFunctionFlags(func);
                if (node.asteriskToken) {
                    if ((functionFlags & 3) === 3 &&
                        languageVersion < 5) {
                        checkExternalEmitHelpers(node, 26624);
                    }
                    if ((functionFlags & 3) === 1 &&
                        languageVersion < 2 && compilerOptions.downlevelIteration) {
                        checkExternalEmitHelpers(node, 256);
                    }
                }
                if (functionFlags & 1) {
                    var expressionType = checkExpressionCached(node.expression, undefined);
                    var expressionElementType = void 0;
                    var nodeIsYieldStar = !!node.asteriskToken;
                    if (nodeIsYieldStar) {
                        expressionElementType = checkIteratedTypeOrElementType(expressionType, node.expression, false, (functionFlags & 2) !== 0);
                    }
                    if (func.type) {
                        var signatureElementType = getIteratedTypeOfGenerator(getTypeFromTypeNode(func.type), (functionFlags & 2) !== 0) || anyType;
                        if (nodeIsYieldStar) {
                            checkTypeAssignableTo(functionFlags & 2
                                ? getAwaitedType(expressionElementType, node.expression, ts.Diagnostics.Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
                                : expressionElementType, signatureElementType, node.expression, undefined);
                        }
                        else {
                            checkTypeAssignableTo(functionFlags & 2
                                ? getAwaitedType(expressionType, node.expression, ts.Diagnostics.Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
                                : expressionType, signatureElementType, node.expression, undefined);
                        }
                    }
                }
            }
            return anyType;
        }
        function checkConditionalExpression(node, checkMode) {
            checkExpression(node.condition);
            var type1 = checkExpression(node.whenTrue, checkMode);
            var type2 = checkExpression(node.whenFalse, checkMode);
            return getBestChoiceType(type1, type2);
        }
        function checkLiteralExpression(node) {
            if (node.kind === 8) {
                checkGrammarNumericLiteral(node);
            }
            switch (node.kind) {
                case 9:
                    return getFreshTypeOfLiteralType(getLiteralTypeForText(32, node.text));
                case 8:
                    return getFreshTypeOfLiteralType(getLiteralTypeForText(64, node.text));
                case 101:
                    return trueType;
                case 86:
                    return falseType;
            }
        }
        function checkTemplateExpression(node) {
            ts.forEach(node.templateSpans, function (templateSpan) {
                checkExpression(templateSpan.expression);
            });
            return stringType;
        }
        function checkExpressionWithContextualType(node, contextualType, contextualMapper) {
            var saveContextualType = node.contextualType;
            var saveContextualMapper = node.contextualMapper;
            node.contextualType = contextualType;
            node.contextualMapper = contextualMapper;
            var checkMode = contextualMapper === identityMapper ? 1 :
                contextualMapper ? 2 : 0;
            var result = checkExpression(node, checkMode);
            node.contextualType = saveContextualType;
            node.contextualMapper = saveContextualMapper;
            return result;
        }
        function checkExpressionCached(node, checkMode) {
            var links = getNodeLinks(node);
            if (!links.resolvedType) {
                var saveFlowLoopStart = flowLoopStart;
                flowLoopStart = flowLoopCount;
                links.resolvedType = checkExpression(node, checkMode);
                flowLoopStart = saveFlowLoopStart;
            }
            return links.resolvedType;
        }
        function isTypeAssertion(node) {
            node = ts.skipParentheses(node);
            return node.kind === 184 || node.kind === 202;
        }
        function checkDeclarationInitializer(declaration) {
            var type = getTypeOfExpression(declaration.initializer, true);
            return ts.getCombinedNodeFlags(declaration) & 2 ||
                ts.getCombinedModifierFlags(declaration) & 64 && !ts.isParameterPropertyDeclaration(declaration) ||
                isTypeAssertion(declaration.initializer) ? type : getWidenedLiteralType(type);
        }
        function isLiteralContextualType(contextualType) {
            if (contextualType) {
                if (contextualType.flags & 540672) {
                    var constraint = getBaseConstraintOfType(contextualType) || emptyObjectType;
                    if (constraint.flags & (2 | 4 | 8 | 16)) {
                        return true;
                    }
                    contextualType = constraint;
                }
                return maybeTypeOfKind(contextualType, (480 | 262144));
            }
            return false;
        }
        function checkExpressionForMutableLocation(node, checkMode) {
            var type = checkExpression(node, checkMode);
            return isTypeAssertion(node) || isLiteralContextualType(getContextualType(node)) ? type : getWidenedLiteralType(type);
        }
        function checkPropertyAssignment(node, checkMode) {
            if (node.name.kind === 144) {
                checkComputedPropertyName(node.name);
            }
            return checkExpressionForMutableLocation(node.initializer, checkMode);
        }
        function checkObjectLiteralMethod(node, checkMode) {
            checkGrammarMethod(node);
            if (node.name.kind === 144) {
                checkComputedPropertyName(node.name);
            }
            var uninstantiatedType = checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
            return instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
        }
        function instantiateTypeWithSingleGenericCallSignature(node, type, checkMode) {
            if (checkMode === 2) {
                var signature = getSingleCallSignature(type);
                if (signature && signature.typeParameters) {
                    var contextualType = getApparentTypeOfContextualType(node);
                    if (contextualType) {
                        var contextualSignature = getSingleCallSignature(contextualType);
                        if (contextualSignature && !contextualSignature.typeParameters) {
                            return getOrCreateTypeFromSignature(instantiateSignatureInContextOf(signature, contextualSignature, getContextualMapper(node)));
                        }
                    }
                }
            }
            return type;
        }
        function getTypeOfExpression(node, cache) {
            if (node.kind === 181 && node.expression.kind !== 97 && !ts.isRequireCall(node, true)) {
                var funcType = checkNonNullExpression(node.expression);
                var signature = getSingleCallSignature(funcType);
                if (signature && !signature.typeParameters) {
                    return getReturnTypeOfSignature(signature);
                }
            }
            return cache ? checkExpressionCached(node) : checkExpression(node);
        }
        function getContextFreeTypeOfExpression(node) {
            var saveContextualType = node.contextualType;
            node.contextualType = anyType;
            var type = getTypeOfExpression(node);
            node.contextualType = saveContextualType;
            return type;
        }
        function checkExpression(node, checkMode) {
            var type;
            if (node.kind === 143) {
                type = checkQualifiedName(node);
            }
            else {
                var uninstantiatedType = checkExpressionWorker(node, checkMode);
                type = instantiateTypeWithSingleGenericCallSignature(node, uninstantiatedType, checkMode);
            }
            if (isConstEnumObjectType(type)) {
                var ok = (node.parent.kind === 179 && node.parent.expression === node) ||
                    (node.parent.kind === 180 && node.parent.expression === node) ||
                    ((node.kind === 71 || node.kind === 143) && isInRightSideOfImportOrExportAssignment(node));
                if (!ok) {
                    error(node, ts.Diagnostics.const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment);
                }
            }
            return type;
        }
        function checkExpressionWorker(node, checkMode) {
            switch (node.kind) {
                case 71:
                    return checkIdentifier(node);
                case 99:
                    return checkThisExpression(node);
                case 97:
                    return checkSuperExpression(node);
                case 95:
                    return nullWideningType;
                case 9:
                case 8:
                case 101:
                case 86:
                    return checkLiteralExpression(node);
                case 196:
                    return checkTemplateExpression(node);
                case 13:
                    return stringType;
                case 12:
                    return globalRegExpType;
                case 177:
                    return checkArrayLiteral(node, checkMode);
                case 178:
                    return checkObjectLiteral(node, checkMode);
                case 179:
                    return checkPropertyAccessExpression(node);
                case 180:
                    return checkIndexedAccess(node);
                case 181:
                case 182:
                    return checkCallExpression(node);
                case 183:
                    return checkTaggedTemplateExpression(node);
                case 185:
                    return checkExpression(node.expression, checkMode);
                case 199:
                    return checkClassExpression(node);
                case 186:
                case 187:
                    return checkFunctionExpressionOrObjectLiteralMethod(node, checkMode);
                case 189:
                    return checkTypeOfExpression(node);
                case 184:
                case 202:
                    return checkAssertion(node);
                case 203:
                    return checkNonNullAssertion(node);
                case 204:
                    return checkMetaProperty(node);
                case 188:
                    return checkDeleteExpression(node);
                case 190:
                    return checkVoidExpression(node);
                case 191:
                    return checkAwaitExpression(node);
                case 192:
                    return checkPrefixUnaryExpression(node);
                case 193:
                    return checkPostfixUnaryExpression(node);
                case 194:
                    return checkBinaryExpression(node, checkMode);
                case 195:
                    return checkConditionalExpression(node, checkMode);
                case 198:
                    return checkSpreadExpression(node, checkMode);
                case 200:
                    return undefinedWideningType;
                case 197:
                    return checkYieldExpression(node);
                case 256:
                    return checkJsxExpression(node, checkMode);
                case 249:
                    return checkJsxElement(node);
                case 250:
                    return checkJsxSelfClosingElement(node);
                case 254:
                    return checkJsxAttributes(node, checkMode);
                case 251:
                    ts.Debug.fail("Shouldn't ever directly check a JsxOpeningElement");
            }
            return unknownType;
        }
        function checkTypeParameter(node) {
            if (node.expression) {
                grammarErrorOnFirstToken(node.expression, ts.Diagnostics.Type_expected);
            }
            checkSourceElement(node.constraint);
            checkSourceElement(node.default);
            var typeParameter = getDeclaredTypeOfTypeParameter(getSymbolOfNode(node));
            if (!hasNonCircularBaseConstraint(typeParameter)) {
                error(node.constraint, ts.Diagnostics.Type_parameter_0_has_a_circular_constraint, typeToString(typeParameter));
            }
            var constraintType = getConstraintOfTypeParameter(typeParameter);
            var defaultType = getDefaultFromTypeParameter(typeParameter);
            if (constraintType && defaultType) {
                checkTypeAssignableTo(defaultType, getTypeWithThisArgument(constraintType, defaultType), node.default, ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
            }
            if (produceDiagnostics) {
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_parameter_name_cannot_be_0);
            }
        }
        function checkParameter(node) {
            checkGrammarDecorators(node) || checkGrammarModifiers(node);
            checkVariableLikeDeclaration(node);
            var func = ts.getContainingFunction(node);
            if (ts.getModifierFlags(node) & 92) {
                func = ts.getContainingFunction(node);
                if (!(func.kind === 152 && ts.nodeIsPresent(func.body))) {
                    error(node, ts.Diagnostics.A_parameter_property_is_only_allowed_in_a_constructor_implementation);
                }
            }
            if (node.questionToken && ts.isBindingPattern(node.name) && func.body) {
                error(node, ts.Diagnostics.A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature);
            }
            if (node.name.text === "this") {
                if (ts.indexOf(func.parameters, node) !== 0) {
                    error(node, ts.Diagnostics.A_this_parameter_must_be_the_first_parameter);
                }
                if (func.kind === 152 || func.kind === 156 || func.kind === 161) {
                    error(node, ts.Diagnostics.A_constructor_cannot_have_a_this_parameter);
                }
            }
            if (node.dotDotDotToken && !ts.isBindingPattern(node.name) && !isArrayType(getTypeOfSymbol(node.symbol))) {
                error(node, ts.Diagnostics.A_rest_parameter_must_be_of_an_array_type);
            }
        }
        function getTypePredicateParameterIndex(parameterList, parameter) {
            if (parameterList) {
                for (var i = 0; i < parameterList.length; i++) {
                    var param = parameterList[i];
                    if (param.name.kind === 71 &&
                        param.name.text === parameter.text) {
                        return i;
                    }
                }
            }
            return -1;
        }
        function checkTypePredicate(node) {
            var parent = getTypePredicateParent(node);
            if (!parent) {
                error(node, ts.Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
                return;
            }
            var typePredicate = getSignatureFromDeclaration(parent).typePredicate;
            if (!typePredicate) {
                return;
            }
            var parameterName = node.parameterName;
            if (ts.isThisTypePredicate(typePredicate)) {
                getTypeFromThisTypeNode(parameterName);
            }
            else {
                if (typePredicate.parameterIndex >= 0) {
                    if (parent.parameters[typePredicate.parameterIndex].dotDotDotToken) {
                        error(parameterName, ts.Diagnostics.A_type_predicate_cannot_reference_a_rest_parameter);
                    }
                    else {
                        var leadingError = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type);
                        checkTypeAssignableTo(typePredicate.type, getTypeOfNode(parent.parameters[typePredicate.parameterIndex]), node.type, undefined, leadingError);
                    }
                }
                else if (parameterName) {
                    var hasReportedError = false;
                    for (var _i = 0, _a = parent.parameters; _i < _a.length; _i++) {
                        var name = _a[_i].name;
                        if (ts.isBindingPattern(name) &&
                            checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, parameterName, typePredicate.parameterName)) {
                            hasReportedError = true;
                            break;
                        }
                    }
                    if (!hasReportedError) {
                        error(node.parameterName, ts.Diagnostics.Cannot_find_parameter_0, typePredicate.parameterName);
                    }
                }
            }
        }
        function getTypePredicateParent(node) {
            switch (node.parent.kind) {
                case 187:
                case 155:
                case 228:
                case 186:
                case 160:
                case 151:
                case 150:
                    var parent = node.parent;
                    if (node === parent.type) {
                        return parent;
                    }
            }
        }
        function checkIfTypePredicateVariableIsDeclaredInBindingPattern(pattern, predicateVariableNode, predicateVariableName) {
            for (var _i = 0, _a = pattern.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (ts.isOmittedExpression(element)) {
                    continue;
                }
                var name = element.name;
                if (name.kind === 71 &&
                    name.text === predicateVariableName) {
                    error(predicateVariableNode, ts.Diagnostics.A_type_predicate_cannot_reference_element_0_in_a_binding_pattern, predicateVariableName);
                    return true;
                }
                else if (name.kind === 175 ||
                    name.kind === 174) {
                    if (checkIfTypePredicateVariableIsDeclaredInBindingPattern(name, predicateVariableNode, predicateVariableName)) {
                        return true;
                    }
                }
            }
        }
        function checkSignatureDeclaration(node) {
            if (node.kind === 157) {
                checkGrammarIndexSignature(node);
            }
            else if (node.kind === 160 || node.kind === 228 || node.kind === 161 ||
                node.kind === 155 || node.kind === 152 ||
                node.kind === 156) {
                checkGrammarFunctionLikeDeclaration(node);
            }
            var functionFlags = ts.getFunctionFlags(node);
            if (!(functionFlags & 4)) {
                if ((functionFlags & 3) === 3 && languageVersion < 5) {
                    checkExternalEmitHelpers(node, 6144);
                }
                if ((functionFlags & 3) === 2 && languageVersion < 4) {
                    checkExternalEmitHelpers(node, 64);
                }
                if ((functionFlags & 3) !== 0 && languageVersion < 2) {
                    checkExternalEmitHelpers(node, 128);
                }
            }
            checkTypeParameters(node.typeParameters);
            ts.forEach(node.parameters, checkParameter);
            if (node.type) {
                checkSourceElement(node.type);
            }
            if (produceDiagnostics) {
                checkCollisionWithArgumentsInGeneratedCode(node);
                if (noImplicitAny && !node.type) {
                    switch (node.kind) {
                        case 156:
                            error(node, ts.Diagnostics.Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                        case 155:
                            error(node, ts.Diagnostics.Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type);
                            break;
                    }
                }
                if (node.type) {
                    var functionFlags_1 = ts.getFunctionFlags(node);
                    if ((functionFlags_1 & (4 | 1)) === 1) {
                        var returnType = getTypeFromTypeNode(node.type);
                        if (returnType === voidType) {
                            error(node.type, ts.Diagnostics.A_generator_cannot_have_a_void_type_annotation);
                        }
                        else {
                            var generatorElementType = getIteratedTypeOfGenerator(returnType, (functionFlags_1 & 2) !== 0) || anyType;
                            var iterableIteratorInstantiation = functionFlags_1 & 2
                                ? createAsyncIterableIteratorType(generatorElementType)
                                : createIterableIteratorType(generatorElementType);
                            checkTypeAssignableTo(iterableIteratorInstantiation, returnType, node.type);
                        }
                    }
                    else if ((functionFlags_1 & 3) === 2) {
                        checkAsyncFunctionReturnType(node);
                    }
                }
                if (noUnusedIdentifiers && !node.body) {
                    checkUnusedTypeParameters(node);
                }
            }
        }
        function checkClassForDuplicateDeclarations(node) {
            var Declaration;
            (function (Declaration) {
                Declaration[Declaration["Getter"] = 1] = "Getter";
                Declaration[Declaration["Setter"] = 2] = "Setter";
                Declaration[Declaration["Method"] = 4] = "Method";
                Declaration[Declaration["Property"] = 3] = "Property";
            })(Declaration || (Declaration = {}));
            var instanceNames = ts.createMap();
            var staticNames = ts.createMap();
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (member.kind === 152) {
                    for (var _b = 0, _c = member.parameters; _b < _c.length; _b++) {
                        var param = _c[_b];
                        if (ts.isParameterPropertyDeclaration(param)) {
                            addName(instanceNames, param.name, param.name.text, 3);
                        }
                    }
                }
                else {
                    var isStatic = ts.getModifierFlags(member) & 32;
                    var names = isStatic ? staticNames : instanceNames;
                    var memberName = member.name && ts.getPropertyNameForPropertyNameNode(member.name);
                    if (memberName) {
                        switch (member.kind) {
                            case 153:
                                addName(names, member.name, memberName, 1);
                                break;
                            case 154:
                                addName(names, member.name, memberName, 2);
                                break;
                            case 149:
                                addName(names, member.name, memberName, 3);
                                break;
                            case 151:
                                addName(names, member.name, memberName, 4);
                                break;
                        }
                    }
                }
            }
            function addName(names, location, name, meaning) {
                var prev = names.get(name);
                if (prev) {
                    if (prev & 4) {
                        if (meaning !== 4) {
                            error(location, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(location));
                        }
                    }
                    else if (prev & meaning) {
                        error(location, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(location));
                    }
                    else {
                        names.set(name, prev | meaning);
                    }
                }
                else {
                    names.set(name, meaning);
                }
            }
        }
        function checkClassForStaticPropertyNameConflicts(node) {
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                var memberNameNode = member.name;
                var isStatic = ts.getModifierFlags(member) & 32;
                if (isStatic && memberNameNode) {
                    var memberName = ts.getPropertyNameForPropertyNameNode(memberNameNode);
                    switch (memberName) {
                        case "name":
                        case "length":
                        case "caller":
                        case "arguments":
                        case "prototype":
                            var message = ts.Diagnostics.Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1;
                            var className = getNameOfSymbol(getSymbolOfNode(node));
                            error(memberNameNode, message, memberName, className);
                            break;
                    }
                }
            }
        }
        function checkObjectTypeForDuplicateDeclarations(node) {
            var names = ts.createMap();
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (member.kind === 148) {
                    var memberName = void 0;
                    switch (member.name.kind) {
                        case 9:
                        case 8:
                        case 71:
                            memberName = member.name.text;
                            break;
                        default:
                            continue;
                    }
                    if (names.get(memberName)) {
                        error(ts.getNameOfDeclaration(member.symbol.valueDeclaration), ts.Diagnostics.Duplicate_identifier_0, memberName);
                        error(member.name, ts.Diagnostics.Duplicate_identifier_0, memberName);
                    }
                    else {
                        names.set(memberName, true);
                    }
                }
            }
        }
        function checkTypeForDuplicateIndexSignatures(node) {
            if (node.kind === 230) {
                var nodeSymbol = getSymbolOfNode(node);
                if (nodeSymbol.declarations.length > 0 && nodeSymbol.declarations[0] !== node) {
                    return;
                }
            }
            var indexSymbol = getIndexSymbol(getSymbolOfNode(node));
            if (indexSymbol) {
                var seenNumericIndexer = false;
                var seenStringIndexer = false;
                for (var _i = 0, _a = indexSymbol.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    var declaration = decl;
                    if (declaration.parameters.length === 1 && declaration.parameters[0].type) {
                        switch (declaration.parameters[0].type.kind) {
                            case 136:
                                if (!seenStringIndexer) {
                                    seenStringIndexer = true;
                                }
                                else {
                                    error(declaration, ts.Diagnostics.Duplicate_string_index_signature);
                                }
                                break;
                            case 133:
                                if (!seenNumericIndexer) {
                                    seenNumericIndexer = true;
                                }
                                else {
                                    error(declaration, ts.Diagnostics.Duplicate_number_index_signature);
                                }
                                break;
                        }
                    }
                }
            }
        }
        function checkPropertyDeclaration(node) {
            checkGrammarDecorators(node) || checkGrammarModifiers(node) || checkGrammarProperty(node) || checkGrammarComputedPropertyName(node.name);
            checkVariableLikeDeclaration(node);
        }
        function checkMethodDeclaration(node) {
            checkGrammarMethod(node) || checkGrammarComputedPropertyName(node.name);
            checkFunctionOrMethodDeclaration(node);
            if (ts.getModifierFlags(node) & 128 && node.body) {
                error(node, ts.Diagnostics.Method_0_cannot_have_an_implementation_because_it_is_marked_abstract, ts.declarationNameToString(node.name));
            }
        }
        function checkConstructorDeclaration(node) {
            checkSignatureDeclaration(node);
            checkGrammarConstructorTypeParameters(node) || checkGrammarConstructorTypeAnnotation(node);
            checkSourceElement(node.body);
            registerForUnusedIdentifiersCheck(node);
            var symbol = getSymbolOfNode(node);
            var firstDeclaration = ts.getDeclarationOfKind(symbol, node.kind);
            if (node === firstDeclaration) {
                checkFunctionOrConstructorSymbol(symbol);
            }
            if (ts.nodeIsMissing(node.body)) {
                return;
            }
            if (!produceDiagnostics) {
                return;
            }
            function containsSuperCallAsComputedPropertyName(n) {
                var name = ts.getNameOfDeclaration(n);
                return name && containsSuperCall(name);
            }
            function containsSuperCall(n) {
                if (ts.isSuperCall(n)) {
                    return true;
                }
                else if (ts.isFunctionLike(n)) {
                    return false;
                }
                else if (ts.isClassLike(n)) {
                    return ts.forEach(n.members, containsSuperCallAsComputedPropertyName);
                }
                return ts.forEachChild(n, containsSuperCall);
            }
            function markThisReferencesAsErrors(n) {
                if (n.kind === 99) {
                    error(n, ts.Diagnostics.this_cannot_be_referenced_in_current_location);
                }
                else if (n.kind !== 186 && n.kind !== 228) {
                    ts.forEachChild(n, markThisReferencesAsErrors);
                }
            }
            function isInstancePropertyWithInitializer(n) {
                return n.kind === 149 &&
                    !(ts.getModifierFlags(n) & 32) &&
                    !!n.initializer;
            }
            var containingClassDecl = node.parent;
            if (ts.getClassExtendsHeritageClauseElement(containingClassDecl)) {
                captureLexicalThis(node.parent, containingClassDecl);
                var classExtendsNull = classDeclarationExtendsNull(containingClassDecl);
                var superCall = getSuperCallInConstructor(node);
                if (superCall) {
                    if (classExtendsNull) {
                        error(superCall, ts.Diagnostics.A_constructor_cannot_contain_a_super_call_when_its_class_extends_null);
                    }
                    var superCallShouldBeFirst = ts.forEach(node.parent.members, isInstancePropertyWithInitializer) ||
                        ts.forEach(node.parameters, function (p) { return ts.getModifierFlags(p) & 92; });
                    if (superCallShouldBeFirst) {
                        var statements = node.body.statements;
                        var superCallStatement = void 0;
                        for (var _i = 0, statements_3 = statements; _i < statements_3.length; _i++) {
                            var statement = statements_3[_i];
                            if (statement.kind === 210 && ts.isSuperCall(statement.expression)) {
                                superCallStatement = statement;
                                break;
                            }
                            if (!ts.isPrologueDirective(statement)) {
                                break;
                            }
                        }
                        if (!superCallStatement) {
                            error(node, ts.Diagnostics.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties);
                        }
                    }
                }
                else if (!classExtendsNull) {
                    error(node, ts.Diagnostics.Constructors_for_derived_classes_must_contain_a_super_call);
                }
            }
        }
        function checkAccessorDeclaration(node) {
            if (produceDiagnostics) {
                checkGrammarFunctionLikeDeclaration(node) || checkGrammarAccessor(node) || checkGrammarComputedPropertyName(node.name);
                checkDecorators(node);
                checkSignatureDeclaration(node);
                if (node.kind === 153) {
                    if (!ts.isInAmbientContext(node) && ts.nodeIsPresent(node.body) && (node.flags & 128)) {
                        if (!(node.flags & 256)) {
                            error(node.name, ts.Diagnostics.A_get_accessor_must_return_a_value);
                        }
                    }
                }
                if (node.name.kind === 144) {
                    checkComputedPropertyName(node.name);
                }
                if (!ts.hasDynamicName(node)) {
                    var otherKind = node.kind === 153 ? 154 : 153;
                    var otherAccessor = ts.getDeclarationOfKind(node.symbol, otherKind);
                    if (otherAccessor) {
                        if ((ts.getModifierFlags(node) & 28) !== (ts.getModifierFlags(otherAccessor) & 28)) {
                            error(node.name, ts.Diagnostics.Getter_and_setter_accessors_do_not_agree_in_visibility);
                        }
                        if (ts.hasModifier(node, 128) !== ts.hasModifier(otherAccessor, 128)) {
                            error(node.name, ts.Diagnostics.Accessors_must_both_be_abstract_or_non_abstract);
                        }
                        checkAccessorDeclarationTypesIdentical(node, otherAccessor, getAnnotatedAccessorType, ts.Diagnostics.get_and_set_accessor_must_have_the_same_type);
                        checkAccessorDeclarationTypesIdentical(node, otherAccessor, getThisTypeOfDeclaration, ts.Diagnostics.get_and_set_accessor_must_have_the_same_this_type);
                    }
                }
                var returnType = getTypeOfAccessors(getSymbolOfNode(node));
                if (node.kind === 153) {
                    checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnType);
                }
            }
            checkSourceElement(node.body);
            registerForUnusedIdentifiersCheck(node);
        }
        function checkAccessorDeclarationTypesIdentical(first, second, getAnnotatedType, message) {
            var firstType = getAnnotatedType(first);
            var secondType = getAnnotatedType(second);
            if (firstType && secondType && !isTypeIdenticalTo(firstType, secondType)) {
                error(first, message);
            }
        }
        function checkMissingDeclaration(node) {
            checkDecorators(node);
        }
        function checkTypeArgumentConstraints(typeParameters, typeArgumentNodes) {
            var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
            var typeArguments;
            var mapper;
            var result = true;
            for (var i = 0; i < typeParameters.length; i++) {
                var constraint = getConstraintOfTypeParameter(typeParameters[i]);
                if (constraint) {
                    if (!typeArguments) {
                        typeArguments = fillMissingTypeArguments(ts.map(typeArgumentNodes, getTypeFromTypeNode), typeParameters, minTypeArgumentCount);
                        mapper = createTypeMapper(typeParameters, typeArguments);
                    }
                    var typeArgument = typeArguments[i];
                    result = result && checkTypeAssignableTo(typeArgument, getTypeWithThisArgument(instantiateType(constraint, mapper), typeArgument), typeArgumentNodes[i], ts.Diagnostics.Type_0_does_not_satisfy_the_constraint_1);
                }
            }
            return result;
        }
        function checkTypeReferenceNode(node) {
            checkGrammarTypeArguments(node, node.typeArguments);
            var type = getTypeFromTypeReference(node);
            if (type !== unknownType) {
                if (node.typeArguments) {
                    ts.forEach(node.typeArguments, checkSourceElement);
                    if (produceDiagnostics) {
                        var symbol = getNodeLinks(node).resolvedSymbol;
                        var typeParameters = symbol.flags & 524288 ? getSymbolLinks(symbol).typeParameters : type.target.localTypeParameters;
                        checkTypeArgumentConstraints(typeParameters, node.typeArguments);
                    }
                }
                if (type.flags & 16 && !type.memberTypes && getNodeLinks(node).resolvedSymbol.flags & 8) {
                    error(node, ts.Diagnostics.Enum_type_0_has_members_with_initializers_that_are_not_literals, typeToString(type));
                }
            }
        }
        function checkTypeQuery(node) {
            getTypeFromTypeQueryNode(node);
        }
        function checkTypeLiteral(node) {
            ts.forEach(node.members, checkSourceElement);
            if (produceDiagnostics) {
                var type = getTypeFromTypeLiteralOrFunctionOrConstructorTypeNode(node);
                checkIndexConstraints(type);
                checkTypeForDuplicateIndexSignatures(node);
                checkObjectTypeForDuplicateDeclarations(node);
            }
        }
        function checkArrayType(node) {
            checkSourceElement(node.elementType);
        }
        function checkTupleType(node) {
            var hasErrorFromDisallowedTrailingComma = checkGrammarForDisallowedTrailingComma(node.elementTypes);
            if (!hasErrorFromDisallowedTrailingComma && node.elementTypes.length === 0) {
                grammarErrorOnNode(node, ts.Diagnostics.A_tuple_type_element_list_cannot_be_empty);
            }
            ts.forEach(node.elementTypes, checkSourceElement);
        }
        function checkUnionOrIntersectionType(node) {
            ts.forEach(node.types, checkSourceElement);
        }
        function checkIndexedAccessIndexType(type, accessNode) {
            if (!(type.flags & 524288)) {
                return type;
            }
            var objectType = type.objectType;
            var indexType = type.indexType;
            if (isTypeAssignableTo(indexType, getIndexType(objectType))) {
                return type;
            }
            if (maybeTypeOfKind(objectType, 540672) && isTypeOfKind(indexType, 340)) {
                var constraint = getBaseConstraintOfType(objectType);
                if (constraint && getIndexInfoOfType(constraint, 1)) {
                    return type;
                }
            }
            error(accessNode, ts.Diagnostics.Type_0_cannot_be_used_to_index_type_1, typeToString(indexType), typeToString(objectType));
            return type;
        }
        function checkIndexedAccessType(node) {
            checkIndexedAccessIndexType(getTypeFromIndexedAccessTypeNode(node), node);
        }
        function checkMappedType(node) {
            checkSourceElement(node.typeParameter);
            checkSourceElement(node.type);
            var type = getTypeFromMappedTypeNode(node);
            var constraintType = getConstraintTypeFromMappedType(type);
            checkTypeAssignableTo(constraintType, stringType, node.typeParameter.constraint);
        }
        function isPrivateWithinAmbient(node) {
            return (ts.getModifierFlags(node) & 8) && ts.isInAmbientContext(node);
        }
        function getEffectiveDeclarationFlags(n, flagsToCheck) {
            var flags = ts.getCombinedModifierFlags(n);
            if (n.parent.kind !== 230 &&
                n.parent.kind !== 229 &&
                n.parent.kind !== 199 &&
                ts.isInAmbientContext(n)) {
                if (!(flags & 2)) {
                    flags |= 1;
                }
                flags |= 2;
            }
            return flags & flagsToCheck;
        }
        function checkFunctionOrConstructorSymbol(symbol) {
            if (!produceDiagnostics) {
                return;
            }
            function getCanonicalOverload(overloads, implementation) {
                var implementationSharesContainerWithFirstOverload = implementation !== undefined && implementation.parent === overloads[0].parent;
                return implementationSharesContainerWithFirstOverload ? implementation : overloads[0];
            }
            function checkFlagAgreementBetweenOverloads(overloads, implementation, flagsToCheck, someOverloadFlags, allOverloadFlags) {
                var someButNotAllOverloadFlags = someOverloadFlags ^ allOverloadFlags;
                if (someButNotAllOverloadFlags !== 0) {
                    var canonicalFlags_1 = getEffectiveDeclarationFlags(getCanonicalOverload(overloads, implementation), flagsToCheck);
                    ts.forEach(overloads, function (o) {
                        var deviation = getEffectiveDeclarationFlags(o, flagsToCheck) ^ canonicalFlags_1;
                        if (deviation & 1) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_exported_or_non_exported);
                        }
                        else if (deviation & 2) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_ambient_or_non_ambient);
                        }
                        else if (deviation & (8 | 16)) {
                            error(ts.getNameOfDeclaration(o) || o, ts.Diagnostics.Overload_signatures_must_all_be_public_private_or_protected);
                        }
                        else if (deviation & 128) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_abstract_or_non_abstract);
                        }
                    });
                }
            }
            function checkQuestionTokenAgreementBetweenOverloads(overloads, implementation, someHaveQuestionToken, allHaveQuestionToken) {
                if (someHaveQuestionToken !== allHaveQuestionToken) {
                    var canonicalHasQuestionToken_1 = ts.hasQuestionToken(getCanonicalOverload(overloads, implementation));
                    ts.forEach(overloads, function (o) {
                        var deviation = ts.hasQuestionToken(o) !== canonicalHasQuestionToken_1;
                        if (deviation) {
                            error(ts.getNameOfDeclaration(o), ts.Diagnostics.Overload_signatures_must_all_be_optional_or_required);
                        }
                    });
                }
            }
            var flagsToCheck = 1 | 2 | 8 | 16 | 128;
            var someNodeFlags = 0;
            var allNodeFlags = flagsToCheck;
            var someHaveQuestionToken = false;
            var allHaveQuestionToken = true;
            var hasOverloads = false;
            var bodyDeclaration;
            var lastSeenNonAmbientDeclaration;
            var previousDeclaration;
            var declarations = symbol.declarations;
            var isConstructor = (symbol.flags & 16384) !== 0;
            function reportImplementationExpectedError(node) {
                if (node.name && ts.nodeIsMissing(node.name)) {
                    return;
                }
                var seen = false;
                var subsequentNode = ts.forEachChild(node.parent, function (c) {
                    if (seen) {
                        return c;
                    }
                    else {
                        seen = c === node;
                    }
                });
                if (subsequentNode && subsequentNode.pos === node.end) {
                    if (subsequentNode.kind === node.kind) {
                        var errorNode_1 = subsequentNode.name || subsequentNode;
                        if (node.name && subsequentNode.name && node.name.text === subsequentNode.name.text) {
                            var reportError = (node.kind === 151 || node.kind === 150) &&
                                (ts.getModifierFlags(node) & 32) !== (ts.getModifierFlags(subsequentNode) & 32);
                            if (reportError) {
                                var diagnostic = ts.getModifierFlags(node) & 32 ? ts.Diagnostics.Function_overload_must_be_static : ts.Diagnostics.Function_overload_must_not_be_static;
                                error(errorNode_1, diagnostic);
                            }
                            return;
                        }
                        else if (ts.nodeIsPresent(subsequentNode.body)) {
                            error(errorNode_1, ts.Diagnostics.Function_implementation_name_must_be_0, ts.declarationNameToString(node.name));
                            return;
                        }
                    }
                }
                var errorNode = node.name || node;
                if (isConstructor) {
                    error(errorNode, ts.Diagnostics.Constructor_implementation_is_missing);
                }
                else {
                    if (ts.getModifierFlags(node) & 128) {
                        error(errorNode, ts.Diagnostics.All_declarations_of_an_abstract_method_must_be_consecutive);
                    }
                    else {
                        error(errorNode, ts.Diagnostics.Function_implementation_is_missing_or_not_immediately_following_the_declaration);
                    }
                }
            }
            var duplicateFunctionDeclaration = false;
            var multipleConstructorImplementation = false;
            for (var _i = 0, declarations_5 = declarations; _i < declarations_5.length; _i++) {
                var current = declarations_5[_i];
                var node = current;
                var inAmbientContext = ts.isInAmbientContext(node);
                var inAmbientContextOrInterface = node.parent.kind === 230 || node.parent.kind === 163 || inAmbientContext;
                if (inAmbientContextOrInterface) {
                    previousDeclaration = undefined;
                }
                if (node.kind === 228 || node.kind === 151 || node.kind === 150 || node.kind === 152) {
                    var currentNodeFlags = getEffectiveDeclarationFlags(node, flagsToCheck);
                    someNodeFlags |= currentNodeFlags;
                    allNodeFlags &= currentNodeFlags;
                    someHaveQuestionToken = someHaveQuestionToken || ts.hasQuestionToken(node);
                    allHaveQuestionToken = allHaveQuestionToken && ts.hasQuestionToken(node);
                    if (ts.nodeIsPresent(node.body) && bodyDeclaration) {
                        if (isConstructor) {
                            multipleConstructorImplementation = true;
                        }
                        else {
                            duplicateFunctionDeclaration = true;
                        }
                    }
                    else if (previousDeclaration && previousDeclaration.parent === node.parent && previousDeclaration.end !== node.pos) {
                        reportImplementationExpectedError(previousDeclaration);
                    }
                    if (ts.nodeIsPresent(node.body)) {
                        if (!bodyDeclaration) {
                            bodyDeclaration = node;
                        }
                    }
                    else {
                        hasOverloads = true;
                    }
                    previousDeclaration = node;
                    if (!inAmbientContextOrInterface) {
                        lastSeenNonAmbientDeclaration = node;
                    }
                }
            }
            if (multipleConstructorImplementation) {
                ts.forEach(declarations, function (declaration) {
                    error(declaration, ts.Diagnostics.Multiple_constructor_implementations_are_not_allowed);
                });
            }
            if (duplicateFunctionDeclaration) {
                ts.forEach(declarations, function (declaration) {
                    error(ts.getNameOfDeclaration(declaration), ts.Diagnostics.Duplicate_function_implementation);
                });
            }
            if (lastSeenNonAmbientDeclaration && !lastSeenNonAmbientDeclaration.body &&
                !(ts.getModifierFlags(lastSeenNonAmbientDeclaration) & 128) && !lastSeenNonAmbientDeclaration.questionToken) {
                reportImplementationExpectedError(lastSeenNonAmbientDeclaration);
            }
            if (hasOverloads) {
                checkFlagAgreementBetweenOverloads(declarations, bodyDeclaration, flagsToCheck, someNodeFlags, allNodeFlags);
                checkQuestionTokenAgreementBetweenOverloads(declarations, bodyDeclaration, someHaveQuestionToken, allHaveQuestionToken);
                if (bodyDeclaration) {
                    var signatures = getSignaturesOfSymbol(symbol);
                    var bodySignature = getSignatureFromDeclaration(bodyDeclaration);
                    for (var _a = 0, signatures_5 = signatures; _a < signatures_5.length; _a++) {
                        var signature = signatures_5[_a];
                        if (!isImplementationCompatibleWithOverload(bodySignature, signature)) {
                            error(signature.declaration, ts.Diagnostics.Overload_signature_is_not_compatible_with_function_implementation);
                            break;
                        }
                    }
                }
            }
        }
        function checkExportsOnMergedDeclarations(node) {
            if (!produceDiagnostics) {
                return;
            }
            var symbol = node.localSymbol;
            if (!symbol) {
                symbol = getSymbolOfNode(node);
                if (!(symbol.flags & 7340032)) {
                    return;
                }
            }
            if (ts.getDeclarationOfKind(symbol, node.kind) !== node) {
                return;
            }
            var exportedDeclarationSpaces = 0;
            var nonExportedDeclarationSpaces = 0;
            var defaultExportedDeclarationSpaces = 0;
            for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                var d = _a[_i];
                var declarationSpaces = getDeclarationSpaces(d);
                var effectiveDeclarationFlags = getEffectiveDeclarationFlags(d, 1 | 512);
                if (effectiveDeclarationFlags & 1) {
                    if (effectiveDeclarationFlags & 512) {
                        defaultExportedDeclarationSpaces |= declarationSpaces;
                    }
                    else {
                        exportedDeclarationSpaces |= declarationSpaces;
                    }
                }
                else {
                    nonExportedDeclarationSpaces |= declarationSpaces;
                }
            }
            var nonDefaultExportedDeclarationSpaces = exportedDeclarationSpaces | nonExportedDeclarationSpaces;
            var commonDeclarationSpacesForExportsAndLocals = exportedDeclarationSpaces & nonExportedDeclarationSpaces;
            var commonDeclarationSpacesForDefaultAndNonDefault = defaultExportedDeclarationSpaces & nonDefaultExportedDeclarationSpaces;
            if (commonDeclarationSpacesForExportsAndLocals || commonDeclarationSpacesForDefaultAndNonDefault) {
                for (var _b = 0, _c = symbol.declarations; _b < _c.length; _b++) {
                    var d = _c[_b];
                    var declarationSpaces = getDeclarationSpaces(d);
                    var name = ts.getNameOfDeclaration(d);
                    if (declarationSpaces & commonDeclarationSpacesForDefaultAndNonDefault) {
                        error(name, ts.Diagnostics.Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead, ts.declarationNameToString(name));
                    }
                    else if (declarationSpaces & commonDeclarationSpacesForExportsAndLocals) {
                        error(name, ts.Diagnostics.Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local, ts.declarationNameToString(name));
                    }
                }
            }
            function getDeclarationSpaces(d) {
                switch (d.kind) {
                    case 230:
                        return 2097152;
                    case 233:
                        return ts.isAmbientModule(d) || ts.getModuleInstanceState(d) !== 0
                            ? 4194304 | 1048576
                            : 4194304;
                    case 229:
                    case 232:
                        return 2097152 | 1048576;
                    case 237:
                        var result_3 = 0;
                        var target = resolveAlias(getSymbolOfNode(d));
                        ts.forEach(target.declarations, function (d) { result_3 |= getDeclarationSpaces(d); });
                        return result_3;
                    default:
                        return 1048576;
                }
            }
        }
        function getAwaitedTypeOfPromise(type, errorNode, diagnosticMessage) {
            var promisedType = getPromisedTypeOfPromise(type, errorNode);
            return promisedType && getAwaitedType(promisedType, errorNode, diagnosticMessage);
        }
        function getPromisedTypeOfPromise(promise, errorNode) {
            if (isTypeAny(promise)) {
                return undefined;
            }
            var typeAsPromise = promise;
            if (typeAsPromise.promisedTypeOfPromise) {
                return typeAsPromise.promisedTypeOfPromise;
            }
            if (isReferenceToType(promise, getGlobalPromiseType(false))) {
                return typeAsPromise.promisedTypeOfPromise = promise.typeArguments[0];
            }
            var thenFunction = getTypeOfPropertyOfType(promise, "then");
            if (isTypeAny(thenFunction)) {
                return undefined;
            }
            var thenSignatures = thenFunction ? getSignaturesOfType(thenFunction, 0) : emptyArray;
            if (thenSignatures.length === 0) {
                if (errorNode) {
                    error(errorNode, ts.Diagnostics.A_promise_must_have_a_then_method);
                }
                return undefined;
            }
            var onfulfilledParameterType = getTypeWithFacts(getUnionType(ts.map(thenSignatures, getTypeOfFirstParameterOfSignature)), 524288);
            if (isTypeAny(onfulfilledParameterType)) {
                return undefined;
            }
            var onfulfilledParameterSignatures = getSignaturesOfType(onfulfilledParameterType, 0);
            if (onfulfilledParameterSignatures.length === 0) {
                if (errorNode) {
                    error(errorNode, ts.Diagnostics.The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback);
                }
                return undefined;
            }
            return typeAsPromise.promisedTypeOfPromise = getUnionType(ts.map(onfulfilledParameterSignatures, getTypeOfFirstParameterOfSignature), true);
        }
        function checkAwaitedType(type, errorNode, diagnosticMessage) {
            return getAwaitedType(type, errorNode, diagnosticMessage) || unknownType;
        }
        function getAwaitedType(type, errorNode, diagnosticMessage) {
            var typeAsAwaitable = type;
            if (typeAsAwaitable.awaitedTypeOfType) {
                return typeAsAwaitable.awaitedTypeOfType;
            }
            if (isTypeAny(type)) {
                return typeAsAwaitable.awaitedTypeOfType = type;
            }
            if (type.flags & 65536) {
                var types = void 0;
                for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                    var constituentType = _a[_i];
                    types = ts.append(types, getAwaitedType(constituentType, errorNode, diagnosticMessage));
                }
                if (!types) {
                    return undefined;
                }
                return typeAsAwaitable.awaitedTypeOfType = getUnionType(types, true);
            }
            var promisedType = getPromisedTypeOfPromise(type);
            if (promisedType) {
                if (type.id === promisedType.id || ts.indexOf(awaitedTypeStack, promisedType.id) >= 0) {
                    if (errorNode) {
                        error(errorNode, ts.Diagnostics.Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method);
                    }
                    return undefined;
                }
                awaitedTypeStack.push(type.id);
                var awaitedType = getAwaitedType(promisedType, errorNode, diagnosticMessage);
                awaitedTypeStack.pop();
                if (!awaitedType) {
                    return undefined;
                }
                return typeAsAwaitable.awaitedTypeOfType = awaitedType;
            }
            var thenFunction = getTypeOfPropertyOfType(type, "then");
            if (thenFunction && getSignaturesOfType(thenFunction, 0).length > 0) {
                if (errorNode) {
                    ts.Debug.assert(!!diagnosticMessage);
                    error(errorNode, diagnosticMessage);
                }
                return undefined;
            }
            return typeAsAwaitable.awaitedTypeOfType = type;
        }
        function checkAsyncFunctionReturnType(node) {
            var returnType = getTypeFromTypeNode(node.type);
            if (languageVersion >= 2) {
                if (returnType === unknownType) {
                    return unknownType;
                }
                var globalPromiseType = getGlobalPromiseType(true);
                if (globalPromiseType !== emptyGenericType && !isReferenceToType(returnType, globalPromiseType)) {
                    error(node.type, ts.Diagnostics.The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type);
                    return unknownType;
                }
            }
            else {
                markTypeNodeAsReferenced(node.type);
                if (returnType === unknownType) {
                    return unknownType;
                }
                var promiseConstructorName = ts.getEntityNameFromTypeNode(node.type);
                if (promiseConstructorName === undefined) {
                    error(node.type, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, typeToString(returnType));
                    return unknownType;
                }
                var promiseConstructorSymbol = resolveEntityName(promiseConstructorName, 107455, true);
                var promiseConstructorType = promiseConstructorSymbol ? getTypeOfSymbol(promiseConstructorSymbol) : unknownType;
                if (promiseConstructorType === unknownType) {
                    if (promiseConstructorName.kind === 71 && promiseConstructorName.text === "Promise" && getTargetType(returnType) === getGlobalPromiseType(false)) {
                        error(node.type, ts.Diagnostics.An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option);
                    }
                    else {
                        error(node.type, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, ts.entityNameToString(promiseConstructorName));
                    }
                    return unknownType;
                }
                var globalPromiseConstructorLikeType = getGlobalPromiseConstructorLikeType(true);
                if (globalPromiseConstructorLikeType === emptyObjectType) {
                    error(node.type, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value, ts.entityNameToString(promiseConstructorName));
                    return unknownType;
                }
                if (!checkTypeAssignableTo(promiseConstructorType, globalPromiseConstructorLikeType, node.type, ts.Diagnostics.Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value)) {
                    return unknownType;
                }
                var rootName = promiseConstructorName && getFirstIdentifier(promiseConstructorName);
                var collidingSymbol = getSymbol(node.locals, rootName.text, 107455);
                if (collidingSymbol) {
                    error(collidingSymbol.valueDeclaration, ts.Diagnostics.Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions, rootName.text, ts.entityNameToString(promiseConstructorName));
                    return unknownType;
                }
            }
            return checkAwaitedType(returnType, node, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
        }
        function checkDecorator(node) {
            var signature = getResolvedSignature(node);
            var returnType = getReturnTypeOfSignature(signature);
            if (returnType.flags & 1) {
                return;
            }
            var expectedReturnType;
            var headMessage = getDiagnosticHeadMessageForDecoratorResolution(node);
            var errorInfo;
            switch (node.parent.kind) {
                case 229:
                    var classSymbol = getSymbolOfNode(node.parent);
                    var classConstructorType = getTypeOfSymbol(classSymbol);
                    expectedReturnType = getUnionType([classConstructorType, voidType]);
                    break;
                case 146:
                    expectedReturnType = voidType;
                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any);
                    break;
                case 149:
                    expectedReturnType = voidType;
                    errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.The_return_type_of_a_property_decorator_function_must_be_either_void_or_any);
                    break;
                case 151:
                case 153:
                case 154:
                    var methodType = getTypeOfNode(node.parent);
                    var descriptorType = createTypedPropertyDescriptorType(methodType);
                    expectedReturnType = getUnionType([descriptorType, voidType]);
                    break;
            }
            checkTypeAssignableTo(returnType, expectedReturnType, node, headMessage, errorInfo);
        }
        function markTypeNodeAsReferenced(node) {
            var typeName = node && ts.getEntityNameFromTypeNode(node);
            var rootName = typeName && getFirstIdentifier(typeName);
            var rootSymbol = rootName && resolveName(rootName, rootName.text, (typeName.kind === 71 ? 793064 : 1920) | 8388608, undefined, undefined);
            if (rootSymbol
                && rootSymbol.flags & 8388608
                && symbolIsValue(rootSymbol)
                && !isConstEnumOrConstEnumOnlyModule(resolveAlias(rootSymbol))) {
                markAliasSymbolAsReferenced(rootSymbol);
            }
        }
        function getParameterTypeNodeForDecoratorCheck(node) {
            return node.dotDotDotToken ? ts.getRestParameterElementType(node.type) : node.type;
        }
        function checkDecorators(node) {
            if (!node.decorators) {
                return;
            }
            if (!ts.nodeCanBeDecorated(node)) {
                return;
            }
            if (!compilerOptions.experimentalDecorators) {
                error(node, ts.Diagnostics.Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_to_remove_this_warning);
            }
            var firstDecorator = node.decorators[0];
            checkExternalEmitHelpers(firstDecorator, 8);
            if (node.kind === 146) {
                checkExternalEmitHelpers(firstDecorator, 32);
            }
            if (compilerOptions.emitDecoratorMetadata) {
                checkExternalEmitHelpers(firstDecorator, 16);
                switch (node.kind) {
                    case 229:
                        var constructor = ts.getFirstConstructorWithBody(node);
                        if (constructor) {
                            for (var _i = 0, _a = constructor.parameters; _i < _a.length; _i++) {
                                var parameter = _a[_i];
                                markTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                            }
                        }
                        break;
                    case 151:
                    case 153:
                    case 154:
                        for (var _b = 0, _c = node.parameters; _b < _c.length; _b++) {
                            var parameter = _c[_b];
                            markTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(parameter));
                        }
                        markTypeNodeAsReferenced(node.type);
                        break;
                    case 149:
                        markTypeNodeAsReferenced(getParameterTypeNodeForDecoratorCheck(node));
                        break;
                    case 146:
                        markTypeNodeAsReferenced(node.type);
                        break;
                }
            }
            ts.forEach(node.decorators, checkDecorator);
        }
        function checkFunctionDeclaration(node) {
            if (produceDiagnostics) {
                checkFunctionOrMethodDeclaration(node) || checkGrammarForGenerator(node);
                checkCollisionWithCapturedSuperVariable(node, node.name);
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollisionWithCapturedNewTargetVariable(node, node.name);
                checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
                checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
            }
        }
        function checkFunctionOrMethodDeclaration(node) {
            checkDecorators(node);
            checkSignatureDeclaration(node);
            var functionFlags = ts.getFunctionFlags(node);
            if (node.name && node.name.kind === 144) {
                checkComputedPropertyName(node.name);
            }
            if (!ts.hasDynamicName(node)) {
                var symbol = getSymbolOfNode(node);
                var localSymbol = node.localSymbol || symbol;
                var firstDeclaration = ts.forEach(localSymbol.declarations, function (declaration) { return declaration.kind === node.kind && !ts.isSourceFileJavaScript(ts.getSourceFileOfNode(declaration)) ?
                    declaration : undefined; });
                if (node === firstDeclaration) {
                    checkFunctionOrConstructorSymbol(localSymbol);
                }
                if (symbol.parent) {
                    if (ts.getDeclarationOfKind(symbol, node.kind) === node) {
                        checkFunctionOrConstructorSymbol(symbol);
                    }
                }
            }
            checkSourceElement(node.body);
            if ((functionFlags & 1) === 0) {
                var returnOrPromisedType = node.type && (functionFlags & 2
                    ? checkAsyncFunctionReturnType(node)
                    : getTypeFromTypeNode(node.type));
                checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, returnOrPromisedType);
            }
            if (produceDiagnostics && !node.type) {
                if (noImplicitAny && ts.nodeIsMissing(node.body) && !isPrivateWithinAmbient(node)) {
                    reportImplicitAnyError(node, anyType);
                }
                if (functionFlags & 1 && ts.nodeIsPresent(node.body)) {
                    getReturnTypeOfSignature(getSignatureFromDeclaration(node));
                }
            }
            registerForUnusedIdentifiersCheck(node);
        }
        function registerForUnusedIdentifiersCheck(node) {
            if (deferredUnusedIdentifierNodes) {
                deferredUnusedIdentifierNodes.push(node);
            }
        }
        function checkUnusedIdentifiers() {
            if (deferredUnusedIdentifierNodes) {
                for (var _i = 0, deferredUnusedIdentifierNodes_1 = deferredUnusedIdentifierNodes; _i < deferredUnusedIdentifierNodes_1.length; _i++) {
                    var node = deferredUnusedIdentifierNodes_1[_i];
                    switch (node.kind) {
                        case 265:
                        case 233:
                            checkUnusedModuleMembers(node);
                            break;
                        case 229:
                        case 199:
                            checkUnusedClassMembers(node);
                            checkUnusedTypeParameters(node);
                            break;
                        case 230:
                            checkUnusedTypeParameters(node);
                            break;
                        case 207:
                        case 235:
                        case 214:
                        case 215:
                        case 216:
                            checkUnusedLocalsAndParameters(node);
                            break;
                        case 152:
                        case 186:
                        case 228:
                        case 187:
                        case 151:
                        case 153:
                        case 154:
                            if (node.body) {
                                checkUnusedLocalsAndParameters(node);
                            }
                            checkUnusedTypeParameters(node);
                            break;
                        case 150:
                        case 155:
                        case 156:
                        case 157:
                        case 160:
                        case 161:
                            checkUnusedTypeParameters(node);
                            break;
                    }
                }
            }
        }
        function checkUnusedLocalsAndParameters(node) {
            if (node.parent.kind !== 230 && noUnusedIdentifiers && !ts.isInAmbientContext(node)) {
                node.locals.forEach(function (local) {
                    if (!local.isReferenced) {
                        if (local.valueDeclaration && ts.getRootDeclaration(local.valueDeclaration).kind === 146) {
                            var parameter = ts.getRootDeclaration(local.valueDeclaration);
                            var name = ts.getNameOfDeclaration(local.valueDeclaration);
                            if (compilerOptions.noUnusedParameters &&
                                !ts.isParameterPropertyDeclaration(parameter) &&
                                !ts.parameterIsThisKeyword(parameter) &&
                                !parameterNameStartsWithUnderscore(name)) {
                                error(name, ts.Diagnostics._0_is_declared_but_never_used, local.name);
                            }
                        }
                        else if (compilerOptions.noUnusedLocals) {
                            ts.forEach(local.declarations, function (d) { return errorUnusedLocal(ts.getNameOfDeclaration(d) || d, local.name); });
                        }
                    }
                });
            }
        }
        function isRemovedPropertyFromObjectSpread(node) {
            if (ts.isBindingElement(node) && ts.isObjectBindingPattern(node.parent)) {
                var lastElement = ts.lastOrUndefined(node.parent.elements);
                return lastElement !== node && !!lastElement.dotDotDotToken;
            }
            return false;
        }
        function errorUnusedLocal(node, name) {
            if (isIdentifierThatStartsWithUnderScore(node)) {
                var declaration = ts.getRootDeclaration(node.parent);
                if (declaration.kind === 226 &&
                    (declaration.parent.parent.kind === 215 ||
                        declaration.parent.parent.kind === 216)) {
                    return;
                }
            }
            if (!isRemovedPropertyFromObjectSpread(node.kind === 71 ? node.parent : node)) {
                error(node, ts.Diagnostics._0_is_declared_but_never_used, name);
            }
        }
        function parameterNameStartsWithUnderscore(parameterName) {
            return parameterName && isIdentifierThatStartsWithUnderScore(parameterName);
        }
        function isIdentifierThatStartsWithUnderScore(node) {
            return node.kind === 71 && node.text.charCodeAt(0) === 95;
        }
        function checkUnusedClassMembers(node) {
            if (compilerOptions.noUnusedLocals && !ts.isInAmbientContext(node)) {
                if (node.members) {
                    for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                        var member = _a[_i];
                        if (member.kind === 151 || member.kind === 149) {
                            if (!member.symbol.isReferenced && ts.getModifierFlags(member) & 8) {
                                error(member.name, ts.Diagnostics._0_is_declared_but_never_used, member.symbol.name);
                            }
                        }
                        else if (member.kind === 152) {
                            for (var _b = 0, _c = member.parameters; _b < _c.length; _b++) {
                                var parameter = _c[_b];
                                if (!parameter.symbol.isReferenced && ts.getModifierFlags(parameter) & 8) {
                                    error(parameter.name, ts.Diagnostics.Property_0_is_declared_but_never_used, parameter.symbol.name);
                                }
                            }
                        }
                    }
                }
            }
        }
        function checkUnusedTypeParameters(node) {
            if (compilerOptions.noUnusedLocals && !ts.isInAmbientContext(node)) {
                if (node.typeParameters) {
                    var symbol = getSymbolOfNode(node);
                    var lastDeclaration = symbol && symbol.declarations && ts.lastOrUndefined(symbol.declarations);
                    if (lastDeclaration !== node) {
                        return;
                    }
                    for (var _i = 0, _a = node.typeParameters; _i < _a.length; _i++) {
                        var typeParameter = _a[_i];
                        if (!getMergedSymbol(typeParameter.symbol).isReferenced) {
                            error(typeParameter.name, ts.Diagnostics._0_is_declared_but_never_used, typeParameter.symbol.name);
                        }
                    }
                }
            }
        }
        function checkUnusedModuleMembers(node) {
            if (compilerOptions.noUnusedLocals && !ts.isInAmbientContext(node)) {
                node.locals.forEach(function (local) {
                    if (!local.isReferenced && !local.exportSymbol) {
                        for (var _i = 0, _a = local.declarations; _i < _a.length; _i++) {
                            var declaration = _a[_i];
                            if (!ts.isAmbientModule(declaration)) {
                                errorUnusedLocal(ts.getNameOfDeclaration(declaration), local.name);
                            }
                        }
                    }
                });
            }
        }
        function checkBlock(node) {
            if (node.kind === 207) {
                checkGrammarStatementInAmbientContext(node);
            }
            ts.forEach(node.statements, checkSourceElement);
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkCollisionWithArgumentsInGeneratedCode(node) {
            if (!ts.hasDeclaredRestParameter(node) || ts.isInAmbientContext(node) || ts.nodeIsMissing(node.body)) {
                return;
            }
            ts.forEach(node.parameters, function (p) {
                if (p.name && !ts.isBindingPattern(p.name) && p.name.text === argumentsSymbol.name) {
                    error(p, ts.Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
                }
            });
        }
        function needCollisionCheckForIdentifier(node, identifier, name) {
            if (!(identifier && identifier.text === name)) {
                return false;
            }
            if (node.kind === 149 ||
                node.kind === 148 ||
                node.kind === 151 ||
                node.kind === 150 ||
                node.kind === 153 ||
                node.kind === 154) {
                return false;
            }
            if (ts.isInAmbientContext(node)) {
                return false;
            }
            var root = ts.getRootDeclaration(node);
            if (root.kind === 146 && ts.nodeIsMissing(root.parent.body)) {
                return false;
            }
            return true;
        }
        function checkCollisionWithCapturedThisVariable(node, name) {
            if (needCollisionCheckForIdentifier(node, name, "_this")) {
                potentialThisCollisions.push(node);
            }
        }
        function checkCollisionWithCapturedNewTargetVariable(node, name) {
            if (needCollisionCheckForIdentifier(node, name, "_newTarget")) {
                potentialNewTargetCollisions.push(node);
            }
        }
        function checkIfThisIsCapturedInEnclosingScope(node) {
            ts.findAncestor(node, function (current) {
                if (getNodeCheckFlags(current) & 4) {
                    var isDeclaration_1 = node.kind !== 71;
                    if (isDeclaration_1) {
                        error(ts.getNameOfDeclaration(node), ts.Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
                    }
                    else {
                        error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
                    }
                    return true;
                }
            });
        }
        function checkIfNewTargetIsCapturedInEnclosingScope(node) {
            ts.findAncestor(node, function (current) {
                if (getNodeCheckFlags(current) & 8) {
                    var isDeclaration_2 = node.kind !== 71;
                    if (isDeclaration_2) {
                        error(ts.getNameOfDeclaration(node), ts.Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference);
                    }
                    else {
                        error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference);
                    }
                    return true;
                }
            });
        }
        function checkCollisionWithCapturedSuperVariable(node, name) {
            if (!needCollisionCheckForIdentifier(node, name, "_super")) {
                return;
            }
            var enclosingClass = ts.getContainingClass(node);
            if (!enclosingClass || ts.isInAmbientContext(enclosingClass)) {
                return;
            }
            if (ts.getClassExtendsHeritageClauseElement(enclosingClass)) {
                var isDeclaration_3 = node.kind !== 71;
                if (isDeclaration_3) {
                    error(node, ts.Diagnostics.Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference);
                }
                else {
                    error(node, ts.Diagnostics.Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference);
                }
            }
        }
        function checkCollisionWithRequireExportsInGeneratedCode(node, name) {
            if (modulekind >= ts.ModuleKind.ES2015) {
                return;
            }
            if (!needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports")) {
                return;
            }
            if (node.kind === 233 && ts.getModuleInstanceState(node) !== 1) {
                return;
            }
            var parent = getDeclarationContainer(node);
            if (parent.kind === 265 && ts.isExternalOrCommonJsModule(parent)) {
                error(name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, ts.declarationNameToString(name), ts.declarationNameToString(name));
            }
        }
        function checkCollisionWithGlobalPromiseInGeneratedCode(node, name) {
            if (languageVersion >= 4 || !needCollisionCheckForIdentifier(node, name, "Promise")) {
                return;
            }
            if (node.kind === 233 && ts.getModuleInstanceState(node) !== 1) {
                return;
            }
            var parent = getDeclarationContainer(node);
            if (parent.kind === 265 && ts.isExternalOrCommonJsModule(parent) && parent.flags & 1024) {
                error(name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, ts.declarationNameToString(name), ts.declarationNameToString(name));
            }
        }
        function checkVarDeclaredNamesNotShadowed(node) {
            if ((ts.getCombinedNodeFlags(node) & 3) !== 0 || ts.isParameterDeclaration(node)) {
                return;
            }
            if (node.kind === 226 && !node.initializer) {
                return;
            }
            var symbol = getSymbolOfNode(node);
            if (symbol.flags & 1) {
                var localDeclarationSymbol = resolveName(node, node.name.text, 3, undefined, undefined);
                if (localDeclarationSymbol &&
                    localDeclarationSymbol !== symbol &&
                    localDeclarationSymbol.flags & 2) {
                    if (getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & 3) {
                        var varDeclList = ts.getAncestor(localDeclarationSymbol.valueDeclaration, 227);
                        var container = varDeclList.parent.kind === 208 && varDeclList.parent.parent
                            ? varDeclList.parent.parent
                            : undefined;
                        var namesShareScope = container &&
                            (container.kind === 207 && ts.isFunctionLike(container.parent) ||
                                container.kind === 234 ||
                                container.kind === 233 ||
                                container.kind === 265);
                        if (!namesShareScope) {
                            var name = symbolToString(localDeclarationSymbol);
                            error(node, ts.Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name);
                        }
                    }
                }
            }
        }
        function checkParameterInitializer(node) {
            if (ts.getRootDeclaration(node).kind !== 146) {
                return;
            }
            var func = ts.getContainingFunction(node);
            visit(node.initializer);
            function visit(n) {
                if (ts.isTypeNode(n) || ts.isDeclarationName(n)) {
                    return;
                }
                if (n.kind === 179) {
                    return visit(n.expression);
                }
                else if (n.kind === 71) {
                    var symbol = resolveName(n, n.text, 107455 | 8388608, undefined, undefined);
                    if (!symbol || symbol === unknownSymbol || !symbol.valueDeclaration) {
                        return;
                    }
                    if (symbol.valueDeclaration === node) {
                        error(n, ts.Diagnostics.Parameter_0_cannot_be_referenced_in_its_initializer, ts.declarationNameToString(node.name));
                        return;
                    }
                    var enclosingContainer = ts.getEnclosingBlockScopeContainer(symbol.valueDeclaration);
                    if (enclosingContainer === func) {
                        if (symbol.valueDeclaration.kind === 146 ||
                            symbol.valueDeclaration.kind === 176) {
                            if (symbol.valueDeclaration.pos < node.pos) {
                                return;
                            }
                            if (ts.findAncestor(n, function (current) {
                                if (current === node.initializer) {
                                    return "quit";
                                }
                                return ts.isFunctionLike(current.parent) ||
                                    (current.parent.kind === 149 &&
                                        !(ts.hasModifier(current.parent, 32)) &&
                                        ts.isClassLike(current.parent.parent));
                            })) {
                                return;
                            }
                        }
                        error(n, ts.Diagnostics.Initializer_of_parameter_0_cannot_reference_identifier_1_declared_after_it, ts.declarationNameToString(node.name), ts.declarationNameToString(n));
                    }
                }
                else {
                    return ts.forEachChild(n, visit);
                }
            }
        }
        function convertAutoToAny(type) {
            return type === autoType ? anyType : type === autoArrayType ? anyArrayType : type;
        }
        function checkVariableLikeDeclaration(node) {
            checkDecorators(node);
            checkSourceElement(node.type);
            if (node.name.kind === 144) {
                checkComputedPropertyName(node.name);
                if (node.initializer) {
                    checkExpressionCached(node.initializer);
                }
            }
            if (node.kind === 176) {
                if (node.parent.kind === 174 && languageVersion < 5) {
                    checkExternalEmitHelpers(node, 4);
                }
                if (node.propertyName && node.propertyName.kind === 144) {
                    checkComputedPropertyName(node.propertyName);
                }
                var parent = node.parent.parent;
                var parentType = getTypeForBindingElementParent(parent);
                var name = node.propertyName || node.name;
                var property = getPropertyOfType(parentType, ts.getTextOfPropertyName(name));
                markPropertyAsReferenced(property);
                if (parent.initializer && property) {
                    checkPropertyAccessibility(parent, parent.initializer, parentType, property);
                }
            }
            if (ts.isBindingPattern(node.name)) {
                if (node.name.kind === 175 && languageVersion < 2 && compilerOptions.downlevelIteration) {
                    checkExternalEmitHelpers(node, 512);
                }
                ts.forEach(node.name.elements, checkSourceElement);
            }
            if (node.initializer && ts.getRootDeclaration(node).kind === 146 && ts.nodeIsMissing(ts.getContainingFunction(node).body)) {
                error(node, ts.Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
                return;
            }
            if (ts.isBindingPattern(node.name)) {
                if (node.initializer && node.parent.parent.kind !== 215) {
                    checkTypeAssignableTo(checkExpressionCached(node.initializer), getWidenedTypeForVariableLikeDeclaration(node), node, undefined);
                    checkParameterInitializer(node);
                }
                return;
            }
            var symbol = getSymbolOfNode(node);
            var type = convertAutoToAny(getTypeOfVariableOrParameterOrProperty(symbol));
            if (node === symbol.valueDeclaration) {
                if (node.initializer && node.parent.parent.kind !== 215) {
                    checkTypeAssignableTo(checkExpressionCached(node.initializer), type, node, undefined);
                    checkParameterInitializer(node);
                }
            }
            else {
                var declarationType = convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node));
                if (type !== unknownType && declarationType !== unknownType && !isTypeIdenticalTo(type, declarationType)) {
                    error(node.name, ts.Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, ts.declarationNameToString(node.name), typeToString(type), typeToString(declarationType));
                }
                if (node.initializer) {
                    checkTypeAssignableTo(checkExpressionCached(node.initializer), declarationType, node, undefined);
                }
                if (!areDeclarationFlagsIdentical(node, symbol.valueDeclaration)) {
                    error(ts.getNameOfDeclaration(symbol.valueDeclaration), ts.Diagnostics.All_declarations_of_0_must_have_identical_modifiers, ts.declarationNameToString(node.name));
                    error(node.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_modifiers, ts.declarationNameToString(node.name));
                }
            }
            if (node.kind !== 149 && node.kind !== 148) {
                checkExportsOnMergedDeclarations(node);
                if (node.kind === 226 || node.kind === 176) {
                    checkVarDeclaredNamesNotShadowed(node);
                }
                checkCollisionWithCapturedSuperVariable(node, node.name);
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollisionWithCapturedNewTargetVariable(node, node.name);
                checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
                checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
            }
        }
        function areDeclarationFlagsIdentical(left, right) {
            if ((left.kind === 146 && right.kind === 226) ||
                (left.kind === 226 && right.kind === 146)) {
                return true;
            }
            if (ts.hasQuestionToken(left) !== ts.hasQuestionToken(right)) {
                return false;
            }
            var interestingFlags = 8 |
                16 |
                256 |
                128 |
                64 |
                32;
            return (ts.getModifierFlags(left) & interestingFlags) === (ts.getModifierFlags(right) & interestingFlags);
        }
        function checkVariableDeclaration(node) {
            checkGrammarVariableDeclaration(node);
            return checkVariableLikeDeclaration(node);
        }
        function checkBindingElement(node) {
            checkGrammarBindingElement(node);
            return checkVariableLikeDeclaration(node);
        }
        function checkVariableStatement(node) {
            checkGrammarDecorators(node) || checkGrammarModifiers(node) || checkGrammarVariableDeclarationList(node.declarationList) || checkGrammarForDisallowedLetOrConstStatement(node);
            ts.forEach(node.declarationList.declarations, checkSourceElement);
        }
        function checkGrammarDisallowedModifiersOnObjectLiteralExpressionMethod(node) {
            if (node.modifiers && node.parent.kind === 178) {
                if (ts.getFunctionFlags(node) & 2) {
                    if (node.modifiers.length > 1) {
                        return grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_cannot_appear_here);
                    }
                }
                else {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_cannot_appear_here);
                }
            }
        }
        function checkExpressionStatement(node) {
            checkGrammarStatementInAmbientContext(node);
            checkExpression(node.expression);
        }
        function checkIfStatement(node) {
            checkGrammarStatementInAmbientContext(node);
            checkExpression(node.expression);
            checkSourceElement(node.thenStatement);
            if (node.thenStatement.kind === 209) {
                error(node.thenStatement, ts.Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement);
            }
            checkSourceElement(node.elseStatement);
        }
        function checkDoStatement(node) {
            checkGrammarStatementInAmbientContext(node);
            checkSourceElement(node.statement);
            checkExpression(node.expression);
        }
        function checkWhileStatement(node) {
            checkGrammarStatementInAmbientContext(node);
            checkExpression(node.expression);
            checkSourceElement(node.statement);
        }
        function checkForStatement(node) {
            if (!checkGrammarStatementInAmbientContext(node)) {
                if (node.initializer && node.initializer.kind === 227) {
                    checkGrammarVariableDeclarationList(node.initializer);
                }
            }
            if (node.initializer) {
                if (node.initializer.kind === 227) {
                    ts.forEach(node.initializer.declarations, checkVariableDeclaration);
                }
                else {
                    checkExpression(node.initializer);
                }
            }
            if (node.condition)
                checkExpression(node.condition);
            if (node.incrementor)
                checkExpression(node.incrementor);
            checkSourceElement(node.statement);
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkForOfStatement(node) {
            checkGrammarForInOrForOfStatement(node);
            if (node.kind === 216) {
                if (node.awaitModifier) {
                    var functionFlags = ts.getFunctionFlags(ts.getContainingFunction(node));
                    if ((functionFlags & (4 | 2)) === 2 && languageVersion < 5) {
                        checkExternalEmitHelpers(node, 16384);
                    }
                }
                else if (compilerOptions.downlevelIteration && languageVersion < 2) {
                    checkExternalEmitHelpers(node, 256);
                }
            }
            if (node.initializer.kind === 227) {
                checkForInOrForOfVariableDeclaration(node);
            }
            else {
                var varExpr = node.initializer;
                var iteratedType = checkRightHandSideOfForOf(node.expression, node.awaitModifier);
                if (varExpr.kind === 177 || varExpr.kind === 178) {
                    checkDestructuringAssignment(varExpr, iteratedType || unknownType);
                }
                else {
                    var leftType = checkExpression(varExpr);
                    checkReferenceExpression(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access);
                    if (iteratedType) {
                        checkTypeAssignableTo(iteratedType, leftType, varExpr, undefined);
                    }
                }
            }
            checkSourceElement(node.statement);
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkForInStatement(node) {
            checkGrammarForInOrForOfStatement(node);
            var rightType = checkNonNullExpression(node.expression);
            if (node.initializer.kind === 227) {
                var variable = node.initializer.declarations[0];
                if (variable && ts.isBindingPattern(variable.name)) {
                    error(variable.name, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
                }
                checkForInOrForOfVariableDeclaration(node);
            }
            else {
                var varExpr = node.initializer;
                var leftType = checkExpression(varExpr);
                if (varExpr.kind === 177 || varExpr.kind === 178) {
                    error(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
                }
                else if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
                    error(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
                }
                else {
                    checkReferenceExpression(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access);
                }
            }
            if (!isTypeAnyOrAllConstituentTypesHaveKind(rightType, 32768 | 540672 | 16777216)) {
                error(node.expression, ts.Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter);
            }
            checkSourceElement(node.statement);
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkForInOrForOfVariableDeclaration(iterationStatement) {
            var variableDeclarationList = iterationStatement.initializer;
            if (variableDeclarationList.declarations.length >= 1) {
                var decl = variableDeclarationList.declarations[0];
                checkVariableDeclaration(decl);
            }
        }
        function checkRightHandSideOfForOf(rhsExpression, awaitModifier) {
            var expressionType = checkNonNullExpression(rhsExpression);
            return checkIteratedTypeOrElementType(expressionType, rhsExpression, true, awaitModifier !== undefined);
        }
        function checkIteratedTypeOrElementType(inputType, errorNode, allowStringInput, allowAsyncIterable) {
            if (isTypeAny(inputType)) {
                return inputType;
            }
            return getIteratedTypeOrElementType(inputType, errorNode, allowStringInput, allowAsyncIterable, true) || anyType;
        }
        function getIteratedTypeOrElementType(inputType, errorNode, allowStringInput, allowAsyncIterable, checkAssignability) {
            var uplevelIteration = languageVersion >= 2;
            var downlevelIteration = !uplevelIteration && compilerOptions.downlevelIteration;
            if (uplevelIteration || downlevelIteration || allowAsyncIterable) {
                var iteratedType = getIteratedTypeOfIterable(inputType, uplevelIteration ? errorNode : undefined, allowAsyncIterable, allowAsyncIterable, checkAssignability);
                if (iteratedType || uplevelIteration) {
                    return iteratedType;
                }
            }
            var arrayType = inputType;
            var reportedError = false;
            var hasStringConstituent = false;
            if (allowStringInput) {
                if (arrayType.flags & 65536) {
                    var arrayTypes = inputType.types;
                    var filteredTypes = ts.filter(arrayTypes, function (t) { return !(t.flags & 262178); });
                    if (filteredTypes !== arrayTypes) {
                        arrayType = getUnionType(filteredTypes, true);
                    }
                }
                else if (arrayType.flags & 262178) {
                    arrayType = neverType;
                }
                hasStringConstituent = arrayType !== inputType;
                if (hasStringConstituent) {
                    if (languageVersion < 1) {
                        if (errorNode) {
                            error(errorNode, ts.Diagnostics.Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher);
                            reportedError = true;
                        }
                    }
                    if (arrayType.flags & 8192) {
                        return stringType;
                    }
                }
            }
            if (!isArrayLikeType(arrayType)) {
                if (errorNode && !reportedError) {
                    var diagnostic = !allowStringInput || hasStringConstituent
                        ? downlevelIteration
                            ? ts.Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator
                            : ts.Diagnostics.Type_0_is_not_an_array_type
                        : downlevelIteration
                            ? ts.Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator
                            : ts.Diagnostics.Type_0_is_not_an_array_type_or_a_string_type;
                    error(errorNode, diagnostic, typeToString(arrayType));
                }
                return hasStringConstituent ? stringType : undefined;
            }
            var arrayElementType = getIndexTypeOfType(arrayType, 1);
            if (hasStringConstituent && arrayElementType) {
                if (arrayElementType.flags & 262178) {
                    return stringType;
                }
                return getUnionType([arrayElementType, stringType], true);
            }
            return arrayElementType;
        }
        function getIteratedTypeOfIterable(type, errorNode, isAsyncIterable, allowNonAsyncIterables, checkAssignability) {
            if (isTypeAny(type)) {
                return undefined;
            }
            var typeAsIterable = type;
            if (isAsyncIterable ? typeAsIterable.iteratedTypeOfAsyncIterable : typeAsIterable.iteratedTypeOfIterable) {
                return isAsyncIterable ? typeAsIterable.iteratedTypeOfAsyncIterable : typeAsIterable.iteratedTypeOfIterable;
            }
            if (isAsyncIterable) {
                if (isReferenceToType(type, getGlobalAsyncIterableType(false)) ||
                    isReferenceToType(type, getGlobalAsyncIterableIteratorType(false))) {
                    return typeAsIterable.iteratedTypeOfAsyncIterable = type.typeArguments[0];
                }
            }
            if (!isAsyncIterable || allowNonAsyncIterables) {
                if (isReferenceToType(type, getGlobalIterableType(false)) ||
                    isReferenceToType(type, getGlobalIterableIteratorType(false))) {
                    return isAsyncIterable
                        ? typeAsIterable.iteratedTypeOfAsyncIterable = type.typeArguments[0]
                        : typeAsIterable.iteratedTypeOfIterable = type.typeArguments[0];
                }
            }
            var iteratorMethodSignatures;
            var isNonAsyncIterable = false;
            if (isAsyncIterable) {
                var iteratorMethod = getTypeOfPropertyOfType(type, ts.getPropertyNameForKnownSymbolName("asyncIterator"));
                if (isTypeAny(iteratorMethod)) {
                    return undefined;
                }
                iteratorMethodSignatures = iteratorMethod && getSignaturesOfType(iteratorMethod, 0);
            }
            if (!isAsyncIterable || (allowNonAsyncIterables && !ts.some(iteratorMethodSignatures))) {
                var iteratorMethod = getTypeOfPropertyOfType(type, ts.getPropertyNameForKnownSymbolName("iterator"));
                if (isTypeAny(iteratorMethod)) {
                    return undefined;
                }
                iteratorMethodSignatures = iteratorMethod && getSignaturesOfType(iteratorMethod, 0);
                isNonAsyncIterable = true;
            }
            if (ts.some(iteratorMethodSignatures)) {
                var iteratorMethodReturnType = getUnionType(ts.map(iteratorMethodSignatures, getReturnTypeOfSignature), true);
                var iteratedType = getIteratedTypeOfIterator(iteratorMethodReturnType, errorNode, !isNonAsyncIterable);
                if (checkAssignability && errorNode && iteratedType) {
                    checkTypeAssignableTo(type, isNonAsyncIterable
                        ? createIterableType(iteratedType)
                        : createAsyncIterableType(iteratedType), errorNode);
                }
                return isAsyncIterable
                    ? typeAsIterable.iteratedTypeOfAsyncIterable = iteratedType
                    : typeAsIterable.iteratedTypeOfIterable = iteratedType;
            }
            if (errorNode) {
                error(errorNode, isAsyncIterable
                    ? ts.Diagnostics.Type_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator
                    : ts.Diagnostics.Type_must_have_a_Symbol_iterator_method_that_returns_an_iterator);
            }
            return undefined;
        }
        function getIteratedTypeOfIterator(type, errorNode, isAsyncIterator) {
            if (isTypeAny(type)) {
                return undefined;
            }
            var typeAsIterator = type;
            if (isAsyncIterator ? typeAsIterator.iteratedTypeOfAsyncIterator : typeAsIterator.iteratedTypeOfIterator) {
                return isAsyncIterator ? typeAsIterator.iteratedTypeOfAsyncIterator : typeAsIterator.iteratedTypeOfIterator;
            }
            var getIteratorType = isAsyncIterator ? getGlobalAsyncIteratorType : getGlobalIteratorType;
            if (isReferenceToType(type, getIteratorType(false))) {
                return isAsyncIterator
                    ? typeAsIterator.iteratedTypeOfAsyncIterator = type.typeArguments[0]
                    : typeAsIterator.iteratedTypeOfIterator = type.typeArguments[0];
            }
            var nextMethod = getTypeOfPropertyOfType(type, "next");
            if (isTypeAny(nextMethod)) {
                return undefined;
            }
            var nextMethodSignatures = nextMethod ? getSignaturesOfType(nextMethod, 0) : emptyArray;
            if (nextMethodSignatures.length === 0) {
                if (errorNode) {
                    error(errorNode, isAsyncIterator
                        ? ts.Diagnostics.An_async_iterator_must_have_a_next_method
                        : ts.Diagnostics.An_iterator_must_have_a_next_method);
                }
                return undefined;
            }
            var nextResult = getUnionType(ts.map(nextMethodSignatures, getReturnTypeOfSignature), true);
            if (isTypeAny(nextResult)) {
                return undefined;
            }
            if (isAsyncIterator) {
                nextResult = getAwaitedTypeOfPromise(nextResult, errorNode, ts.Diagnostics.The_type_returned_by_the_next_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property);
                if (isTypeAny(nextResult)) {
                    return undefined;
                }
            }
            var nextValue = nextResult && getTypeOfPropertyOfType(nextResult, "value");
            if (!nextValue) {
                if (errorNode) {
                    error(errorNode, isAsyncIterator
                        ? ts.Diagnostics.The_type_returned_by_the_next_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property
                        : ts.Diagnostics.The_type_returned_by_the_next_method_of_an_iterator_must_have_a_value_property);
                }
                return undefined;
            }
            return isAsyncIterator
                ? typeAsIterator.iteratedTypeOfAsyncIterator = nextValue
                : typeAsIterator.iteratedTypeOfIterator = nextValue;
        }
        function getIteratedTypeOfGenerator(returnType, isAsyncGenerator) {
            if (isTypeAny(returnType)) {
                return undefined;
            }
            return getIteratedTypeOfIterable(returnType, undefined, isAsyncGenerator, false, false)
                || getIteratedTypeOfIterator(returnType, undefined, isAsyncGenerator);
        }
        function checkBreakOrContinueStatement(node) {
            checkGrammarStatementInAmbientContext(node) || checkGrammarBreakOrContinueStatement(node);
        }
        function isGetAccessorWithAnnotatedSetAccessor(node) {
            return !!(node.kind === 153 && ts.getSetAccessorTypeAnnotationNode(ts.getDeclarationOfKind(node.symbol, 154)));
        }
        function isUnwrappedReturnTypeVoidOrAny(func, returnType) {
            var unwrappedReturnType = (ts.getFunctionFlags(func) & 3) === 2
                ? getPromisedTypeOfPromise(returnType)
                : returnType;
            return unwrappedReturnType && maybeTypeOfKind(unwrappedReturnType, 1024 | 1);
        }
        function checkReturnStatement(node) {
            if (!checkGrammarStatementInAmbientContext(node)) {
                var functionBlock = ts.getContainingFunction(node);
                if (!functionBlock) {
                    grammarErrorOnFirstToken(node, ts.Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
                }
            }
            var func = ts.getContainingFunction(node);
            if (func) {
                var signature = getSignatureFromDeclaration(func);
                var returnType = getReturnTypeOfSignature(signature);
                if (strictNullChecks || node.expression || returnType.flags & 8192) {
                    var exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;
                    var functionFlags = ts.getFunctionFlags(func);
                    if (functionFlags & 1) {
                        return;
                    }
                    if (func.kind === 154) {
                        if (node.expression) {
                            error(node, ts.Diagnostics.Setters_cannot_return_a_value);
                        }
                    }
                    else if (func.kind === 152) {
                        if (node.expression && !checkTypeAssignableTo(exprType, returnType, node)) {
                            error(node, ts.Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
                        }
                    }
                    else if (func.type || isGetAccessorWithAnnotatedSetAccessor(func)) {
                        if (functionFlags & 2) {
                            var promisedType = getPromisedTypeOfPromise(returnType);
                            var awaitedType = checkAwaitedType(exprType, node, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member);
                            if (promisedType) {
                                checkTypeAssignableTo(awaitedType, promisedType, node);
                            }
                        }
                        else {
                            checkTypeAssignableTo(exprType, returnType, node);
                        }
                    }
                }
                else if (func.kind !== 152 && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeVoidOrAny(func, returnType)) {
                    error(node, ts.Diagnostics.Not_all_code_paths_return_a_value);
                }
            }
        }
        function checkWithStatement(node) {
            if (!checkGrammarStatementInAmbientContext(node)) {
                if (node.flags & 16384) {
                    grammarErrorOnFirstToken(node, ts.Diagnostics.with_statements_are_not_allowed_in_an_async_function_block);
                }
            }
            checkExpression(node.expression);
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                var start = ts.getSpanOfTokenAtPosition(sourceFile, node.pos).start;
                var end = node.statement.pos;
                grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any);
            }
        }
        function checkSwitchStatement(node) {
            checkGrammarStatementInAmbientContext(node);
            var firstDefaultClause;
            var hasDuplicateDefaultClause = false;
            var expressionType = checkExpression(node.expression);
            var expressionIsLiteral = isLiteralType(expressionType);
            ts.forEach(node.caseBlock.clauses, function (clause) {
                if (clause.kind === 258 && !hasDuplicateDefaultClause) {
                    if (firstDefaultClause === undefined) {
                        firstDefaultClause = clause;
                    }
                    else {
                        var sourceFile = ts.getSourceFileOfNode(node);
                        var start = ts.skipTrivia(sourceFile.text, clause.pos);
                        var end = clause.statements.length > 0 ? clause.statements[0].pos : clause.end;
                        grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
                        hasDuplicateDefaultClause = true;
                    }
                }
                if (produceDiagnostics && clause.kind === 257) {
                    var caseClause = clause;
                    var caseType = checkExpression(caseClause.expression);
                    var caseIsLiteral = isLiteralType(caseType);
                    var comparedExpressionType = expressionType;
                    if (!caseIsLiteral || !expressionIsLiteral) {
                        caseType = caseIsLiteral ? getBaseTypeOfLiteralType(caseType) : caseType;
                        comparedExpressionType = getBaseTypeOfLiteralType(expressionType);
                    }
                    if (!isTypeEqualityComparableTo(comparedExpressionType, caseType)) {
                        checkTypeComparableTo(caseType, comparedExpressionType, caseClause.expression, undefined);
                    }
                }
                ts.forEach(clause.statements, checkSourceElement);
            });
            if (node.caseBlock.locals) {
                registerForUnusedIdentifiersCheck(node.caseBlock);
            }
        }
        function checkLabeledStatement(node) {
            if (!checkGrammarStatementInAmbientContext(node)) {
                ts.findAncestor(node.parent, function (current) {
                    if (ts.isFunctionLike(current)) {
                        return "quit";
                    }
                    if (current.kind === 222 && current.label.text === node.label.text) {
                        var sourceFile = ts.getSourceFileOfNode(node);
                        grammarErrorOnNode(node.label, ts.Diagnostics.Duplicate_label_0, ts.getTextOfNodeFromSourceText(sourceFile.text, node.label));
                        return true;
                    }
                });
            }
            checkSourceElement(node.statement);
        }
        function checkThrowStatement(node) {
            if (!checkGrammarStatementInAmbientContext(node)) {
                if (node.expression === undefined) {
                    grammarErrorAfterFirstToken(node, ts.Diagnostics.Line_break_not_permitted_here);
                }
            }
            if (node.expression) {
                checkExpression(node.expression);
            }
        }
        function checkTryStatement(node) {
            checkGrammarStatementInAmbientContext(node);
            checkBlock(node.tryBlock);
            var catchClause = node.catchClause;
            if (catchClause) {
                if (catchClause.variableDeclaration) {
                    if (catchClause.variableDeclaration.type) {
                        grammarErrorOnFirstToken(catchClause.variableDeclaration.type, ts.Diagnostics.Catch_clause_variable_cannot_have_a_type_annotation);
                    }
                    else if (catchClause.variableDeclaration.initializer) {
                        grammarErrorOnFirstToken(catchClause.variableDeclaration.initializer, ts.Diagnostics.Catch_clause_variable_cannot_have_an_initializer);
                    }
                    else {
                        var blockLocals_1 = catchClause.block.locals;
                        if (blockLocals_1) {
                            ts.forEachKey(catchClause.locals, function (caughtName) {
                                var blockLocal = blockLocals_1.get(caughtName);
                                if (blockLocal && (blockLocal.flags & 2) !== 0) {
                                    grammarErrorOnNode(blockLocal.valueDeclaration, ts.Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, caughtName);
                                }
                            });
                        }
                    }
                }
                checkBlock(catchClause.block);
            }
            if (node.finallyBlock) {
                checkBlock(node.finallyBlock);
            }
        }
        function checkIndexConstraints(type) {
            var declaredNumberIndexer = getIndexDeclarationOfSymbol(type.symbol, 1);
            var declaredStringIndexer = getIndexDeclarationOfSymbol(type.symbol, 0);
            var stringIndexType = getIndexTypeOfType(type, 0);
            var numberIndexType = getIndexTypeOfType(type, 1);
            if (stringIndexType || numberIndexType) {
                ts.forEach(getPropertiesOfObjectType(type), function (prop) {
                    var propType = getTypeOfSymbol(prop);
                    checkIndexConstraintForProperty(prop, propType, type, declaredStringIndexer, stringIndexType, 0);
                    checkIndexConstraintForProperty(prop, propType, type, declaredNumberIndexer, numberIndexType, 1);
                });
                if (getObjectFlags(type) & 1 && ts.isClassLike(type.symbol.valueDeclaration)) {
                    var classDeclaration = type.symbol.valueDeclaration;
                    for (var _i = 0, _a = classDeclaration.members; _i < _a.length; _i++) {
                        var member = _a[_i];
                        if (!(ts.getModifierFlags(member) & 32) && ts.hasDynamicName(member)) {
                            var propType = getTypeOfSymbol(member.symbol);
                            checkIndexConstraintForProperty(member.symbol, propType, type, declaredStringIndexer, stringIndexType, 0);
                            checkIndexConstraintForProperty(member.symbol, propType, type, declaredNumberIndexer, numberIndexType, 1);
                        }
                    }
                }
            }
            var errorNode;
            if (stringIndexType && numberIndexType) {
                errorNode = declaredNumberIndexer || declaredStringIndexer;
                if (!errorNode && (getObjectFlags(type) & 2)) {
                    var someBaseTypeHasBothIndexers = ts.forEach(getBaseTypes(type), function (base) { return getIndexTypeOfType(base, 0) && getIndexTypeOfType(base, 1); });
                    errorNode = someBaseTypeHasBothIndexers ? undefined : type.symbol.declarations[0];
                }
            }
            if (errorNode && !isTypeAssignableTo(numberIndexType, stringIndexType)) {
                error(errorNode, ts.Diagnostics.Numeric_index_type_0_is_not_assignable_to_string_index_type_1, typeToString(numberIndexType), typeToString(stringIndexType));
            }
            function checkIndexConstraintForProperty(prop, propertyType, containingType, indexDeclaration, indexType, indexKind) {
                if (!indexType) {
                    return;
                }
                var propDeclaration = prop.valueDeclaration;
                if (indexKind === 1 && !(propDeclaration ? isNumericName(ts.getNameOfDeclaration(propDeclaration)) : isNumericLiteralName(prop.name))) {
                    return;
                }
                var errorNode;
                if (propDeclaration &&
                    (propDeclaration.kind === 194 ||
                        ts.getNameOfDeclaration(propDeclaration).kind === 144 ||
                        prop.parent === containingType.symbol)) {
                    errorNode = propDeclaration;
                }
                else if (indexDeclaration) {
                    errorNode = indexDeclaration;
                }
                else if (getObjectFlags(containingType) & 2) {
                    var someBaseClassHasBothPropertyAndIndexer = ts.forEach(getBaseTypes(containingType), function (base) { return getPropertyOfObjectType(base, prop.name) && getIndexTypeOfType(base, indexKind); });
                    errorNode = someBaseClassHasBothPropertyAndIndexer ? undefined : containingType.symbol.declarations[0];
                }
                if (errorNode && !isTypeAssignableTo(propertyType, indexType)) {
                    var errorMessage = indexKind === 0
                        ? ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_string_index_type_2
                        : ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2;
                    error(errorNode, errorMessage, symbolToString(prop), typeToString(propertyType), typeToString(indexType));
                }
            }
        }
        function checkTypeNameIsReserved(name, message) {
            switch (name.text) {
                case "any":
                case "number":
                case "boolean":
                case "string":
                case "symbol":
                case "void":
                case "object":
                    error(name, message, name.text);
            }
        }
        function checkTypeParameters(typeParameterDeclarations) {
            if (typeParameterDeclarations) {
                var seenDefault = false;
                for (var i = 0; i < typeParameterDeclarations.length; i++) {
                    var node = typeParameterDeclarations[i];
                    checkTypeParameter(node);
                    if (produceDiagnostics) {
                        if (node.default) {
                            seenDefault = true;
                        }
                        else if (seenDefault) {
                            error(node, ts.Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters);
                        }
                        for (var j = 0; j < i; j++) {
                            if (typeParameterDeclarations[j].symbol === node.symbol) {
                                error(node.name, ts.Diagnostics.Duplicate_identifier_0, ts.declarationNameToString(node.name));
                            }
                        }
                    }
                }
            }
        }
        function checkTypeParameterListsIdentical(symbol) {
            if (symbol.declarations.length === 1) {
                return;
            }
            var links = getSymbolLinks(symbol);
            if (!links.typeParametersChecked) {
                links.typeParametersChecked = true;
                var declarations = getClassOrInterfaceDeclarationsOfSymbol(symbol);
                if (declarations.length <= 1) {
                    return;
                }
                var type = getDeclaredTypeOfSymbol(symbol);
                if (!areTypeParametersIdentical(declarations, type.localTypeParameters)) {
                    var name = symbolToString(symbol);
                    for (var _i = 0, declarations_6 = declarations; _i < declarations_6.length; _i++) {
                        var declaration = declarations_6[_i];
                        error(declaration.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name);
                    }
                }
            }
        }
        function areTypeParametersIdentical(declarations, typeParameters) {
            var maxTypeArgumentCount = ts.length(typeParameters);
            var minTypeArgumentCount = getMinTypeArgumentCount(typeParameters);
            for (var _i = 0, declarations_7 = declarations; _i < declarations_7.length; _i++) {
                var declaration = declarations_7[_i];
                var numTypeParameters = ts.length(declaration.typeParameters);
                if (numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount) {
                    return false;
                }
                for (var i = 0; i < numTypeParameters; i++) {
                    var source = declaration.typeParameters[i];
                    var target = typeParameters[i];
                    if (source.name.text !== target.symbol.name) {
                        return false;
                    }
                    var sourceConstraint = source.constraint && getTypeFromTypeNode(source.constraint);
                    var targetConstraint = getConstraintFromTypeParameter(target);
                    if ((sourceConstraint || targetConstraint) &&
                        (!sourceConstraint || !targetConstraint || !isTypeIdenticalTo(sourceConstraint, targetConstraint))) {
                        return false;
                    }
                    var sourceDefault = source.default && getTypeFromTypeNode(source.default);
                    var targetDefault = getDefaultFromTypeParameter(target);
                    if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {
                        return false;
                    }
                }
            }
            return true;
        }
        function checkClassExpression(node) {
            checkClassLikeDeclaration(node);
            checkNodeDeferred(node);
            return getTypeOfSymbol(getSymbolOfNode(node));
        }
        function checkClassExpressionDeferred(node) {
            ts.forEach(node.members, checkSourceElement);
            registerForUnusedIdentifiersCheck(node);
        }
        function checkClassDeclaration(node) {
            if (!node.name && !(ts.getModifierFlags(node) & 512)) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name);
            }
            checkClassLikeDeclaration(node);
            ts.forEach(node.members, checkSourceElement);
            registerForUnusedIdentifiersCheck(node);
        }
        function checkClassLikeDeclaration(node) {
            checkGrammarClassLikeDeclaration(node);
            checkDecorators(node);
            if (node.name) {
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Class_name_cannot_be_0);
                checkCollisionWithCapturedThisVariable(node, node.name);
                checkCollisionWithCapturedNewTargetVariable(node, node.name);
                checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
                checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
            }
            checkTypeParameters(node.typeParameters);
            checkExportsOnMergedDeclarations(node);
            var symbol = getSymbolOfNode(node);
            var type = getDeclaredTypeOfSymbol(symbol);
            var typeWithThis = getTypeWithThisArgument(type);
            var staticType = getTypeOfSymbol(symbol);
            checkTypeParameterListsIdentical(symbol);
            checkClassForDuplicateDeclarations(node);
            if (!ts.isInAmbientContext(node)) {
                checkClassForStaticPropertyNameConflicts(node);
            }
            var baseTypeNode = ts.getClassExtendsHeritageClauseElement(node);
            if (baseTypeNode) {
                if (languageVersion < 2) {
                    checkExternalEmitHelpers(baseTypeNode.parent, 1);
                }
                var baseTypes = getBaseTypes(type);
                if (baseTypes.length && produceDiagnostics) {
                    var baseType_1 = baseTypes[0];
                    var baseConstructorType = getBaseConstructorTypeOfClass(type);
                    var staticBaseType = getApparentType(baseConstructorType);
                    checkBaseTypeAccessibility(staticBaseType, baseTypeNode);
                    checkSourceElement(baseTypeNode.expression);
                    if (baseTypeNode.typeArguments) {
                        ts.forEach(baseTypeNode.typeArguments, checkSourceElement);
                        for (var _i = 0, _a = getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode); _i < _a.length; _i++) {
                            var constructor = _a[_i];
                            if (!checkTypeArgumentConstraints(constructor.typeParameters, baseTypeNode.typeArguments)) {
                                break;
                            }
                        }
                    }
                    checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType_1, type.thisType), node.name || node, ts.Diagnostics.Class_0_incorrectly_extends_base_class_1);
                    checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, ts.Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
                    if (baseConstructorType.flags & 540672 && !isMixinConstructorType(staticType)) {
                        error(node.name || node, ts.Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);
                    }
                    if (!(staticBaseType.symbol && staticBaseType.symbol.flags & 32) && !(baseConstructorType.flags & 540672)) {
                        var constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);
                        if (ts.forEach(constructors, function (sig) { return getReturnTypeOfSignature(sig) !== baseType_1; })) {
                            error(baseTypeNode.expression, ts.Diagnostics.Base_constructors_must_all_have_the_same_return_type);
                        }
                    }
                    checkKindsOfPropertyMemberOverrides(type, baseType_1);
                }
            }
            var implementedTypeNodes = ts.getClassImplementsHeritageClauseElements(node);
            if (implementedTypeNodes) {
                for (var _b = 0, implementedTypeNodes_1 = implementedTypeNodes; _b < implementedTypeNodes_1.length; _b++) {
                    var typeRefNode = implementedTypeNodes_1[_b];
                    if (!ts.isEntityNameExpression(typeRefNode.expression)) {
                        error(typeRefNode.expression, ts.Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments);
                    }
                    checkTypeReferenceNode(typeRefNode);
                    if (produceDiagnostics) {
                        var t = getTypeFromTypeNode(typeRefNode);
                        if (t !== unknownType) {
                            if (isValidBaseType(t)) {
                                checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(t, type.thisType), node.name || node, ts.Diagnostics.Class_0_incorrectly_implements_interface_1);
                            }
                            else {
                                error(typeRefNode, ts.Diagnostics.A_class_may_only_implement_another_class_or_interface);
                            }
                        }
                    }
                }
            }
            if (produceDiagnostics) {
                checkIndexConstraints(type);
                checkTypeForDuplicateIndexSignatures(node);
            }
        }
        function checkBaseTypeAccessibility(type, node) {
            var signatures = getSignaturesOfType(type, 1);
            if (signatures.length) {
                var declaration = signatures[0].declaration;
                if (declaration && ts.getModifierFlags(declaration) & 8) {
                    var typeClassDeclaration = getClassLikeDeclarationOfSymbol(type.symbol);
                    if (!isNodeWithinClass(node, typeClassDeclaration)) {
                        error(node, ts.Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type.symbol));
                    }
                }
            }
        }
        function getTargetSymbol(s) {
            return getCheckFlags(s) & 1 ? s.target : s;
        }
        function getClassLikeDeclarationOfSymbol(symbol) {
            return ts.forEach(symbol.declarations, function (d) { return ts.isClassLike(d) ? d : undefined; });
        }
        function getClassOrInterfaceDeclarationsOfSymbol(symbol) {
            return ts.filter(symbol.declarations, function (d) {
                return d.kind === 229 || d.kind === 230;
            });
        }
        function checkKindsOfPropertyMemberOverrides(type, baseType) {
            var baseProperties = getPropertiesOfType(baseType);
            for (var _i = 0, baseProperties_1 = baseProperties; _i < baseProperties_1.length; _i++) {
                var baseProperty = baseProperties_1[_i];
                var base = getTargetSymbol(baseProperty);
                if (base.flags & 16777216) {
                    continue;
                }
                var derived = getTargetSymbol(getPropertyOfObjectType(type, base.name));
                var baseDeclarationFlags = getDeclarationModifierFlagsFromSymbol(base);
                ts.Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");
                if (derived) {
                    if (derived === base) {
                        var derivedClassDecl = getClassLikeDeclarationOfSymbol(type.symbol);
                        if (baseDeclarationFlags & 128 && (!derivedClassDecl || !(ts.getModifierFlags(derivedClassDecl) & 128))) {
                            if (derivedClassDecl.kind === 199) {
                                error(derivedClassDecl, ts.Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, symbolToString(baseProperty), typeToString(baseType));
                            }
                            else {
                                error(derivedClassDecl, ts.Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, typeToString(type), symbolToString(baseProperty), typeToString(baseType));
                            }
                        }
                    }
                    else {
                        var derivedDeclarationFlags = getDeclarationModifierFlagsFromSymbol(derived);
                        if (baseDeclarationFlags & 8 || derivedDeclarationFlags & 8) {
                            continue;
                        }
                        if ((baseDeclarationFlags & 32) !== (derivedDeclarationFlags & 32)) {
                            continue;
                        }
                        if (isMethodLike(base) && isMethodLike(derived) || base.flags & 98308 && derived.flags & 98308) {
                            continue;
                        }
                        var errorMessage = void 0;
                        if (isMethodLike(base)) {
                            if (derived.flags & 98304) {
                                errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                            }
                            else {
                                errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                            }
                        }
                        else if (base.flags & 4) {
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                        }
                        else {
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                        }
                        error(ts.getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));
                    }
                }
            }
        }
        function isAccessor(kind) {
            return kind === 153 || kind === 154;
        }
        function checkInheritedPropertiesAreIdentical(type, typeNode) {
            var baseTypes = getBaseTypes(type);
            if (baseTypes.length < 2) {
                return true;
            }
            var seen = ts.createMap();
            ts.forEach(resolveDeclaredMembers(type).declaredProperties, function (p) { seen.set(p.name, { prop: p, containingType: type }); });
            var ok = true;
            for (var _i = 0, baseTypes_2 = baseTypes; _i < baseTypes_2.length; _i++) {
                var base = baseTypes_2[_i];
                var properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
                for (var _a = 0, properties_8 = properties; _a < properties_8.length; _a++) {
                    var prop = properties_8[_a];
                    var existing = seen.get(prop.name);
                    if (!existing) {
                        seen.set(prop.name, { prop: prop, containingType: base });
                    }
                    else {
                        var isInheritedProperty = existing.containingType !== type;
                        if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {
                            ok = false;
                            var typeName1 = typeToString(existing.containingType);
                            var typeName2 = typeToString(base);
                            var errorInfo = ts.chainDiagnosticMessages(undefined, ts.Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, symbolToString(prop), typeName1, typeName2);
                            errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2);
                            diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(typeNode, errorInfo));
                        }
                    }
                }
            }
            return ok;
        }
        function checkInterfaceDeclaration(node) {
            checkGrammarDecorators(node) || checkGrammarModifiers(node) || checkGrammarInterfaceDeclaration(node);
            checkTypeParameters(node.typeParameters);
            if (produceDiagnostics) {
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Interface_name_cannot_be_0);
                checkExportsOnMergedDeclarations(node);
                var symbol = getSymbolOfNode(node);
                checkTypeParameterListsIdentical(symbol);
                var firstInterfaceDecl = ts.getDeclarationOfKind(symbol, 230);
                if (node === firstInterfaceDecl) {
                    var type = getDeclaredTypeOfSymbol(symbol);
                    var typeWithThis = getTypeWithThisArgument(type);
                    if (checkInheritedPropertiesAreIdentical(type, node.name)) {
                        for (var _i = 0, _a = getBaseTypes(type); _i < _a.length; _i++) {
                            var baseType = _a[_i];
                            checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type.thisType), node.name, ts.Diagnostics.Interface_0_incorrectly_extends_interface_1);
                        }
                        checkIndexConstraints(type);
                    }
                }
                checkObjectTypeForDuplicateDeclarations(node);
            }
            ts.forEach(ts.getInterfaceBaseTypeNodes(node), function (heritageElement) {
                if (!ts.isEntityNameExpression(heritageElement.expression)) {
                    error(heritageElement.expression, ts.Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments);
                }
                checkTypeReferenceNode(heritageElement);
            });
            ts.forEach(node.members, checkSourceElement);
            if (produceDiagnostics) {
                checkTypeForDuplicateIndexSignatures(node);
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkTypeAliasDeclaration(node) {
            checkGrammarDecorators(node) || checkGrammarModifiers(node);
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_alias_name_cannot_be_0);
            checkTypeParameters(node.typeParameters);
            checkSourceElement(node.type);
        }
        function computeEnumMemberValues(node) {
            var nodeLinks = getNodeLinks(node);
            if (!(nodeLinks.flags & 16384)) {
                var enumSymbol = getSymbolOfNode(node);
                var enumType = getDeclaredTypeOfSymbol(enumSymbol);
                var autoValue = 0;
                var ambient = ts.isInAmbientContext(node);
                var enumIsConst = ts.isConst(node);
                for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                    var member = _a[_i];
                    if (isComputedNonLiteralName(member.name)) {
                        error(member.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_enums);
                    }
                    else {
                        var text = ts.getTextOfPropertyName(member.name);
                        if (isNumericLiteralName(text) && !isInfinityOrNaNString(text)) {
                            error(member.name, ts.Diagnostics.An_enum_member_cannot_have_a_numeric_name);
                        }
                    }
                    var previousEnumMemberIsNonConstant = autoValue === undefined;
                    var initializer = member.initializer;
                    if (initializer) {
                        autoValue = computeConstantValueForEnumMemberInitializer(initializer, enumType, enumIsConst, ambient);
                    }
                    else if (ambient && !enumIsConst) {
                        autoValue = undefined;
                    }
                    else if (previousEnumMemberIsNonConstant) {
                        error(member.name, ts.Diagnostics.Enum_member_must_have_initializer);
                    }
                    if (autoValue !== undefined) {
                        getNodeLinks(member).enumMemberValue = autoValue;
                        autoValue++;
                    }
                }
                nodeLinks.flags |= 16384;
            }
            function computeConstantValueForEnumMemberInitializer(initializer, enumType, enumIsConst, ambient) {
                var reportError = true;
                var value = evalConstant(initializer);
                if (reportError) {
                    if (value === undefined) {
                        if (enumIsConst) {
                            error(initializer, ts.Diagnostics.In_const_enum_declarations_member_initializer_must_be_constant_expression);
                        }
                        else if (ambient) {
                            error(initializer, ts.Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression);
                        }
                        else {
                            checkTypeAssignableTo(checkExpression(initializer), enumType, initializer, undefined);
                        }
                    }
                    else if (enumIsConst) {
                        if (isNaN(value)) {
                            error(initializer, ts.Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN);
                        }
                        else if (!isFinite(value)) {
                            error(initializer, ts.Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value);
                        }
                    }
                }
                return value;
                function evalConstant(e) {
                    switch (e.kind) {
                        case 192:
                            var value_1 = evalConstant(e.operand);
                            if (value_1 === undefined) {
                                return undefined;
                            }
                            switch (e.operator) {
                                case 37: return value_1;
                                case 38: return -value_1;
                                case 52: return ~value_1;
                            }
                            return undefined;
                        case 194:
                            var left = evalConstant(e.left);
                            if (left === undefined) {
                                return undefined;
                            }
                            var right = evalConstant(e.right);
                            if (right === undefined) {
                                return undefined;
                            }
                            switch (e.operatorToken.kind) {
                                case 49: return left | right;
                                case 48: return left & right;
                                case 46: return left >> right;
                                case 47: return left >>> right;
                                case 45: return left << right;
                                case 50: return left ^ right;
                                case 39: return left * right;
                                case 41: return left / right;
                                case 37: return left + right;
                                case 38: return left - right;
                                case 42: return left % right;
                            }
                            return undefined;
                        case 8:
                            checkGrammarNumericLiteral(e);
                            return +e.text;
                        case 185:
                            return evalConstant(e.expression);
                        case 71:
                        case 180:
                        case 179:
                            var member = initializer.parent;
                            var currentType = getTypeOfSymbol(getSymbolOfNode(member.parent));
                            var enumType_1;
                            var propertyName = void 0;
                            if (e.kind === 71) {
                                enumType_1 = currentType;
                                propertyName = e.text;
                            }
                            else {
                                var expression = void 0;
                                if (e.kind === 180) {
                                    if (e.argumentExpression === undefined ||
                                        e.argumentExpression.kind !== 9) {
                                        return undefined;
                                    }
                                    expression = e.expression;
                                    propertyName = e.argumentExpression.text;
                                }
                                else {
                                    expression = e.expression;
                                    propertyName = e.name.text;
                                }
                                var current = expression;
                                while (current) {
                                    if (current.kind === 71) {
                                        break;
                                    }
                                    else if (current.kind === 179) {
                                        current = current.expression;
                                    }
                                    else {
                                        return undefined;
                                    }
                                }
                                enumType_1 = getTypeOfExpression(expression);
                                if (!(enumType_1.symbol && (enumType_1.symbol.flags & 384))) {
                                    return undefined;
                                }
                            }
                            if (propertyName === undefined) {
                                return undefined;
                            }
                            var property = getPropertyOfObjectType(enumType_1, propertyName);
                            if (!property || !(property.flags & 8)) {
                                return undefined;
                            }
                            var propertyDecl = property.valueDeclaration;
                            if (member === propertyDecl) {
                                return undefined;
                            }
                            if (!isBlockScopedNameDeclaredBeforeUse(propertyDecl, member)) {
                                reportError = false;
                                error(e, ts.Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums);
                                return undefined;
                            }
                            return getNodeLinks(propertyDecl).enumMemberValue;
                    }
                }
            }
        }
        function checkEnumDeclaration(node) {
            if (!produceDiagnostics) {
                return;
            }
            checkGrammarDecorators(node) || checkGrammarModifiers(node);
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Enum_name_cannot_be_0);
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollisionWithCapturedNewTargetVariable(node, node.name);
            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
            checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
            checkExportsOnMergedDeclarations(node);
            computeEnumMemberValues(node);
            var enumIsConst = ts.isConst(node);
            if (compilerOptions.isolatedModules && enumIsConst && ts.isInAmbientContext(node)) {
                error(node.name, ts.Diagnostics.Ambient_const_enums_are_not_allowed_when_the_isolatedModules_flag_is_provided);
            }
            var enumSymbol = getSymbolOfNode(node);
            var firstDeclaration = ts.getDeclarationOfKind(enumSymbol, node.kind);
            if (node === firstDeclaration) {
                if (enumSymbol.declarations.length > 1) {
                    ts.forEach(enumSymbol.declarations, function (decl) {
                        if (ts.isConstEnumDeclaration(decl) !== enumIsConst) {
                            error(ts.getNameOfDeclaration(decl), ts.Diagnostics.Enum_declarations_must_all_be_const_or_non_const);
                        }
                    });
                }
                var seenEnumMissingInitialInitializer_1 = false;
                ts.forEach(enumSymbol.declarations, function (declaration) {
                    if (declaration.kind !== 232) {
                        return false;
                    }
                    var enumDeclaration = declaration;
                    if (!enumDeclaration.members.length) {
                        return false;
                    }
                    var firstEnumMember = enumDeclaration.members[0];
                    if (!firstEnumMember.initializer) {
                        if (seenEnumMissingInitialInitializer_1) {
                            error(firstEnumMember.name, ts.Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
                        }
                        else {
                            seenEnumMissingInitialInitializer_1 = true;
                        }
                    }
                });
            }
        }
        function getFirstNonAmbientClassOrFunctionDeclaration(symbol) {
            var declarations = symbol.declarations;
            for (var _i = 0, declarations_8 = declarations; _i < declarations_8.length; _i++) {
                var declaration = declarations_8[_i];
                if ((declaration.kind === 229 ||
                    (declaration.kind === 228 && ts.nodeIsPresent(declaration.body))) &&
                    !ts.isInAmbientContext(declaration)) {
                    return declaration;
                }
            }
            return undefined;
        }
        function inSameLexicalScope(node1, node2) {
            var container1 = ts.getEnclosingBlockScopeContainer(node1);
            var container2 = ts.getEnclosingBlockScopeContainer(node2);
            if (isGlobalSourceFile(container1)) {
                return isGlobalSourceFile(container2);
            }
            else if (isGlobalSourceFile(container2)) {
                return false;
            }
            else {
                return container1 === container2;
            }
        }
        function checkModuleDeclaration(node) {
            if (produceDiagnostics) {
                var isGlobalAugmentation = ts.isGlobalScopeAugmentation(node);
                var inAmbientContext = ts.isInAmbientContext(node);
                if (isGlobalAugmentation && !inAmbientContext) {
                    error(node.name, ts.Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context);
                }
                var isAmbientExternalModule = ts.isAmbientModule(node);
                var contextErrorMessage = isAmbientExternalModule
                    ? ts.Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file
                    : ts.Diagnostics.A_namespace_declaration_is_only_allowed_in_a_namespace_or_module;
                if (checkGrammarModuleElementContext(node, contextErrorMessage)) {
                    return;
                }
                if (!checkGrammarDecorators(node) && !checkGrammarModifiers(node)) {
                    if (!inAmbientContext && node.name.kind === 9) {
                        grammarErrorOnNode(node.name, ts.Diagnostics.Only_ambient_modules_can_use_quoted_names);
                    }
                }
                if (ts.isIdentifier(node.name)) {
                    checkCollisionWithCapturedThisVariable(node, node.name);
                    checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
                    checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
                }
                checkExportsOnMergedDeclarations(node);
                var symbol = getSymbolOfNode(node);
                if (symbol.flags & 512
                    && symbol.declarations.length > 1
                    && !inAmbientContext
                    && ts.isInstantiatedModule(node, compilerOptions.preserveConstEnums || compilerOptions.isolatedModules)) {
                    var firstNonAmbientClassOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);
                    if (firstNonAmbientClassOrFunc) {
                        if (ts.getSourceFileOfNode(node) !== ts.getSourceFileOfNode(firstNonAmbientClassOrFunc)) {
                            error(node.name, ts.Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
                        }
                        else if (node.pos < firstNonAmbientClassOrFunc.pos) {
                            error(node.name, ts.Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
                        }
                    }
                    var mergedClass = ts.getDeclarationOfKind(symbol, 229);
                    if (mergedClass &&
                        inSameLexicalScope(node, mergedClass)) {
                        getNodeLinks(node).flags |= 32768;
                    }
                }
                if (isAmbientExternalModule) {
                    if (ts.isExternalModuleAugmentation(node)) {
                        var checkBody = isGlobalAugmentation || (getSymbolOfNode(node).flags & 134217728);
                        if (checkBody && node.body) {
                            for (var _i = 0, _a = node.body.statements; _i < _a.length; _i++) {
                                var statement = _a[_i];
                                checkModuleAugmentationElement(statement, isGlobalAugmentation);
                            }
                        }
                    }
                    else if (isGlobalSourceFile(node.parent)) {
                        if (isGlobalAugmentation) {
                            error(node.name, ts.Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
                        }
                        else if (ts.isExternalModuleNameRelative(node.name.text)) {
                            error(node.name, ts.Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name);
                        }
                    }
                    else {
                        if (isGlobalAugmentation) {
                            error(node.name, ts.Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
                        }
                        else {
                            error(node.name, ts.Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces);
                        }
                    }
                }
            }
            if (node.body) {
                checkSourceElement(node.body);
                if (!ts.isGlobalScopeAugmentation(node)) {
                    registerForUnusedIdentifiersCheck(node);
                }
            }
        }
        function checkModuleAugmentationElement(node, isGlobalAugmentation) {
            switch (node.kind) {
                case 208:
                    for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                        var decl = _a[_i];
                        checkModuleAugmentationElement(decl, isGlobalAugmentation);
                    }
                    break;
                case 243:
                case 244:
                    grammarErrorOnFirstToken(node, ts.Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations);
                    break;
                case 237:
                case 238:
                    grammarErrorOnFirstToken(node, ts.Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module);
                    break;
                case 176:
                case 226:
                    var name = node.name;
                    if (ts.isBindingPattern(name)) {
                        for (var _b = 0, _c = name.elements; _b < _c.length; _b++) {
                            var el = _c[_b];
                            checkModuleAugmentationElement(el, isGlobalAugmentation);
                        }
                        break;
                    }
                case 229:
                case 232:
                case 228:
                case 230:
                case 233:
                case 231:
                    if (isGlobalAugmentation) {
                        return;
                    }
                    var symbol = getSymbolOfNode(node);
                    if (symbol) {
                        var reportError = !(symbol.flags & 134217728);
                        if (!reportError) {
                            reportError = ts.isExternalModuleAugmentation(symbol.parent.declarations[0]);
                        }
                    }
                    break;
            }
        }
        function getFirstIdentifier(node) {
            switch (node.kind) {
                case 71:
                    return node;
                case 143:
                    do {
                        node = node.left;
                    } while (node.kind !== 71);
                    return node;
                case 179:
                    do {
                        node = node.expression;
                    } while (node.kind !== 71);
                    return node;
            }
        }
        function checkExternalImportOrExportDeclaration(node) {
            var moduleName = ts.getExternalModuleName(node);
            if (!ts.nodeIsMissing(moduleName) && moduleName.kind !== 9) {
                error(moduleName, ts.Diagnostics.String_literal_expected);
                return false;
            }
            var inAmbientExternalModule = node.parent.kind === 234 && ts.isAmbientModule(node.parent.parent);
            if (node.parent.kind !== 265 && !inAmbientExternalModule) {
                error(moduleName, node.kind === 244 ?
                    ts.Diagnostics.Export_declarations_are_not_permitted_in_a_namespace :
                    ts.Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module);
                return false;
            }
            if (inAmbientExternalModule && ts.isExternalModuleNameRelative(moduleName.text)) {
                if (!isTopLevelInExternalModuleAugmentation(node)) {
                    error(node, ts.Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name);
                    return false;
                }
            }
            return true;
        }
        function checkAliasSymbol(node) {
            var symbol = getSymbolOfNode(node);
            var target = resolveAlias(symbol);
            if (target !== unknownSymbol) {
                var excludedMeanings = (symbol.flags & (107455 | 1048576) ? 107455 : 0) |
                    (symbol.flags & 793064 ? 793064 : 0) |
                    (symbol.flags & 1920 ? 1920 : 0);
                if (target.flags & excludedMeanings) {
                    var message = node.kind === 246 ?
                        ts.Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 :
                        ts.Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0;
                    error(node, message, symbolToString(symbol));
                }
            }
        }
        function checkImportBinding(node) {
            checkCollisionWithCapturedThisVariable(node, node.name);
            checkCollisionWithRequireExportsInGeneratedCode(node, node.name);
            checkCollisionWithGlobalPromiseInGeneratedCode(node, node.name);
            checkAliasSymbol(node);
        }
        function checkImportDeclaration(node) {
            if (checkGrammarModuleElementContext(node, ts.Diagnostics.An_import_declaration_can_only_be_used_in_a_namespace_or_module)) {
                return;
            }
            if (!checkGrammarDecorators(node) && !checkGrammarModifiers(node) && ts.getModifierFlags(node) !== 0) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.An_import_declaration_cannot_have_modifiers);
            }
            if (checkExternalImportOrExportDeclaration(node)) {
                var importClause = node.importClause;
                if (importClause) {
                    if (importClause.name) {
                        checkImportBinding(importClause);
                    }
                    if (importClause.namedBindings) {
                        if (importClause.namedBindings.kind === 240) {
                            checkImportBinding(importClause.namedBindings);
                        }
                        else {
                            ts.forEach(importClause.namedBindings.elements, checkImportBinding);
                        }
                    }
                }
            }
        }
        function checkImportEqualsDeclaration(node) {
            if (checkGrammarModuleElementContext(node, ts.Diagnostics.An_import_declaration_can_only_be_used_in_a_namespace_or_module)) {
                return;
            }
            checkGrammarDecorators(node) || checkGrammarModifiers(node);
            if (ts.isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node)) {
                checkImportBinding(node);
                if (ts.getModifierFlags(node) & 1) {
                    markExportAsReferenced(node);
                }
                if (ts.isInternalModuleImportEqualsDeclaration(node)) {
                    var target = resolveAlias(getSymbolOfNode(node));
                    if (target !== unknownSymbol) {
                        if (target.flags & 107455) {
                            var moduleName = getFirstIdentifier(node.moduleReference);
                            if (!(resolveEntityName(moduleName, 107455 | 1920).flags & 1920)) {
                                error(moduleName, ts.Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, ts.declarationNameToString(moduleName));
                            }
                        }
                        if (target.flags & 793064) {
                            checkTypeNameIsReserved(node.name, ts.Diagnostics.Import_name_cannot_be_0);
                        }
                    }
                }
                else {
                    if (modulekind === ts.ModuleKind.ES2015 && !ts.isInAmbientContext(node)) {
                        grammarErrorOnNode(node, ts.Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_2015_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead);
                    }
                }
            }
        }
        function checkExportDeclaration(node) {
            if (checkGrammarModuleElementContext(node, ts.Diagnostics.An_export_declaration_can_only_be_used_in_a_module)) {
                return;
            }
            if (!checkGrammarDecorators(node) && !checkGrammarModifiers(node) && ts.getModifierFlags(node) !== 0) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.An_export_declaration_cannot_have_modifiers);
            }
            if (!node.moduleSpecifier || checkExternalImportOrExportDeclaration(node)) {
                if (node.exportClause) {
                    ts.forEach(node.exportClause.elements, checkExportSpecifier);
                    var inAmbientExternalModule = node.parent.kind === 234 && ts.isAmbientModule(node.parent.parent);
                    var inAmbientNamespaceDeclaration = !inAmbientExternalModule && node.parent.kind === 234 &&
                        !node.moduleSpecifier && ts.isInAmbientContext(node);
                    if (node.parent.kind !== 265 && !inAmbientExternalModule && !inAmbientNamespaceDeclaration) {
                        error(node, ts.Diagnostics.Export_declarations_are_not_permitted_in_a_namespace);
                    }
                }
                else {
                    var moduleSymbol = resolveExternalModuleName(node, node.moduleSpecifier);
                    if (moduleSymbol && hasExportAssignmentSymbol(moduleSymbol)) {
                        error(node.moduleSpecifier, ts.Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, symbolToString(moduleSymbol));
                    }
                }
            }
        }
        function checkGrammarModuleElementContext(node, errorMessage) {
            var isInAppropriateContext = node.parent.kind === 265 || node.parent.kind === 234 || node.parent.kind === 233;
            if (!isInAppropriateContext) {
                grammarErrorOnFirstToken(node, errorMessage);
            }
            return !isInAppropriateContext;
        }
        function checkExportSpecifier(node) {
            checkAliasSymbol(node);
            if (!node.parent.parent.moduleSpecifier) {
                var exportedName = node.propertyName || node.name;
                var symbol = resolveName(exportedName, exportedName.text, 107455 | 793064 | 1920 | 8388608, undefined, undefined);
                if (symbol && (symbol === undefinedSymbol || isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0])))) {
                    error(exportedName, ts.Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, exportedName.text);
                }
                else {
                    markExportAsReferenced(node);
                }
            }
        }
        function checkExportAssignment(node) {
            if (checkGrammarModuleElementContext(node, ts.Diagnostics.An_export_assignment_can_only_be_used_in_a_module)) {
                return;
            }
            var container = node.parent.kind === 265 ? node.parent : node.parent.parent;
            if (container.kind === 233 && !ts.isAmbientModule(container)) {
                if (node.isExportEquals) {
                    error(node, ts.Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace);
                }
                else {
                    error(node, ts.Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
                }
                return;
            }
            if (!checkGrammarDecorators(node) && !checkGrammarModifiers(node) && ts.getModifierFlags(node) !== 0) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.An_export_assignment_cannot_have_modifiers);
            }
            if (node.expression.kind === 71) {
                markExportAsReferenced(node);
            }
            else {
                checkExpressionCached(node.expression);
            }
            checkExternalModuleExports(container);
            if (node.isExportEquals && !ts.isInAmbientContext(node)) {
                if (modulekind === ts.ModuleKind.ES2015) {
                    grammarErrorOnNode(node, ts.Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_2015_modules_Consider_using_export_default_or_another_module_format_instead);
                }
                else if (modulekind === ts.ModuleKind.System) {
                    grammarErrorOnNode(node, ts.Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system);
                }
            }
        }
        function hasExportedMembers(moduleSymbol) {
            return ts.forEachEntry(moduleSymbol.exports, function (_, id) { return id !== "export="; });
        }
        function checkExternalModuleExports(node) {
            var moduleSymbol = getSymbolOfNode(node);
            var links = getSymbolLinks(moduleSymbol);
            if (!links.exportsChecked) {
                var exportEqualsSymbol = moduleSymbol.exports.get("export=");
                if (exportEqualsSymbol && hasExportedMembers(moduleSymbol)) {
                    var declaration = getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration;
                    if (!isTopLevelInExternalModuleAugmentation(declaration)) {
                        error(declaration, ts.Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);
                    }
                }
                var exports = getExportsOfModule(moduleSymbol);
                exports && exports.forEach(function (_a, id) {
                    var declarations = _a.declarations, flags = _a.flags;
                    if (id === "__export") {
                        return;
                    }
                    if (flags & (1920 | 64 | 384)) {
                        return;
                    }
                    var exportedDeclarationsCount = ts.countWhere(declarations, isNotOverload);
                    if (flags & 524288 && exportedDeclarationsCount <= 2) {
                        return;
                    }
                    if (exportedDeclarationsCount > 1) {
                        for (var _i = 0, declarations_9 = declarations; _i < declarations_9.length; _i++) {
                            var declaration = declarations_9[_i];
                            if (isNotOverload(declaration)) {
                                diagnostics.add(ts.createDiagnosticForNode(declaration, ts.Diagnostics.Cannot_redeclare_exported_variable_0, id));
                            }
                        }
                    }
                });
                links.exportsChecked = true;
            }
            function isNotOverload(declaration) {
                return (declaration.kind !== 228 && declaration.kind !== 151) ||
                    !!declaration.body;
            }
        }
        function checkSourceElement(node) {
            if (!node) {
                return;
            }
            var kind = node.kind;
            if (cancellationToken) {
                switch (kind) {
                    case 233:
                    case 229:
                    case 230:
                    case 228:
                        cancellationToken.throwIfCancellationRequested();
                }
            }
            switch (kind) {
                case 145:
                    return checkTypeParameter(node);
                case 146:
                    return checkParameter(node);
                case 149:
                case 148:
                    return checkPropertyDeclaration(node);
                case 160:
                case 161:
                case 155:
                case 156:
                    return checkSignatureDeclaration(node);
                case 157:
                    return checkSignatureDeclaration(node);
                case 151:
                case 150:
                    return checkMethodDeclaration(node);
                case 152:
                    return checkConstructorDeclaration(node);
                case 153:
                case 154:
                    return checkAccessorDeclaration(node);
                case 159:
                    return checkTypeReferenceNode(node);
                case 158:
                    return checkTypePredicate(node);
                case 162:
                    return checkTypeQuery(node);
                case 163:
                    return checkTypeLiteral(node);
                case 164:
                    return checkArrayType(node);
                case 165:
                    return checkTupleType(node);
                case 166:
                case 167:
                    return checkUnionOrIntersectionType(node);
                case 168:
                case 170:
                    return checkSourceElement(node.type);
                case 171:
                    return checkIndexedAccessType(node);
                case 172:
                    return checkMappedType(node);
                case 228:
                    return checkFunctionDeclaration(node);
                case 207:
                case 234:
                    return checkBlock(node);
                case 208:
                    return checkVariableStatement(node);
                case 210:
                    return checkExpressionStatement(node);
                case 211:
                    return checkIfStatement(node);
                case 212:
                    return checkDoStatement(node);
                case 213:
                    return checkWhileStatement(node);
                case 214:
                    return checkForStatement(node);
                case 215:
                    return checkForInStatement(node);
                case 216:
                    return checkForOfStatement(node);
                case 217:
                case 218:
                    return checkBreakOrContinueStatement(node);
                case 219:
                    return checkReturnStatement(node);
                case 220:
                    return checkWithStatement(node);
                case 221:
                    return checkSwitchStatement(node);
                case 222:
                    return checkLabeledStatement(node);
                case 223:
                    return checkThrowStatement(node);
                case 224:
                    return checkTryStatement(node);
                case 226:
                    return checkVariableDeclaration(node);
                case 176:
                    return checkBindingElement(node);
                case 229:
                    return checkClassDeclaration(node);
                case 230:
                    return checkInterfaceDeclaration(node);
                case 231:
                    return checkTypeAliasDeclaration(node);
                case 232:
                    return checkEnumDeclaration(node);
                case 233:
                    return checkModuleDeclaration(node);
                case 238:
                    return checkImportDeclaration(node);
                case 237:
                    return checkImportEqualsDeclaration(node);
                case 244:
                    return checkExportDeclaration(node);
                case 243:
                    return checkExportAssignment(node);
                case 209:
                    checkGrammarStatementInAmbientContext(node);
                    return;
                case 225:
                    checkGrammarStatementInAmbientContext(node);
                    return;
                case 247:
                    return checkMissingDeclaration(node);
            }
        }
        function checkNodeDeferred(node) {
            if (deferredNodes) {
                deferredNodes.push(node);
            }
        }
        function checkDeferredNodes() {
            for (var _i = 0, deferredNodes_1 = deferredNodes; _i < deferredNodes_1.length; _i++) {
                var node = deferredNodes_1[_i];
                switch (node.kind) {
                    case 186:
                    case 187:
                    case 151:
                    case 150:
                        checkFunctionExpressionOrObjectLiteralMethodDeferred(node);
                        break;
                    case 153:
                    case 154:
                        checkAccessorDeclaration(node);
                        break;
                    case 199:
                        checkClassExpressionDeferred(node);
                        break;
                }
            }
        }
        function checkSourceFile(node) {
            ts.performance.mark("beforeCheck");
            checkSourceFileWorker(node);
            ts.performance.mark("afterCheck");
            ts.performance.measure("Check", "beforeCheck", "afterCheck");
        }
        function checkSourceFileWorker(node) {
            var links = getNodeLinks(node);
            if (!(links.flags & 1)) {
                if (compilerOptions.skipLibCheck && node.isDeclarationFile || compilerOptions.skipDefaultLibCheck && node.hasNoDefaultLib) {
                    return;
                }
                checkGrammarSourceFile(node);
                potentialThisCollisions.length = 0;
                potentialNewTargetCollisions.length = 0;
                deferredNodes = [];
                deferredUnusedIdentifierNodes = produceDiagnostics && noUnusedIdentifiers ? [] : undefined;
                ts.forEach(node.statements, checkSourceElement);
                checkDeferredNodes();
                if (ts.isExternalModule(node)) {
                    registerForUnusedIdentifiersCheck(node);
                }
                if (!node.isDeclarationFile) {
                    checkUnusedIdentifiers();
                }
                deferredNodes = undefined;
                deferredUnusedIdentifierNodes = undefined;
                if (ts.isExternalOrCommonJsModule(node)) {
                    checkExternalModuleExports(node);
                }
                if (potentialThisCollisions.length) {
                    ts.forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);
                    potentialThisCollisions.length = 0;
                }
                if (potentialNewTargetCollisions.length) {
                    ts.forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope);
                    potentialNewTargetCollisions.length = 0;
                }
                links.flags |= 1;
            }
        }
        function getDiagnostics(sourceFile, ct) {
            try {
                cancellationToken = ct;
                return getDiagnosticsWorker(sourceFile);
            }
            finally {
                cancellationToken = undefined;
            }
        }
        function getDiagnosticsWorker(sourceFile) {
            throwIfNonDiagnosticsProducing();
            if (sourceFile) {
                var previousGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
                var previousGlobalDiagnosticsSize = previousGlobalDiagnostics.length;
                checkSourceFile(sourceFile);
                var semanticDiagnostics = diagnostics.getDiagnostics(sourceFile.fileName);
                var currentGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
                if (currentGlobalDiagnostics !== previousGlobalDiagnostics) {
                    var deferredGlobalDiagnostics = ts.relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, ts.compareDiagnostics);
                    return ts.concatenate(deferredGlobalDiagnostics, semanticDiagnostics);
                }
                else if (previousGlobalDiagnosticsSize === 0 && currentGlobalDiagnostics.length > 0) {
                    return ts.concatenate(currentGlobalDiagnostics, semanticDiagnostics);
                }
                return semanticDiagnostics;
            }
            ts.forEach(host.getSourceFiles(), checkSourceFile);
            return diagnostics.getDiagnostics();
        }
        function getGlobalDiagnostics() {
            throwIfNonDiagnosticsProducing();
            return diagnostics.getGlobalDiagnostics();
        }
        function throwIfNonDiagnosticsProducing() {
            if (!produceDiagnostics) {
                throw new Error("Trying to get diagnostics from a type checker that does not produce them.");
            }
        }
        function isInsideWithStatementBody(node) {
            if (node) {
                while (node.parent) {
                    if (node.parent.kind === 220 && node.parent.statement === node) {
                        return true;
                    }
                    node = node.parent;
                }
            }
            return false;
        }
        function getSymbolsInScope(location, meaning) {
            if (isInsideWithStatementBody(location)) {
                return [];
            }
            var symbols = ts.createMap();
            var memberFlags = 0;
            populateSymbols();
            return symbolsToArray(symbols);
            function populateSymbols() {
                while (location) {
                    if (location.locals && !isGlobalSourceFile(location)) {
                        copySymbols(location.locals, meaning);
                    }
                    switch (location.kind) {
                        case 265:
                            if (!ts.isExternalOrCommonJsModule(location)) {
                                break;
                            }
                        case 233:
                            copySymbols(getSymbolOfNode(location).exports, meaning & 8914931);
                            break;
                        case 232:
                            copySymbols(getSymbolOfNode(location).exports, meaning & 8);
                            break;
                        case 199:
                            var className = location.name;
                            if (className) {
                                copySymbol(location.symbol, meaning);
                            }
                        case 229:
                        case 230:
                            if (!(memberFlags & 32)) {
                                copySymbols(getSymbolOfNode(location).members, meaning & 793064);
                            }
                            break;
                        case 186:
                            var funcName = location.name;
                            if (funcName) {
                                copySymbol(location.symbol, meaning);
                            }
                            break;
                    }
                    if (ts.introducesArgumentsExoticObject(location)) {
                        copySymbol(argumentsSymbol, meaning);
                    }
                    memberFlags = ts.getModifierFlags(location);
                    location = location.parent;
                }
                copySymbols(globals, meaning);
            }
            function copySymbol(symbol, meaning) {
                if (symbol.flags & meaning) {
                    var id = symbol.name;
                    if (!symbols.has(id)) {
                        symbols.set(id, symbol);
                    }
                }
            }
            function copySymbols(source, meaning) {
                if (meaning) {
                    source.forEach(function (symbol) {
                        copySymbol(symbol, meaning);
                    });
                }
            }
        }
        function isTypeDeclarationName(name) {
            return name.kind === 71 &&
                isTypeDeclaration(name.parent) &&
                name.parent.name === name;
        }
        function isTypeDeclaration(node) {
            switch (node.kind) {
                case 145:
                case 229:
                case 230:
                case 231:
                case 232:
                    return true;
            }
        }
        function isTypeReferenceIdentifier(entityName) {
            var node = entityName;
            while (node.parent && node.parent.kind === 143) {
                node = node.parent;
            }
            return node.parent && (node.parent.kind === 159 || node.parent.kind === 277);
        }
        function isHeritageClauseElementIdentifier(entityName) {
            var node = entityName;
            while (node.parent && node.parent.kind === 179) {
                node = node.parent;
            }
            return node.parent && node.parent.kind === 201;
        }
        function forEachEnclosingClass(node, callback) {
            var result;
            while (true) {
                node = ts.getContainingClass(node);
                if (!node)
                    break;
                if (result = callback(node))
                    break;
            }
            return result;
        }
        function isNodeWithinClass(node, classDeclaration) {
            return !!forEachEnclosingClass(node, function (n) { return n === classDeclaration; });
        }
        function getLeftSideOfImportEqualsOrExportAssignment(nodeOnRightSide) {
            while (nodeOnRightSide.parent.kind === 143) {
                nodeOnRightSide = nodeOnRightSide.parent;
            }
            if (nodeOnRightSide.parent.kind === 237) {
                return nodeOnRightSide.parent.moduleReference === nodeOnRightSide && nodeOnRightSide.parent;
            }
            if (nodeOnRightSide.parent.kind === 243) {
                return nodeOnRightSide.parent.expression === nodeOnRightSide && nodeOnRightSide.parent;
            }
            return undefined;
        }
        function isInRightSideOfImportOrExportAssignment(node) {
            return getLeftSideOfImportEqualsOrExportAssignment(node) !== undefined;
        }
        function getSpecialPropertyAssignmentSymbolFromEntityName(entityName) {
            var specialPropertyAssignmentKind = ts.getSpecialPropertyAssignmentKind(entityName.parent.parent);
            switch (specialPropertyAssignmentKind) {
                case 1:
                case 3:
                    return getSymbolOfNode(entityName.parent);
                case 4:
                case 2:
                case 5:
                    return getSymbolOfNode(entityName.parent.parent);
            }
        }
        function getSymbolOfEntityNameOrPropertyAccessExpression(entityName) {
            if (ts.isDeclarationName(entityName)) {
                return getSymbolOfNode(entityName.parent);
            }
            if (ts.isInJavaScriptFile(entityName) &&
                entityName.parent.kind === 179 &&
                entityName.parent === entityName.parent.parent.left) {
                var specialPropertyAssignmentSymbol = getSpecialPropertyAssignmentSymbolFromEntityName(entityName);
                if (specialPropertyAssignmentSymbol) {
                    return specialPropertyAssignmentSymbol;
                }
            }
            if (entityName.parent.kind === 243 && ts.isEntityNameExpression(entityName)) {
                return resolveEntityName(entityName, 107455 | 793064 | 1920 | 8388608);
            }
            if (entityName.kind !== 179 && isInRightSideOfImportOrExportAssignment(entityName)) {
                var importEqualsDeclaration = ts.getAncestor(entityName, 237);
                ts.Debug.assert(importEqualsDeclaration !== undefined);
                return getSymbolOfPartOfRightHandSideOfImportEquals(entityName, true);
            }
            if (ts.isRightSideOfQualifiedNameOrPropertyAccess(entityName)) {
                entityName = entityName.parent;
            }
            if (isHeritageClauseElementIdentifier(entityName)) {
                var meaning = 0;
                if (entityName.parent.kind === 201) {
                    meaning = 793064;
                    if (ts.isExpressionWithTypeArgumentsInClassExtendsClause(entityName.parent)) {
                        meaning |= 107455;
                    }
                }
                else {
                    meaning = 1920;
                }
                meaning |= 8388608;
                var entityNameSymbol = resolveEntityName(entityName, meaning);
                if (entityNameSymbol) {
                    return entityNameSymbol;
                }
            }
            if (ts.isPartOfExpression(entityName)) {
                if (ts.nodeIsMissing(entityName)) {
                    return undefined;
                }
                if (entityName.kind === 71) {
                    if (ts.isJSXTagName(entityName) && isJsxIntrinsicIdentifier(entityName)) {
                        return getIntrinsicTagSymbol(entityName.parent);
                    }
                    return resolveEntityName(entityName, 107455, false, true);
                }
                else if (entityName.kind === 179) {
                    var symbol = getNodeLinks(entityName).resolvedSymbol;
                    if (!symbol) {
                        checkPropertyAccessExpression(entityName);
                    }
                    return getNodeLinks(entityName).resolvedSymbol;
                }
                else if (entityName.kind === 143) {
                    var symbol = getNodeLinks(entityName).resolvedSymbol;
                    if (!symbol) {
                        checkQualifiedName(entityName);
                    }
                    return getNodeLinks(entityName).resolvedSymbol;
                }
            }
            else if (isTypeReferenceIdentifier(entityName)) {
                var meaning = (entityName.parent.kind === 159 || entityName.parent.kind === 277) ? 793064 : 1920;
                return resolveEntityName(entityName, meaning, false, true);
            }
            else if (entityName.parent.kind === 253) {
                return getJsxAttributePropertySymbol(entityName.parent);
            }
            if (entityName.parent.kind === 158) {
                return resolveEntityName(entityName, 1);
            }
            return undefined;
        }
        function getSymbolAtLocation(node) {
            if (node.kind === 265) {
                return ts.isExternalModule(node) ? getMergedSymbol(node.symbol) : undefined;
            }
            if (isInsideWithStatementBody(node)) {
                return undefined;
            }
            if (ts.isDeclarationName(node)) {
                return getSymbolOfNode(node.parent);
            }
            else if (ts.isLiteralComputedPropertyDeclarationName(node)) {
                return getSymbolOfNode(node.parent.parent);
            }
            if (node.kind === 71) {
                if (isInRightSideOfImportOrExportAssignment(node)) {
                    return getSymbolOfEntityNameOrPropertyAccessExpression(node);
                }
                else if (node.parent.kind === 176 &&
                    node.parent.parent.kind === 174 &&
                    node === node.parent.propertyName) {
                    var typeOfPattern = getTypeOfNode(node.parent.parent);
                    var propertyDeclaration = typeOfPattern && getPropertyOfType(typeOfPattern, node.text);
                    if (propertyDeclaration) {
                        return propertyDeclaration;
                    }
                }
            }
            switch (node.kind) {
                case 71:
                case 179:
                case 143:
                    return getSymbolOfEntityNameOrPropertyAccessExpression(node);
                case 99:
                    var container = ts.getThisContainer(node, false);
                    if (ts.isFunctionLike(container)) {
                        var sig = getSignatureFromDeclaration(container);
                        if (sig.thisParameter) {
                            return sig.thisParameter;
                        }
                    }
                case 97:
                    var type = ts.isPartOfExpression(node) ? getTypeOfExpression(node) : getTypeFromTypeNode(node);
                    return type.symbol;
                case 169:
                    return getTypeFromTypeNode(node).symbol;
                case 123:
                    var constructorDeclaration = node.parent;
                    if (constructorDeclaration && constructorDeclaration.kind === 152) {
                        return constructorDeclaration.parent.symbol;
                    }
                    return undefined;
                case 9:
                    if ((ts.isExternalModuleImportEqualsDeclaration(node.parent.parent) &&
                        ts.getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node) ||
                        ((node.parent.kind === 238 || node.parent.kind === 244) &&
                            node.parent.moduleSpecifier === node)) {
                        return resolveExternalModuleName(node, node);
                    }
                    if (ts.isInJavaScriptFile(node) && ts.isRequireCall(node.parent, false)) {
                        return resolveExternalModuleName(node, node);
                    }
                case 8:
                    if (node.parent.kind === 180 && node.parent.argumentExpression === node) {
                        var objectType = getTypeOfExpression(node.parent.expression);
                        if (objectType === unknownType)
                            return undefined;
                        var apparentType = getApparentType(objectType);
                        if (apparentType === unknownType)
                            return undefined;
                        return getPropertyOfType(apparentType, node.text);
                    }
                    break;
            }
            return undefined;
        }
        function getShorthandAssignmentValueSymbol(location) {
            if (location && location.kind === 262) {
                return resolveEntityName(location.name, 107455 | 8388608);
            }
            return undefined;
        }
        function getExportSpecifierLocalTargetSymbol(node) {
            return node.parent.parent.moduleSpecifier ?
                getExternalModuleMember(node.parent.parent, node) :
                resolveEntityName(node.propertyName || node.name, 107455 | 793064 | 1920 | 8388608);
        }
        function getTypeOfNode(node) {
            if (isInsideWithStatementBody(node)) {
                return unknownType;
            }
            if (ts.isPartOfTypeNode(node)) {
                var typeFromTypeNode = getTypeFromTypeNode(node);
                if (typeFromTypeNode && ts.isExpressionWithTypeArgumentsInClassImplementsClause(node)) {
                    var containingClass = ts.getContainingClass(node);
                    var classType = getTypeOfNode(containingClass);
                    typeFromTypeNode = getTypeWithThisArgument(typeFromTypeNode, classType.thisType);
                }
                return typeFromTypeNode;
            }
            if (ts.isPartOfExpression(node)) {
                return getRegularTypeOfExpression(node);
            }
            if (ts.isExpressionWithTypeArgumentsInClassExtendsClause(node)) {
                var classNode = ts.getContainingClass(node);
                var classType = getDeclaredTypeOfSymbol(getSymbolOfNode(classNode));
                var baseType = getBaseTypes(classType)[0];
                return baseType && getTypeWithThisArgument(baseType, classType.thisType);
            }
            if (isTypeDeclaration(node)) {
                var symbol = getSymbolOfNode(node);
                return getDeclaredTypeOfSymbol(symbol);
            }
            if (isTypeDeclarationName(node)) {
                var symbol = getSymbolAtLocation(node);
                return symbol && getDeclaredTypeOfSymbol(symbol);
            }
            if (ts.isDeclaration(node)) {
                var symbol = getSymbolOfNode(node);
                return getTypeOfSymbol(symbol);
            }
            if (ts.isDeclarationName(node)) {
                var symbol = getSymbolAtLocation(node);
                return symbol && getTypeOfSymbol(symbol);
            }
            if (ts.isBindingPattern(node)) {
                return getTypeForVariableLikeDeclaration(node.parent, true);
            }
            if (isInRightSideOfImportOrExportAssignment(node)) {
                var symbol = getSymbolAtLocation(node);
                var declaredType = symbol && getDeclaredTypeOfSymbol(symbol);
                return declaredType !== unknownType ? declaredType : getTypeOfSymbol(symbol);
            }
            return unknownType;
        }
        function getTypeOfArrayLiteralOrObjectLiteralDestructuringAssignment(expr) {
            ts.Debug.assert(expr.kind === 178 || expr.kind === 177);
            if (expr.parent.kind === 216) {
                var iteratedType = checkRightHandSideOfForOf(expr.parent.expression, expr.parent.awaitModifier);
                return checkDestructuringAssignment(expr, iteratedType || unknownType);
            }
            if (expr.parent.kind === 194) {
                var iteratedType = getTypeOfExpression(expr.parent.right);
                return checkDestructuringAssignment(expr, iteratedType || unknownType);
            }
            if (expr.parent.kind === 261) {
                var typeOfParentObjectLiteral = getTypeOfArrayLiteralOrObjectLiteralDestructuringAssignment(expr.parent.parent);
                return checkObjectLiteralDestructuringPropertyAssignment(typeOfParentObjectLiteral || unknownType, expr.parent);
            }
            ts.Debug.assert(expr.parent.kind === 177);
            var typeOfArrayLiteral = getTypeOfArrayLiteralOrObjectLiteralDestructuringAssignment(expr.parent);
            var elementType = checkIteratedTypeOrElementType(typeOfArrayLiteral || unknownType, expr.parent, false, false) || unknownType;
            return checkArrayLiteralDestructuringElementAssignment(expr.parent, typeOfArrayLiteral, ts.indexOf(expr.parent.elements, expr), elementType || unknownType);
        }
        function getPropertySymbolOfDestructuringAssignment(location) {
            var typeOfObjectLiteral = getTypeOfArrayLiteralOrObjectLiteralDestructuringAssignment(location.parent.parent);
            return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.text);
        }
        function getRegularTypeOfExpression(expr) {
            if (ts.isRightSideOfQualifiedNameOrPropertyAccess(expr)) {
                expr = expr.parent;
            }
            return getRegularTypeOfLiteralType(getTypeOfExpression(expr));
        }
        function getParentTypeOfClassElement(node) {
            var classSymbol = getSymbolOfNode(node.parent);
            return ts.getModifierFlags(node) & 32
                ? getTypeOfSymbol(classSymbol)
                : getDeclaredTypeOfSymbol(classSymbol);
        }
        function getAugmentedPropertiesOfType(type) {
            type = getApparentType(type);
            var propsByName = createSymbolTable(getPropertiesOfType(type));
            if (getSignaturesOfType(type, 0).length || getSignaturesOfType(type, 1).length) {
                ts.forEach(getPropertiesOfType(globalFunctionType), function (p) {
                    if (!propsByName.has(p.name)) {
                        propsByName.set(p.name, p);
                    }
                });
            }
            return getNamedMembers(propsByName);
        }
        function getRootSymbols(symbol) {
            if (getCheckFlags(symbol) & 6) {
                var symbols_3 = [];
                var name_2 = symbol.name;
                ts.forEach(getSymbolLinks(symbol).containingType.types, function (t) {
                    var symbol = getPropertyOfType(t, name_2);
                    if (symbol) {
                        symbols_3.push(symbol);
                    }
                });
                return symbols_3;
            }
            else if (symbol.flags & 134217728) {
                if (symbol.leftSpread) {
                    var links = symbol;
                    return getRootSymbols(links.leftSpread).concat(getRootSymbols(links.rightSpread));
                }
                if (symbol.syntheticOrigin) {
                    return getRootSymbols(symbol.syntheticOrigin);
                }
                var target = void 0;
                var next = symbol;
                while (next = getSymbolLinks(next).target) {
                    target = next;
                }
                if (target) {
                    return [target];
                }
            }
            return [symbol];
        }
        function isArgumentsLocalBinding(node) {
            if (!ts.isGeneratedIdentifier(node)) {
                node = ts.getParseTreeNode(node, ts.isIdentifier);
                if (node) {
                    var isPropertyName_1 = node.parent.kind === 179 && node.parent.name === node;
                    return !isPropertyName_1 && getReferencedValueSymbol(node) === argumentsSymbol;
                }
            }
            return false;
        }
        function moduleExportsSomeValue(moduleReferenceExpression) {
            var moduleSymbol = resolveExternalModuleName(moduleReferenceExpression.parent, moduleReferenceExpression);
            if (!moduleSymbol || ts.isShorthandAmbientModuleSymbol(moduleSymbol)) {
                return true;
            }
            var hasExportAssignment = hasExportAssignmentSymbol(moduleSymbol);
            moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
            var symbolLinks = getSymbolLinks(moduleSymbol);
            if (symbolLinks.exportsSomeValue === undefined) {
                symbolLinks.exportsSomeValue = hasExportAssignment
                    ? !!(moduleSymbol.flags & 107455)
                    : ts.forEachEntry(getExportsOfModule(moduleSymbol), isValue);
            }
            return symbolLinks.exportsSomeValue;
            function isValue(s) {
                s = resolveSymbol(s);
                return s && !!(s.flags & 107455);
            }
        }
        function isNameOfModuleOrEnumDeclaration(node) {
            var parent = node.parent;
            return parent && ts.isModuleOrEnumDeclaration(parent) && node === parent.name;
        }
        function getReferencedExportContainer(node, prefixLocals) {
            node = ts.getParseTreeNode(node, ts.isIdentifier);
            if (node) {
                var symbol = getReferencedValueSymbol(node, isNameOfModuleOrEnumDeclaration(node));
                if (symbol) {
                    if (symbol.flags & 1048576) {
                        var exportSymbol = getMergedSymbol(symbol.exportSymbol);
                        if (!prefixLocals && exportSymbol.flags & 944) {
                            return undefined;
                        }
                        symbol = exportSymbol;
                    }
                    var parentSymbol_1 = getParentOfSymbol(symbol);
                    if (parentSymbol_1) {
                        if (parentSymbol_1.flags & 512 && parentSymbol_1.valueDeclaration.kind === 265) {
                            var symbolFile = parentSymbol_1.valueDeclaration;
                            var referenceFile = ts.getSourceFileOfNode(node);
                            var symbolIsUmdExport = symbolFile !== referenceFile;
                            return symbolIsUmdExport ? undefined : symbolFile;
                        }
                        return ts.findAncestor(node.parent, function (n) { return ts.isModuleOrEnumDeclaration(n) && getSymbolOfNode(n) === parentSymbol_1; });
                    }
                }
            }
        }
        function getReferencedImportDeclaration(node) {
            node = ts.getParseTreeNode(node, ts.isIdentifier);
            if (node) {
                var symbol = getReferencedValueSymbol(node);
                if (symbol && symbol.flags & 8388608) {
                    return getDeclarationOfAliasSymbol(symbol);
                }
            }
            return undefined;
        }
        function isSymbolOfDeclarationWithCollidingName(symbol) {
            if (symbol.flags & 418) {
                var links = getSymbolLinks(symbol);
                if (links.isDeclarationWithCollidingName === undefined) {
                    var container = ts.getEnclosingBlockScopeContainer(symbol.valueDeclaration);
                    if (ts.isStatementWithLocals(container)) {
                        var nodeLinks_1 = getNodeLinks(symbol.valueDeclaration);
                        if (!!resolveName(container.parent, symbol.name, 107455, undefined, undefined)) {
                            links.isDeclarationWithCollidingName = true;
                        }
                        else if (nodeLinks_1.flags & 131072) {
                            var isDeclaredInLoop = nodeLinks_1.flags & 262144;
                            var inLoopInitializer = ts.isIterationStatement(container, false);
                            var inLoopBodyBlock = container.kind === 207 && ts.isIterationStatement(container.parent, false);
                            links.isDeclarationWithCollidingName = !ts.isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock));
                        }
                        else {
                            links.isDeclarationWithCollidingName = false;
                        }
                    }
                }
                return links.isDeclarationWithCollidingName;
            }
            return false;
        }
        function getReferencedDeclarationWithCollidingName(node) {
            if (!ts.isGeneratedIdentifier(node)) {
                node = ts.getParseTreeNode(node, ts.isIdentifier);
                if (node) {
                    var symbol = getReferencedValueSymbol(node);
                    if (symbol && isSymbolOfDeclarationWithCollidingName(symbol)) {
                        return symbol.valueDeclaration;
                    }
                }
            }
            return undefined;
        }
        function isDeclarationWithCollidingName(node) {
            node = ts.getParseTreeNode(node, ts.isDeclaration);
            if (node) {
                var symbol = getSymbolOfNode(node);
                if (symbol) {
                    return isSymbolOfDeclarationWithCollidingName(symbol);
                }
            }
            return false;
        }
        function isValueAliasDeclaration(node) {
            switch (node.kind) {
                case 237:
                case 239:
                case 240:
                case 242:
                case 246:
                    return isAliasResolvedToValue(getSymbolOfNode(node) || unknownSymbol);
                case 244:
                    var exportClause = node.exportClause;
                    return exportClause && ts.forEach(exportClause.elements, isValueAliasDeclaration);
                case 243:
                    return node.expression
                        && node.expression.kind === 71
                        ? isAliasResolvedToValue(getSymbolOfNode(node) || unknownSymbol)
                        : true;
            }
            return false;
        }
        function isTopLevelValueImportEqualsWithEntityName(node) {
            node = ts.getParseTreeNode(node, ts.isImportEqualsDeclaration);
            if (node === undefined || node.parent.kind !== 265 || !ts.isInternalModuleImportEqualsDeclaration(node)) {
                return false;
            }
            var isValue = isAliasResolvedToValue(getSymbolOfNode(node));
            return isValue && node.moduleReference && !ts.nodeIsMissing(node.moduleReference);
        }
        function isAliasResolvedToValue(symbol) {
            var target = resolveAlias(symbol);
            if (target === unknownSymbol) {
                return true;
            }
            return target.flags & 107455 &&
                (compilerOptions.preserveConstEnums || !isConstEnumOrConstEnumOnlyModule(target));
        }
        function isConstEnumOrConstEnumOnlyModule(s) {
            return isConstEnumSymbol(s) || s.constEnumOnlyModule;
        }
        function isReferencedAliasDeclaration(node, checkChildren) {
            if (ts.isAliasSymbolDeclaration(node)) {
                var symbol = getSymbolOfNode(node);
                if (symbol && getSymbolLinks(symbol).referenced) {
                    return true;
                }
            }
            if (checkChildren) {
                return ts.forEachChild(node, function (node) { return isReferencedAliasDeclaration(node, checkChildren); });
            }
            return false;
        }
        function isImplementationOfOverload(node) {
            if (ts.nodeIsPresent(node.body)) {
                var symbol = getSymbolOfNode(node);
                var signaturesOfSymbol = getSignaturesOfSymbol(symbol);
                return signaturesOfSymbol.length > 1 ||
                    (signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node);
            }
            return false;
        }
        function isRequiredInitializedParameter(parameter) {
            return strictNullChecks &&
                !isOptionalParameter(parameter) &&
                parameter.initializer &&
                !(ts.getModifierFlags(parameter) & 92);
        }
        function getNodeCheckFlags(node) {
            return getNodeLinks(node).flags;
        }
        function getEnumMemberValue(node) {
            computeEnumMemberValues(node.parent);
            return getNodeLinks(node).enumMemberValue;
        }
        function canHaveConstantValue(node) {
            switch (node.kind) {
                case 264:
                case 179:
                case 180:
                    return true;
            }
            return false;
        }
        function getConstantValue(node) {
            if (node.kind === 264) {
                return getEnumMemberValue(node);
            }
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol && (symbol.flags & 8)) {
                if (ts.isConstEnumDeclaration(symbol.valueDeclaration.parent)) {
                    return getEnumMemberValue(symbol.valueDeclaration);
                }
            }
            return undefined;
        }
        function isFunctionType(type) {
            return type.flags & 32768 && getSignaturesOfType(type, 0).length > 0;
        }
        function getTypeReferenceSerializationKind(typeName, location) {
            var valueSymbol = resolveEntityName(typeName, 107455, true, false, location);
            var typeSymbol = resolveEntityName(typeName, 793064, true, false, location);
            if (valueSymbol && valueSymbol === typeSymbol) {
                var globalPromiseSymbol = getGlobalPromiseConstructorSymbol(false);
                if (globalPromiseSymbol && valueSymbol === globalPromiseSymbol) {
                    return ts.TypeReferenceSerializationKind.Promise;
                }
                var constructorType = getTypeOfSymbol(valueSymbol);
                if (constructorType && isConstructorType(constructorType)) {
                    return ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue;
                }
            }
            if (!typeSymbol) {
                return ts.TypeReferenceSerializationKind.ObjectType;
            }
            var type = getDeclaredTypeOfSymbol(typeSymbol);
            if (type === unknownType) {
                return ts.TypeReferenceSerializationKind.Unknown;
            }
            else if (type.flags & 1) {
                return ts.TypeReferenceSerializationKind.ObjectType;
            }
            else if (isTypeOfKind(type, 1024 | 6144 | 8192)) {
                return ts.TypeReferenceSerializationKind.VoidNullableOrNeverType;
            }
            else if (isTypeOfKind(type, 136)) {
                return ts.TypeReferenceSerializationKind.BooleanType;
            }
            else if (isTypeOfKind(type, 340)) {
                return ts.TypeReferenceSerializationKind.NumberLikeType;
            }
            else if (isTypeOfKind(type, 262178)) {
                return ts.TypeReferenceSerializationKind.StringLikeType;
            }
            else if (isTupleType(type)) {
                return ts.TypeReferenceSerializationKind.ArrayLikeType;
            }
            else if (isTypeOfKind(type, 512)) {
                return ts.TypeReferenceSerializationKind.ESSymbolType;
            }
            else if (isFunctionType(type)) {
                return ts.TypeReferenceSerializationKind.TypeWithCallSignature;
            }
            else if (isArrayType(type)) {
                return ts.TypeReferenceSerializationKind.ArrayLikeType;
            }
            else {
                return ts.TypeReferenceSerializationKind.ObjectType;
            }
        }
        function writeTypeOfDeclaration(declaration, enclosingDeclaration, flags, writer) {
            var symbol = getSymbolOfNode(declaration);
            var type = symbol && !(symbol.flags & (2048 | 131072))
                ? getWidenedLiteralType(getTypeOfSymbol(symbol))
                : unknownType;
            if (flags & 4096) {
                type = includeFalsyTypes(type, 2048);
            }
            getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);
        }
        function writeReturnTypeOfSignatureDeclaration(signatureDeclaration, enclosingDeclaration, flags, writer) {
            var signature = getSignatureFromDeclaration(signatureDeclaration);
            getSymbolDisplayBuilder().buildTypeDisplay(getReturnTypeOfSignature(signature), writer, enclosingDeclaration, flags);
        }
        function writeTypeOfExpression(expr, enclosingDeclaration, flags, writer) {
            var type = getWidenedType(getRegularTypeOfExpression(expr));
            getSymbolDisplayBuilder().buildTypeDisplay(type, writer, enclosingDeclaration, flags);
        }
        function hasGlobalName(name) {
            return globals.has(name);
        }
        function getReferencedValueSymbol(reference, startInDeclarationContainer) {
            var resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
            if (resolvedSymbol) {
                return resolvedSymbol;
            }
            var location = reference;
            if (startInDeclarationContainer) {
                var parent = reference.parent;
                if (ts.isDeclaration(parent) && reference === parent.name) {
                    location = getDeclarationContainer(parent);
                }
            }
            return resolveName(location, reference.text, 107455 | 1048576 | 8388608, undefined, undefined);
        }
        function getReferencedValueDeclaration(reference) {
            if (!ts.isGeneratedIdentifier(reference)) {
                reference = ts.getParseTreeNode(reference, ts.isIdentifier);
                if (reference) {
                    var symbol = getReferencedValueSymbol(reference);
                    if (symbol) {
                        return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration;
                    }
                }
            }
            return undefined;
        }
        function isLiteralConstDeclaration(node) {
            if (ts.isConst(node)) {
                var type = getTypeOfSymbol(getSymbolOfNode(node));
                return !!(type.flags & 96 && type.flags & 1048576);
            }
            return false;
        }
        function writeLiteralConstValue(node, writer) {
            var type = getTypeOfSymbol(getSymbolOfNode(node));
            writer.writeStringLiteral(literalTypeToString(type));
        }
        function createResolver() {
            var resolvedTypeReferenceDirectives = host.getResolvedTypeReferenceDirectives();
            var fileToDirective;
            if (resolvedTypeReferenceDirectives) {
                fileToDirective = ts.createFileMap();
                resolvedTypeReferenceDirectives.forEach(function (resolvedDirective, key) {
                    if (!resolvedDirective) {
                        return;
                    }
                    var file = host.getSourceFile(resolvedDirective.resolvedFileName);
                    fileToDirective.set(file.path, key);
                });
            }
            return {
                getReferencedExportContainer: getReferencedExportContainer,
                getReferencedImportDeclaration: getReferencedImportDeclaration,
                getReferencedDeclarationWithCollidingName: getReferencedDeclarationWithCollidingName,
                isDeclarationWithCollidingName: isDeclarationWithCollidingName,
                isValueAliasDeclaration: function (node) {
                    node = ts.getParseTreeNode(node);
                    return node ? isValueAliasDeclaration(node) : true;
                },
                hasGlobalName: hasGlobalName,
                isReferencedAliasDeclaration: function (node, checkChildren) {
                    node = ts.getParseTreeNode(node);
                    return node ? isReferencedAliasDeclaration(node, checkChildren) : true;
                },
                getNodeCheckFlags: function (node) {
                    node = ts.getParseTreeNode(node);
                    return node ? getNodeCheckFlags(node) : undefined;
                },
                isTopLevelValueImportEqualsWithEntityName: isTopLevelValueImportEqualsWithEntityName,
                isDeclarationVisible: isDeclarationVisible,
                isImplementationOfOverload: isImplementationOfOverload,
                isRequiredInitializedParameter: isRequiredInitializedParameter,
                writeTypeOfDeclaration: writeTypeOfDeclaration,
                writeReturnTypeOfSignatureDeclaration: writeReturnTypeOfSignatureDeclaration,
                writeTypeOfExpression: writeTypeOfExpression,
                isSymbolAccessible: isSymbolAccessible,
                isEntityNameVisible: isEntityNameVisible,
                getConstantValue: function (node) {
                    node = ts.getParseTreeNode(node, canHaveConstantValue);
                    return node ? getConstantValue(node) : undefined;
                },
                collectLinkedAliases: collectLinkedAliases,
                getReferencedValueDeclaration: getReferencedValueDeclaration,
                getTypeReferenceSerializationKind: getTypeReferenceSerializationKind,
                isOptionalParameter: isOptionalParameter,
                moduleExportsSomeValue: moduleExportsSomeValue,
                isArgumentsLocalBinding: isArgumentsLocalBinding,
                getExternalModuleFileFromDeclaration: getExternalModuleFileFromDeclaration,
                getTypeReferenceDirectivesForEntityName: getTypeReferenceDirectivesForEntityName,
                getTypeReferenceDirectivesForSymbol: getTypeReferenceDirectivesForSymbol,
                isLiteralConstDeclaration: isLiteralConstDeclaration,
                writeLiteralConstValue: writeLiteralConstValue,
                getJsxFactoryEntity: function () { return _jsxFactoryEntity; }
            };
            function getTypeReferenceDirectivesForEntityName(node) {
                if (!fileToDirective) {
                    return undefined;
                }
                var meaning = (node.kind === 179) || (node.kind === 71 && isInTypeQuery(node))
                    ? 107455 | 1048576
                    : 793064 | 1920;
                var symbol = resolveEntityName(node, meaning, true);
                return symbol && symbol !== unknownSymbol ? getTypeReferenceDirectivesForSymbol(symbol, meaning) : undefined;
            }
            function getTypeReferenceDirectivesForSymbol(symbol, meaning) {
                if (!fileToDirective) {
                    return undefined;
                }
                if (!isSymbolFromTypeDeclarationFile(symbol)) {
                    return undefined;
                }
                var typeReferenceDirectives;
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    if (decl.symbol && decl.symbol.flags & meaning) {
                        var file = ts.getSourceFileOfNode(decl);
                        var typeReferenceDirective = fileToDirective.get(file.path);
                        if (typeReferenceDirective) {
                            (typeReferenceDirectives || (typeReferenceDirectives = [])).push(typeReferenceDirective);
                        }
                        else {
                            return undefined;
                        }
                    }
                }
                return typeReferenceDirectives;
            }
            function isSymbolFromTypeDeclarationFile(symbol) {
                if (!symbol.declarations) {
                    return false;
                }
                var current = symbol;
                while (true) {
                    var parent = getParentOfSymbol(current);
                    if (parent) {
                        current = parent;
                    }
                    else {
                        break;
                    }
                }
                if (current.valueDeclaration && current.valueDeclaration.kind === 265 && current.flags & 512) {
                    return false;
                }
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    var file = ts.getSourceFileOfNode(decl);
                    if (fileToDirective.contains(file.path)) {
                        return true;
                    }
                }
                return false;
            }
        }
        function getExternalModuleFileFromDeclaration(declaration) {
            var specifier = ts.getExternalModuleName(declaration);
            var moduleSymbol = resolveExternalModuleNameWorker(specifier, specifier, undefined);
            if (!moduleSymbol) {
                return undefined;
            }
            return ts.getDeclarationOfKind(moduleSymbol, 265);
        }
        function initializeTypeChecker() {
            for (var _i = 0, _a = host.getSourceFiles(); _i < _a.length; _i++) {
                var file = _a[_i];
                ts.bindSourceFile(file, compilerOptions);
            }
            var augmentations;
            for (var _b = 0, _c = host.getSourceFiles(); _b < _c.length; _b++) {
                var file = _c[_b];
                if (!ts.isExternalOrCommonJsModule(file)) {
                    mergeSymbolTable(globals, file.locals);
                }
                if (file.patternAmbientModules && file.patternAmbientModules.length) {
                    patternAmbientModules = ts.concatenate(patternAmbientModules, file.patternAmbientModules);
                }
                if (file.moduleAugmentations.length) {
                    (augmentations || (augmentations = [])).push(file.moduleAugmentations);
                }
                if (file.symbol && file.symbol.globalExports) {
                    var source = file.symbol.globalExports;
                    source.forEach(function (sourceSymbol, id) {
                        if (!globals.has(id)) {
                            globals.set(id, sourceSymbol);
                        }
                    });
                }
            }
            if (augmentations) {
                for (var _d = 0, augmentations_1 = augmentations; _d < augmentations_1.length; _d++) {
                    var list = augmentations_1[_d];
                    for (var _e = 0, list_1 = list; _e < list_1.length; _e++) {
                        var augmentation = list_1[_e];
                        mergeModuleAugmentation(augmentation);
                    }
                }
            }
            addToSymbolTable(globals, builtinGlobals, ts.Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0);
            getSymbolLinks(undefinedSymbol).type = undefinedWideningType;
            getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments", 0, true);
            getSymbolLinks(unknownSymbol).type = unknownType;
            globalArrayType = getGlobalType("Array", 1, true);
            globalObjectType = getGlobalType("Object", 0, true);
            globalFunctionType = getGlobalType("Function", 0, true);
            globalStringType = getGlobalType("String", 0, true);
            globalNumberType = getGlobalType("Number", 0, true);
            globalBooleanType = getGlobalType("Boolean", 0, true);
            globalRegExpType = getGlobalType("RegExp", 0, true);
            anyArrayType = createArrayType(anyType);
            autoArrayType = createArrayType(autoType);
            globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray", 1);
            anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType;
            globalThisType = getGlobalTypeOrUndefined("ThisType", 1);
        }
        function checkExternalEmitHelpers(location, helpers) {
            if ((requestedExternalEmitHelpers & helpers) !== helpers && compilerOptions.importHelpers) {
                var sourceFile = ts.getSourceFileOfNode(location);
                if (ts.isEffectiveExternalModule(sourceFile, compilerOptions) && !ts.isInAmbientContext(location)) {
                    var helpersModule = resolveHelpersModule(sourceFile, location);
                    if (helpersModule !== unknownSymbol) {
                        var uncheckedHelpers = helpers & ~requestedExternalEmitHelpers;
                        for (var helper = 1; helper <= 16384; helper <<= 1) {
                            if (uncheckedHelpers & helper) {
                                var name = getHelperName(helper);
                                var symbol = getSymbol(helpersModule.exports, ts.escapeIdentifier(name), 107455);
                                if (!symbol) {
                                    error(location, ts.Diagnostics.This_syntax_requires_an_imported_helper_named_1_but_module_0_has_no_exported_member_1, ts.externalHelpersModuleNameText, name);
                                }
                            }
                        }
                    }
                    requestedExternalEmitHelpers |= helpers;
                }
            }
        }
        function getHelperName(helper) {
            switch (helper) {
                case 1: return "__extends";
                case 2: return "__assign";
                case 4: return "__rest";
                case 8: return "__decorate";
                case 16: return "__metadata";
                case 32: return "__param";
                case 64: return "__awaiter";
                case 128: return "__generator";
                case 256: return "__values";
                case 512: return "__read";
                case 1024: return "__spread";
                case 2048: return "__await";
                case 4096: return "__asyncGenerator";
                case 8192: return "__asyncDelegator";
                case 16384: return "__asyncValues";
                default: ts.Debug.fail("Unrecognized helper.");
            }
        }
        function resolveHelpersModule(node, errorNode) {
            if (!externalHelpersModule) {
                externalHelpersModule = resolveExternalModule(node, ts.externalHelpersModuleNameText, ts.Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol;
            }
            return externalHelpersModule;
        }
        function checkGrammarDecorators(node) {
            if (!node.decorators) {
                return false;
            }
            if (!ts.nodeCanBeDecorated(node)) {
                if (node.kind === 151 && !ts.nodeIsPresent(node.body)) {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload);
                }
                else {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.Decorators_are_not_valid_here);
                }
            }
            else if (node.kind === 153 || node.kind === 154) {
                var accessors = ts.getAllAccessorDeclarations(node.parent.members, node);
                if (accessors.firstAccessor.decorators && node === accessors.secondAccessor) {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name);
                }
            }
            return false;
        }
        function checkGrammarModifiers(node) {
            var quickResult = reportObviousModifierErrors(node);
            if (quickResult !== undefined) {
                return quickResult;
            }
            var lastStatic, lastPrivate, lastProtected, lastDeclare, lastAsync, lastReadonly;
            var flags = 0;
            for (var _i = 0, _a = node.modifiers; _i < _a.length; _i++) {
                var modifier = _a[_i];
                if (modifier.kind !== 131) {
                    if (node.kind === 148 || node.kind === 150) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_type_member, ts.tokenToString(modifier.kind));
                    }
                    if (node.kind === 157) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_an_index_signature, ts.tokenToString(modifier.kind));
                    }
                }
                switch (modifier.kind) {
                    case 76:
                        if (node.kind !== 232 && node.parent.kind === 229) {
                            return grammarErrorOnNode(node, ts.Diagnostics.A_class_member_cannot_have_the_0_keyword, ts.tokenToString(76));
                        }
                        break;
                    case 114:
                    case 113:
                    case 112:
                        var text = visibilityToString(ts.modifierToFlag(modifier.kind));
                        if (modifier.kind === 113) {
                            lastProtected = modifier;
                        }
                        else if (modifier.kind === 112) {
                            lastPrivate = modifier;
                        }
                        if (flags & 28) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 32) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "static");
                        }
                        else if (flags & 64) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly");
                        }
                        else if (flags & 256) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "async");
                        }
                        else if (node.parent.kind === 234 || node.parent.kind === 265) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text);
                        }
                        else if (flags & 128) {
                            if (modifier.kind === 112) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract");
                            }
                            else {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract");
                            }
                        }
                        flags |= ts.modifierToFlag(modifier.kind);
                        break;
                    case 115:
                        if (flags & 32) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "static");
                        }
                        else if (flags & 64) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly");
                        }
                        else if (flags & 256) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "async");
                        }
                        else if (node.parent.kind === 234 || node.parent.kind === 265) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static");
                        }
                        else if (node.kind === 146) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");
                        }
                        else if (flags & 128) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                        }
                        flags |= 32;
                        lastStatic = modifier;
                        break;
                    case 131:
                        if (flags & 64) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "readonly");
                        }
                        else if (node.kind !== 149 && node.kind !== 148 && node.kind !== 157 && node.kind !== 146) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature);
                        }
                        flags |= 64;
                        lastReadonly = modifier;
                        break;
                    case 84:
                        if (flags & 1) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "export");
                        }
                        else if (flags & 2) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");
                        }
                        else if (flags & 128) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract");
                        }
                        else if (flags & 256) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "async");
                        }
                        else if (node.parent.kind === 229) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, "export");
                        }
                        else if (node.kind === 146) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");
                        }
                        flags |= 1;
                        break;
                    case 124:
                        if (flags & 2) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "declare");
                        }
                        else if (flags & 256) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                        }
                        else if (node.parent.kind === 229) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_class_element, "declare");
                        }
                        else if (node.kind === 146) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");
                        }
                        else if (ts.isInAmbientContext(node.parent) && node.parent.kind === 234) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                        }
                        flags |= 2;
                        lastDeclare = modifier;
                        break;
                    case 117:
                        if (flags & 128) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "abstract");
                        }
                        if (node.kind !== 229) {
                            if (node.kind !== 151 &&
                                node.kind !== 149 &&
                                node.kind !== 153 &&
                                node.kind !== 154) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration);
                            }
                            if (!(node.parent.kind === 229 && ts.getModifierFlags(node.parent) & 128)) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class);
                            }
                            if (flags & 32) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                            }
                            if (flags & 8) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract");
                            }
                        }
                        flags |= 128;
                        break;
                    case 120:
                        if (flags & 256) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "async");
                        }
                        else if (flags & 2 || ts.isInAmbientContext(node.parent)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                        }
                        else if (node.kind === 146) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async");
                        }
                        flags |= 256;
                        lastAsync = modifier;
                        break;
                }
            }
            if (node.kind === 152) {
                if (flags & 32) {
                    return grammarErrorOnNode(lastStatic, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static");
                }
                if (flags & 128) {
                    return grammarErrorOnNode(lastStatic, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "abstract");
                }
                else if (flags & 256) {
                    return grammarErrorOnNode(lastAsync, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async");
                }
                else if (flags & 64) {
                    return grammarErrorOnNode(lastReadonly, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "readonly");
                }
                return;
            }
            else if ((node.kind === 238 || node.kind === 237) && flags & 2) {
                return grammarErrorOnNode(lastDeclare, ts.Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare");
            }
            else if (node.kind === 146 && (flags & 92) && ts.isBindingPattern(node.name)) {
                return grammarErrorOnNode(node, ts.Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern);
            }
            else if (node.kind === 146 && (flags & 92) && node.dotDotDotToken) {
                return grammarErrorOnNode(node, ts.Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter);
            }
            if (flags & 256) {
                return checkGrammarAsyncModifier(node, lastAsync);
            }
        }
        function reportObviousModifierErrors(node) {
            return !node.modifiers
                ? false
                : shouldReportBadModifier(node)
                    ? grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_cannot_appear_here)
                    : undefined;
        }
        function shouldReportBadModifier(node) {
            switch (node.kind) {
                case 153:
                case 154:
                case 152:
                case 149:
                case 148:
                case 151:
                case 150:
                case 157:
                case 233:
                case 238:
                case 237:
                case 244:
                case 243:
                case 186:
                case 187:
                case 146:
                    return false;
                default:
                    if (node.parent.kind === 234 || node.parent.kind === 265) {
                        return false;
                    }
                    switch (node.kind) {
                        case 228:
                            return nodeHasAnyModifiersExcept(node, 120);
                        case 229:
                            return nodeHasAnyModifiersExcept(node, 117);
                        case 230:
                        case 208:
                        case 231:
                            return true;
                        case 232:
                            return nodeHasAnyModifiersExcept(node, 76);
                        default:
                            ts.Debug.fail();
                            return false;
                    }
            }
        }
        function nodeHasAnyModifiersExcept(node, allowedModifier) {
            return node.modifiers.length > 1 || node.modifiers[0].kind !== allowedModifier;
        }
        function checkGrammarAsyncModifier(node, asyncModifier) {
            switch (node.kind) {
                case 151:
                case 228:
                case 186:
                case 187:
                    return false;
            }
            return grammarErrorOnNode(asyncModifier, ts.Diagnostics._0_modifier_cannot_be_used_here, "async");
        }
        function checkGrammarForDisallowedTrailingComma(list) {
            if (list && list.hasTrailingComma) {
                var start = list.end - ",".length;
                var end = list.end;
                var sourceFile = ts.getSourceFileOfNode(list[0]);
                return grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.Trailing_comma_not_allowed);
            }
        }
        function checkGrammarTypeParameterList(typeParameters, file) {
            if (checkGrammarForDisallowedTrailingComma(typeParameters)) {
                return true;
            }
            if (typeParameters && typeParameters.length === 0) {
                var start = typeParameters.pos - "<".length;
                var end = ts.skipTrivia(file.text, typeParameters.end) + ">".length;
                return grammarErrorAtPos(file, start, end - start, ts.Diagnostics.Type_parameter_list_cannot_be_empty);
            }
        }
        function checkGrammarParameterList(parameters) {
            var seenOptionalParameter = false;
            var parameterCount = parameters.length;
            for (var i = 0; i < parameterCount; i++) {
                var parameter = parameters[i];
                if (parameter.dotDotDotToken) {
                    if (i !== (parameterCount - 1)) {
                        return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                    }
                    if (ts.isBindingPattern(parameter.name)) {
                        return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_element_cannot_contain_a_binding_pattern);
                    }
                    if (parameter.questionToken) {
                        return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.A_rest_parameter_cannot_be_optional);
                    }
                    if (parameter.initializer) {
                        return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_have_an_initializer);
                    }
                }
                else if (parameter.questionToken) {
                    seenOptionalParameter = true;
                    if (parameter.initializer) {
                        return grammarErrorOnNode(parameter.name, ts.Diagnostics.Parameter_cannot_have_question_mark_and_initializer);
                    }
                }
                else if (seenOptionalParameter && !parameter.initializer) {
                    return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);
                }
            }
        }
        function checkGrammarFunctionLikeDeclaration(node) {
            var file = ts.getSourceFileOfNode(node);
            return checkGrammarDecorators(node) || checkGrammarModifiers(node) || checkGrammarTypeParameterList(node.typeParameters, file) ||
                checkGrammarParameterList(node.parameters) || checkGrammarArrowFunction(node, file);
        }
        function checkGrammarClassLikeDeclaration(node) {
            var file = ts.getSourceFileOfNode(node);
            return checkGrammarClassDeclarationHeritageClauses(node) || checkGrammarTypeParameterList(node.typeParameters, file);
        }
        function checkGrammarArrowFunction(node, file) {
            if (node.kind === 187) {
                var arrowFunction = node;
                var startLine = ts.getLineAndCharacterOfPosition(file, arrowFunction.equalsGreaterThanToken.pos).line;
                var endLine = ts.getLineAndCharacterOfPosition(file, arrowFunction.equalsGreaterThanToken.end).line;
                if (startLine !== endLine) {
                    return grammarErrorOnNode(arrowFunction.equalsGreaterThanToken, ts.Diagnostics.Line_terminator_not_permitted_before_arrow);
                }
            }
            return false;
        }
        function checkGrammarIndexSignatureParameters(node) {
            var parameter = node.parameters[0];
            if (node.parameters.length !== 1) {
                if (parameter) {
                    return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter);
                }
                else {
                    return grammarErrorOnNode(node, ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter);
                }
            }
            if (parameter.dotDotDotToken) {
                return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.An_index_signature_cannot_have_a_rest_parameter);
            }
            if (ts.getModifierFlags(parameter) !== 0) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
            }
            if (parameter.questionToken) {
                return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);
            }
            if (parameter.initializer) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);
            }
            if (!parameter.type) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);
            }
            if (parameter.type.kind !== 136 && parameter.type.kind !== 133) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_type_must_be_string_or_number);
            }
            if (!node.type) {
                return grammarErrorOnNode(node, ts.Diagnostics.An_index_signature_must_have_a_type_annotation);
            }
        }
        function checkGrammarIndexSignature(node) {
            return checkGrammarDecorators(node) || checkGrammarModifiers(node) || checkGrammarIndexSignatureParameters(node);
        }
        function checkGrammarForAtLeastOneTypeArgument(node, typeArguments) {
            if (typeArguments && typeArguments.length === 0) {
                var sourceFile = ts.getSourceFileOfNode(node);
                var start = typeArguments.pos - "<".length;
                var end = ts.skipTrivia(sourceFile.text, typeArguments.end) + ">".length;
                return grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.Type_argument_list_cannot_be_empty);
            }
        }
        function checkGrammarTypeArguments(node, typeArguments) {
            return checkGrammarForDisallowedTrailingComma(typeArguments) ||
                checkGrammarForAtLeastOneTypeArgument(node, typeArguments);
        }
        function checkGrammarForOmittedArgument(node, args) {
            if (args) {
                var sourceFile = ts.getSourceFileOfNode(node);
                for (var _i = 0, args_4 = args; _i < args_4.length; _i++) {
                    var arg = args_4[_i];
                    if (arg.kind === 200) {
                        return grammarErrorAtPos(sourceFile, arg.pos, 0, ts.Diagnostics.Argument_expression_expected);
                    }
                }
            }
        }
        function checkGrammarArguments(node, args) {
            return checkGrammarForOmittedArgument(node, args);
        }
        function checkGrammarHeritageClause(node) {
            var types = node.types;
            if (checkGrammarForDisallowedTrailingComma(types)) {
                return true;
            }
            if (types && types.length === 0) {
                var listType = ts.tokenToString(node.token);
                var sourceFile = ts.getSourceFileOfNode(node);
                return grammarErrorAtPos(sourceFile, types.pos, 0, ts.Diagnostics._0_list_cannot_be_empty, listType);
            }
        }
        function checkGrammarClassDeclarationHeritageClauses(node) {
            var seenExtendsClause = false;
            var seenImplementsClause = false;
            if (!checkGrammarDecorators(node) && !checkGrammarModifiers(node) && node.heritageClauses) {
                for (var _i = 0, _a = node.heritageClauses; _i < _a.length; _i++) {
                    var heritageClause = _a[_i];
                    if (heritageClause.token === 85) {
                        if (seenExtendsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_already_seen);
                        }
                        if (seenImplementsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_must_precede_implements_clause);
                        }
                        if (heritageClause.types.length > 1) {
                            return grammarErrorOnFirstToken(heritageClause.types[1], ts.Diagnostics.Classes_can_only_extend_a_single_class);
                        }
                        seenExtendsClause = true;
                    }
                    else {
                        ts.Debug.assert(heritageClause.token === 108);
                        if (seenImplementsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.implements_clause_already_seen);
                        }
                        seenImplementsClause = true;
                    }
                    checkGrammarHeritageClause(heritageClause);
                }
            }
        }
        function checkGrammarInterfaceDeclaration(node) {
            var seenExtendsClause = false;
            if (node.heritageClauses) {
                for (var _i = 0, _a = node.heritageClauses; _i < _a.length; _i++) {
                    var heritageClause = _a[_i];
                    if (heritageClause.token === 85) {
                        if (seenExtendsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_already_seen);
                        }
                        seenExtendsClause = true;
                    }
                    else {
                        ts.Debug.assert(heritageClause.token === 108);
                        return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.Interface_declaration_cannot_have_implements_clause);
                    }
                    checkGrammarHeritageClause(heritageClause);
                }
            }
            return false;
        }
        function checkGrammarComputedPropertyName(node) {
            if (node.kind !== 144) {
                return false;
            }
            var computedPropertyName = node;
            if (computedPropertyName.expression.kind === 194 && computedPropertyName.expression.operatorToken.kind === 26) {
                return grammarErrorOnNode(computedPropertyName.expression, ts.Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name);
            }
        }
        function checkGrammarForGenerator(node) {
            if (node.asteriskToken) {
                ts.Debug.assert(node.kind === 228 ||
                    node.kind === 186 ||
                    node.kind === 151);
                if (ts.isInAmbientContext(node)) {
                    return grammarErrorOnNode(node.asteriskToken, ts.Diagnostics.Generators_are_not_allowed_in_an_ambient_context);
                }
                if (!node.body) {
                    return grammarErrorOnNode(node.asteriskToken, ts.Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator);
                }
            }
        }
        function checkGrammarForInvalidQuestionMark(questionToken, message) {
            if (questionToken) {
                return grammarErrorOnNode(questionToken, message);
            }
        }
        function checkGrammarObjectLiteralExpression(node, inDestructuring) {
            var seen = ts.createMap();
            var Property = 1;
            var GetAccessor = 2;
            var SetAccessor = 4;
            var GetOrSetAccessor = GetAccessor | SetAccessor;
            for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
                var prop = _a[_i];
                if (prop.kind === 263) {
                    continue;
                }
                var name = prop.name;
                if (name.kind === 144) {
                    checkGrammarComputedPropertyName(name);
                }
                if (prop.kind === 262 && !inDestructuring && prop.objectAssignmentInitializer) {
                    return grammarErrorOnNode(prop.equalsToken, ts.Diagnostics.can_only_be_used_in_an_object_literal_property_inside_a_destructuring_assignment);
                }
                if (prop.modifiers) {
                    for (var _b = 0, _c = prop.modifiers; _b < _c.length; _b++) {
                        var mod = _c[_b];
                        if (mod.kind !== 120 || prop.kind !== 151) {
                            grammarErrorOnNode(mod, ts.Diagnostics._0_modifier_cannot_be_used_here, ts.getTextOfNode(mod));
                        }
                    }
                }
                var currentKind = void 0;
                if (prop.kind === 261 || prop.kind === 262) {
                    checkGrammarForInvalidQuestionMark(prop.questionToken, ts.Diagnostics.An_object_member_cannot_be_declared_optional);
                    if (name.kind === 8) {
                        checkGrammarNumericLiteral(name);
                    }
                    currentKind = Property;
                }
                else if (prop.kind === 151) {
                    currentKind = Property;
                }
                else if (prop.kind === 153) {
                    currentKind = GetAccessor;
                }
                else if (prop.kind === 154) {
                    currentKind = SetAccessor;
                }
                else {
                    ts.Debug.fail("Unexpected syntax kind:" + prop.kind);
                }
                var effectiveName = ts.getPropertyNameForPropertyNameNode(name);
                if (effectiveName === undefined) {
                    continue;
                }
                var existingKind = seen.get(effectiveName);
                if (!existingKind) {
                    seen.set(effectiveName, currentKind);
                }
                else {
                    if (currentKind === Property && existingKind === Property) {
                        grammarErrorOnNode(name, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(name));
                    }
                    else if ((currentKind & GetOrSetAccessor) && (existingKind & GetOrSetAccessor)) {
                        if (existingKind !== GetOrSetAccessor && currentKind !== existingKind) {
                            seen.set(effectiveName, currentKind | existingKind);
                        }
                        else {
                            return grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
                        }
                    }
                    else {
                        return grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
                    }
                }
            }
        }
        function checkGrammarJsxElement(node) {
            var seen = ts.createMap();
            for (var _i = 0, _a = node.attributes.properties; _i < _a.length; _i++) {
                var attr = _a[_i];
                if (attr.kind === 255) {
                    continue;
                }
                var jsxAttr = attr;
                var name = jsxAttr.name;
                if (!seen.get(name.text)) {
                    seen.set(name.text, true);
                }
                else {
                    return grammarErrorOnNode(name, ts.Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name);
                }
                var initializer = jsxAttr.initializer;
                if (initializer && initializer.kind === 256 && !initializer.expression) {
                    return grammarErrorOnNode(jsxAttr.initializer, ts.Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression);
                }
            }
        }
        function checkGrammarForInOrForOfStatement(forInOrOfStatement) {
            if (checkGrammarStatementInAmbientContext(forInOrOfStatement)) {
                return true;
            }
            if (forInOrOfStatement.kind === 216 && forInOrOfStatement.awaitModifier) {
                if ((forInOrOfStatement.flags & 16384) === 0) {
                    return grammarErrorOnNode(forInOrOfStatement.awaitModifier, ts.Diagnostics.A_for_await_of_statement_is_only_allowed_within_an_async_function_or_async_generator);
                }
            }
            if (forInOrOfStatement.initializer.kind === 227) {
                var variableList = forInOrOfStatement.initializer;
                if (!checkGrammarVariableDeclarationList(variableList)) {
                    var declarations = variableList.declarations;
                    if (!declarations.length) {
                        return false;
                    }
                    if (declarations.length > 1) {
                        var diagnostic = forInOrOfStatement.kind === 215
                            ? ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement
                            : ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement;
                        return grammarErrorOnFirstToken(variableList.declarations[1], diagnostic);
                    }
                    var firstDeclaration = declarations[0];
                    if (firstDeclaration.initializer) {
                        var diagnostic = forInOrOfStatement.kind === 215
                            ? ts.Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer
                            : ts.Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer;
                        return grammarErrorOnNode(firstDeclaration.name, diagnostic);
                    }
                    if (firstDeclaration.type) {
                        var diagnostic = forInOrOfStatement.kind === 215
                            ? ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation
                            : ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation;
                        return grammarErrorOnNode(firstDeclaration, diagnostic);
                    }
                }
            }
            return false;
        }
        function checkGrammarAccessor(accessor) {
            var kind = accessor.kind;
            if (languageVersion < 1) {
                return grammarErrorOnNode(accessor.name, ts.Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);
            }
            else if (ts.isInAmbientContext(accessor)) {
                return grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_be_declared_in_an_ambient_context);
            }
            else if (accessor.body === undefined && !(ts.getModifierFlags(accessor) & 128)) {
                return grammarErrorAtPos(ts.getSourceFileOfNode(accessor), accessor.end - 1, ";".length, ts.Diagnostics._0_expected, "{");
            }
            else if (accessor.body && ts.getModifierFlags(accessor) & 128) {
                return grammarErrorOnNode(accessor, ts.Diagnostics.An_abstract_accessor_cannot_have_an_implementation);
            }
            else if (accessor.typeParameters) {
                return grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_have_type_parameters);
            }
            else if (!doesAccessorHaveCorrectParameterCount(accessor)) {
                return grammarErrorOnNode(accessor.name, kind === 153 ?
                    ts.Diagnostics.A_get_accessor_cannot_have_parameters :
                    ts.Diagnostics.A_set_accessor_must_have_exactly_one_parameter);
            }
            else if (kind === 154) {
                if (accessor.type) {
                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);
                }
                else {
                    var parameter = accessor.parameters[0];
                    if (parameter.dotDotDotToken) {
                        return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.A_set_accessor_cannot_have_rest_parameter);
                    }
                    else if (parameter.questionToken) {
                        return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);
                    }
                    else if (parameter.initializer) {
                        return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);
                    }
                }
            }
        }
        function doesAccessorHaveCorrectParameterCount(accessor) {
            return getAccessorThisParameter(accessor) || accessor.parameters.length === (accessor.kind === 153 ? 0 : 1);
        }
        function getAccessorThisParameter(accessor) {
            if (accessor.parameters.length === (accessor.kind === 153 ? 1 : 2)) {
                return ts.getThisParameter(accessor);
            }
        }
        function checkGrammarForNonSymbolComputedProperty(node, message) {
            if (ts.isDynamicName(node)) {
                return grammarErrorOnNode(node, message);
            }
        }
        function checkGrammarMethod(node) {
            if (checkGrammarDisallowedModifiersOnObjectLiteralExpressionMethod(node) ||
                checkGrammarFunctionLikeDeclaration(node) ||
                checkGrammarForGenerator(node)) {
                return true;
            }
            if (node.parent.kind === 178) {
                if (checkGrammarForInvalidQuestionMark(node.questionToken, ts.Diagnostics.An_object_member_cannot_be_declared_optional)) {
                    return true;
                }
                else if (node.body === undefined) {
                    return grammarErrorAtPos(ts.getSourceFileOfNode(node), node.end - 1, ";".length, ts.Diagnostics._0_expected, "{");
                }
            }
            if (ts.isClassLike(node.parent)) {
                if (ts.isInAmbientContext(node)) {
                    return checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_an_ambient_context_must_directly_refer_to_a_built_in_symbol);
                }
                else if (!node.body) {
                    return checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_a_method_overload_must_directly_refer_to_a_built_in_symbol);
                }
            }
            else if (node.parent.kind === 230) {
                return checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_an_interface_must_directly_refer_to_a_built_in_symbol);
            }
            else if (node.parent.kind === 163) {
                return checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_a_type_literal_must_directly_refer_to_a_built_in_symbol);
            }
        }
        function checkGrammarBreakOrContinueStatement(node) {
            var current = node;
            while (current) {
                if (ts.isFunctionLike(current)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);
                }
                switch (current.kind) {
                    case 222:
                        if (node.label && current.label.text === node.label.text) {
                            var isMisplacedContinueLabel = node.kind === 217
                                && !ts.isIterationStatement(current.statement, true);
                            if (isMisplacedContinueLabel) {
                                return grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
                            }
                            return false;
                        }
                        break;
                    case 221:
                        if (node.kind === 218 && !node.label) {
                            return false;
                        }
                        break;
                    default:
                        if (ts.isIterationStatement(current, false) && !node.label) {
                            return false;
                        }
                        break;
                }
                current = current.parent;
            }
            if (node.label) {
                var message = node.kind === 218
                    ? ts.Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement
                    : ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;
                return grammarErrorOnNode(node, message);
            }
            else {
                var message = node.kind === 218
                    ? ts.Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement
                    : ts.Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;
                return grammarErrorOnNode(node, message);
            }
        }
        function checkGrammarBindingElement(node) {
            if (node.dotDotDotToken) {
                var elements = node.parent.elements;
                if (node !== ts.lastOrUndefined(elements)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
                }
                if (node.name.kind === 175 || node.name.kind === 174) {
                    return grammarErrorOnNode(node.name, ts.Diagnostics.A_rest_element_cannot_contain_a_binding_pattern);
                }
                if (node.initializer) {
                    return grammarErrorAtPos(ts.getSourceFileOfNode(node), node.initializer.pos - 1, 1, ts.Diagnostics.A_rest_element_cannot_have_an_initializer);
                }
            }
        }
        function isStringOrNumberLiteralExpression(expr) {
            return expr.kind === 9 || expr.kind === 8 ||
                expr.kind === 192 && expr.operator === 38 &&
                    expr.operand.kind === 8;
        }
        function checkGrammarVariableDeclaration(node) {
            if (node.parent.parent.kind !== 215 && node.parent.parent.kind !== 216) {
                if (ts.isInAmbientContext(node)) {
                    if (node.initializer) {
                        if (ts.isConst(node) && !node.type) {
                            if (!isStringOrNumberLiteralExpression(node.initializer)) {
                                return grammarErrorOnNode(node.initializer, ts.Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal);
                            }
                        }
                        else {
                            var equalsTokenLength = "=".length;
                            return grammarErrorAtPos(ts.getSourceFileOfNode(node), node.initializer.pos - equalsTokenLength, equalsTokenLength, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
                        }
                    }
                    if (node.initializer && !(ts.isConst(node) && isStringOrNumberLiteralExpression(node.initializer))) {
                        var equalsTokenLength = "=".length;
                        return grammarErrorAtPos(ts.getSourceFileOfNode(node), node.initializer.pos - equalsTokenLength, equalsTokenLength, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
                    }
                }
                else if (!node.initializer) {
                    if (ts.isBindingPattern(node.name) && !ts.isBindingPattern(node.parent)) {
                        return grammarErrorOnNode(node, ts.Diagnostics.A_destructuring_declaration_must_have_an_initializer);
                    }
                    if (ts.isConst(node)) {
                        return grammarErrorOnNode(node, ts.Diagnostics.const_declarations_must_be_initialized);
                    }
                }
            }
            if (compilerOptions.module !== ts.ModuleKind.ES2015 && compilerOptions.module !== ts.ModuleKind.System && !compilerOptions.noEmit &&
                !ts.isInAmbientContext(node.parent.parent) && ts.hasModifier(node.parent.parent, 1)) {
                checkESModuleMarker(node.name);
            }
            var checkLetConstNames = (ts.isLet(node) || ts.isConst(node));
            return checkLetConstNames && checkGrammarNameInLetOrConstDeclarations(node.name);
        }
        function checkESModuleMarker(name) {
            if (name.kind === 71) {
                if (ts.unescapeIdentifier(name.text) === "__esModule") {
                    return grammarErrorOnNode(name, ts.Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules);
                }
            }
            else {
                var elements = name.elements;
                for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
                    var element = elements_2[_i];
                    if (!ts.isOmittedExpression(element)) {
                        return checkESModuleMarker(element.name);
                    }
                }
            }
        }
        function checkGrammarNameInLetOrConstDeclarations(name) {
            if (name.kind === 71) {
                if (name.originalKeywordKind === 110) {
                    return grammarErrorOnNode(name, ts.Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations);
                }
            }
            else {
                var elements = name.elements;
                for (var _i = 0, elements_3 = elements; _i < elements_3.length; _i++) {
                    var element = elements_3[_i];
                    if (!ts.isOmittedExpression(element)) {
                        checkGrammarNameInLetOrConstDeclarations(element.name);
                    }
                }
            }
        }
        function checkGrammarVariableDeclarationList(declarationList) {
            var declarations = declarationList.declarations;
            if (checkGrammarForDisallowedTrailingComma(declarationList.declarations)) {
                return true;
            }
            if (!declarationList.declarations.length) {
                return grammarErrorAtPos(ts.getSourceFileOfNode(declarationList), declarations.pos, declarations.end - declarations.pos, ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
            }
        }
        function allowLetAndConstDeclarations(parent) {
            switch (parent.kind) {
                case 211:
                case 212:
                case 213:
                case 220:
                case 214:
                case 215:
                case 216:
                    return false;
                case 222:
                    return allowLetAndConstDeclarations(parent.parent);
            }
            return true;
        }
        function checkGrammarForDisallowedLetOrConstStatement(node) {
            if (!allowLetAndConstDeclarations(node.parent)) {
                if (ts.isLet(node.declarationList)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.let_declarations_can_only_be_declared_inside_a_block);
                }
                else if (ts.isConst(node.declarationList)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.const_declarations_can_only_be_declared_inside_a_block);
                }
            }
        }
        function checkGrammarMetaProperty(node) {
            if (node.keywordToken === 94) {
                if (node.name.text !== "target") {
                    return grammarErrorOnNode(node.name, ts.Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, node.name.text, ts.tokenToString(node.keywordToken), "target");
                }
            }
        }
        function hasParseDiagnostics(sourceFile) {
            return sourceFile.parseDiagnostics.length > 0;
        }
        function grammarErrorOnFirstToken(node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                var span_4 = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                diagnostics.add(ts.createFileDiagnostic(sourceFile, span_4.start, span_4.length, message, arg0, arg1, arg2));
                return true;
            }
        }
        function grammarErrorAtPos(sourceFile, start, length, message, arg0, arg1, arg2) {
            if (!hasParseDiagnostics(sourceFile)) {
                diagnostics.add(ts.createFileDiagnostic(sourceFile, start, length, message, arg0, arg1, arg2));
                return true;
            }
        }
        function grammarErrorOnNode(node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                diagnostics.add(ts.createDiagnosticForNode(node, message, arg0, arg1, arg2));
                return true;
            }
        }
        function checkGrammarConstructorTypeParameters(node) {
            if (node.typeParameters) {
                return grammarErrorAtPos(ts.getSourceFileOfNode(node), node.typeParameters.pos, node.typeParameters.end - node.typeParameters.pos, ts.Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration);
            }
        }
        function checkGrammarConstructorTypeAnnotation(node) {
            if (node.type) {
                return grammarErrorOnNode(node.type, ts.Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration);
            }
        }
        function checkGrammarProperty(node) {
            if (ts.isClassLike(node.parent)) {
                if (checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_directly_refer_to_a_built_in_symbol)) {
                    return true;
                }
            }
            else if (node.parent.kind === 230) {
                if (checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_an_interface_must_directly_refer_to_a_built_in_symbol)) {
                    return true;
                }
                if (node.initializer) {
                    return grammarErrorOnNode(node.initializer, ts.Diagnostics.An_interface_property_cannot_have_an_initializer);
                }
            }
            else if (node.parent.kind === 163) {
                if (checkGrammarForNonSymbolComputedProperty(node.name, ts.Diagnostics.A_computed_property_name_in_a_type_literal_must_directly_refer_to_a_built_in_symbol)) {
                    return true;
                }
                if (node.initializer) {
                    return grammarErrorOnNode(node.initializer, ts.Diagnostics.A_type_literal_property_cannot_have_an_initializer);
                }
            }
            if (ts.isInAmbientContext(node) && node.initializer) {
                return grammarErrorOnFirstToken(node.initializer, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
            }
        }
        function checkGrammarTopLevelElementForRequiredDeclareModifier(node) {
            if (node.kind === 230 ||
                node.kind === 231 ||
                node.kind === 238 ||
                node.kind === 237 ||
                node.kind === 244 ||
                node.kind === 243 ||
                node.kind === 236 ||
                ts.getModifierFlags(node) & (2 | 1 | 512)) {
                return false;
            }
            return grammarErrorOnFirstToken(node, ts.Diagnostics.A_declare_modifier_is_required_for_a_top_level_declaration_in_a_d_ts_file);
        }
        function checkGrammarTopLevelElementsForRequiredDeclareModifier(file) {
            for (var _i = 0, _a = file.statements; _i < _a.length; _i++) {
                var decl = _a[_i];
                if (ts.isDeclaration(decl) || decl.kind === 208) {
                    if (checkGrammarTopLevelElementForRequiredDeclareModifier(decl)) {
                        return true;
                    }
                }
            }
        }
        function checkGrammarSourceFile(node) {
            return ts.isInAmbientContext(node) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node);
        }
        function checkGrammarStatementInAmbientContext(node) {
            if (ts.isInAmbientContext(node)) {
                if (isAccessor(node.parent.kind)) {
                    return getNodeLinks(node).hasReportedStatementInAmbientContext = true;
                }
                var links = getNodeLinks(node);
                if (!links.hasReportedStatementInAmbientContext && ts.isFunctionLike(node.parent)) {
                    return getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, ts.Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts);
                }
                if (node.parent.kind === 207 || node.parent.kind === 234 || node.parent.kind === 265) {
                    var links_1 = getNodeLinks(node.parent);
                    if (!links_1.hasReportedStatementInAmbientContext) {
                        return links_1.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, ts.Diagnostics.Statements_are_not_allowed_in_ambient_contexts);
                    }
                }
                else {
                }
            }
        }
        function checkGrammarNumericLiteral(node) {
            if (node.numericLiteralFlags & 4) {
                var diagnosticMessage = void 0;
                if (languageVersion >= 1) {
                    diagnosticMessage = ts.Diagnostics.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0;
                }
                else if (ts.isChildOfNodeWithKind(node, 173)) {
                    diagnosticMessage = ts.Diagnostics.Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0;
                }
                else if (ts.isChildOfNodeWithKind(node, 264)) {
                    diagnosticMessage = ts.Diagnostics.Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0;
                }
                if (diagnosticMessage) {
                    var withMinus = ts.isPrefixUnaryExpression(node.parent) && node.parent.operator === 38;
                    var literal = (withMinus ? "-" : "") + "0o" + node.text;
                    return grammarErrorOnNode(withMinus ? node.parent : node, diagnosticMessage, literal);
                }
            }
        }
        function grammarErrorAfterFirstToken(node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                var span_5 = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                diagnostics.add(ts.createFileDiagnostic(sourceFile, ts.textSpanEnd(span_5), 0, message, arg0, arg1, arg2));
                return true;
            }
        }
        function getAmbientModules() {
            var result = [];
            globals.forEach(function (global, sym) {
                if (ambientModuleSymbolRegex.test(sym)) {
                    result.push(global);
                }
            });
            return result;
        }
    }
    ts.createTypeChecker = createTypeChecker;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function visitNode(node, visitor, test, lift) {
        if (node === undefined || visitor === undefined) {
            return node;
        }
        ts.aggregateTransformFlags(node);
        var visited = visitor(node);
        if (visited === node) {
            return node;
        }
        var visitedNode;
        if (visited === undefined) {
            return undefined;
        }
        else if (ts.isArray(visited)) {
            visitedNode = (lift || extractSingleNode)(visited);
        }
        else {
            visitedNode = visited;
        }
        ts.Debug.assertNode(visitedNode, test);
        ts.aggregateTransformFlags(visitedNode);
        return visitedNode;
    }
    ts.visitNode = visitNode;
    function visitNodes(nodes, visitor, test, start, count) {
        if (nodes === undefined || visitor === undefined) {
            return nodes;
        }
        var updated;
        var length = nodes.length;
        if (start === undefined || start < 0) {
            start = 0;
        }
        if (count === undefined || count > length - start) {
            count = length - start;
        }
        if (start > 0 || count < length) {
            updated = ts.createNodeArray([], nodes.hasTrailingComma && start + count === length);
        }
        for (var i = 0; i < count; i++) {
            var node = nodes[i + start];
            ts.aggregateTransformFlags(node);
            var visited = node !== undefined ? visitor(node) : undefined;
            if (updated !== undefined || visited === undefined || visited !== node) {
                if (updated === undefined) {
                    updated = ts.createNodeArray(nodes.slice(0, i), nodes.hasTrailingComma);
                    ts.setTextRange(updated, nodes);
                }
                if (visited) {
                    if (ts.isArray(visited)) {
                        for (var _i = 0, visited_1 = visited; _i < visited_1.length; _i++) {
                            var visitedNode = visited_1[_i];
                            ts.Debug.assertNode(visitedNode, test);
                            ts.aggregateTransformFlags(visitedNode);
                            updated.push(visitedNode);
                        }
                    }
                    else {
                        ts.Debug.assertNode(visited, test);
                        ts.aggregateTransformFlags(visited);
                        updated.push(visited);
                    }
                }
            }
        }
        return updated || nodes;
    }
    ts.visitNodes = visitNodes;
    function visitLexicalEnvironment(statements, visitor, context, start, ensureUseStrict) {
        context.startLexicalEnvironment();
        statements = visitNodes(statements, visitor, ts.isStatement, start);
        if (ensureUseStrict && !ts.startsWithUseStrict(statements)) {
            statements = ts.setTextRange(ts.createNodeArray([ts.createStatement(ts.createLiteral("use strict"))].concat(statements)), statements);
        }
        var declarations = context.endLexicalEnvironment();
        return ts.setTextRange(ts.createNodeArray(ts.concatenate(statements, declarations)), statements);
    }
    ts.visitLexicalEnvironment = visitLexicalEnvironment;
    function visitParameterList(nodes, visitor, context, nodesVisitor) {
        if (nodesVisitor === void 0) { nodesVisitor = visitNodes; }
        context.startLexicalEnvironment();
        var updated = nodesVisitor(nodes, visitor, ts.isParameterDeclaration);
        context.suspendLexicalEnvironment();
        return updated;
    }
    ts.visitParameterList = visitParameterList;
    function visitFunctionBody(node, visitor, context) {
        context.resumeLexicalEnvironment();
        var updated = visitNode(node, visitor, ts.isConciseBody);
        var declarations = context.endLexicalEnvironment();
        if (ts.some(declarations)) {
            var block = ts.convertToFunctionBody(updated);
            var statements = ts.mergeLexicalEnvironment(block.statements, declarations);
            return ts.updateBlock(block, statements);
        }
        return updated;
    }
    ts.visitFunctionBody = visitFunctionBody;
    function visitEachChild(node, visitor, context, nodesVisitor, tokenVisitor) {
        if (nodesVisitor === void 0) { nodesVisitor = visitNodes; }
        if (node === undefined) {
            return undefined;
        }
        var kind = node.kind;
        if ((kind > 0 && kind <= 142) || kind === 169) {
            return node;
        }
        switch (node.kind) {
            case 206:
            case 209:
            case 200:
            case 225:
            case 298:
            case 247:
                return node;
            case 143:
                return ts.updateQualifiedName(node, visitNode(node.left, visitor, ts.isEntityName), visitNode(node.right, visitor, ts.isIdentifier));
            case 144:
                return ts.updateComputedPropertyName(node, visitNode(node.expression, visitor, ts.isExpression));
            case 160:
                return ts.updateFunctionTypeNode(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode));
            case 161:
                return ts.updateConstructorTypeNode(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode));
            case 155:
                return ts.updateCallSignatureDeclaration(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode));
            case 156:
                return ts.updateConstructSignatureDeclaration(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode));
            case 150:
                return ts.updateMethodSignature(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode), visitNode(node.name, visitor, ts.isPropertyName), visitNode(node.questionToken, tokenVisitor, ts.isToken));
            case 157:
                return ts.updateIndexSignatureDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode));
            case 146:
                return ts.updateParameter(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.dotDotDotToken, tokenVisitor, ts.isToken), visitNode(node.name, visitor, ts.isBindingName), visitNode(node.questionToken, tokenVisitor, ts.isToken), visitNode(node.type, visitor, ts.isTypeNode), visitNode(node.initializer, visitor, ts.isExpression));
            case 147:
                return ts.updateDecorator(node, visitNode(node.expression, visitor, ts.isExpression));
            case 159:
                return ts.updateTypeReferenceNode(node, visitNode(node.typeName, visitor, ts.isEntityName), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode));
            case 158:
                return ts.updateTypePredicateNode(node, visitNode(node.parameterName, visitor), visitNode(node.type, visitor, ts.isTypeNode));
            case 162:
                return ts.updateTypeQueryNode(node, visitNode(node.exprName, visitor, ts.isEntityName));
            case 163:
                return ts.updateTypeLiteralNode(node, nodesVisitor(node.members, visitor));
            case 164:
                return ts.updateArrayTypeNode(node, visitNode(node.elementType, visitor, ts.isTypeNode));
            case 165:
                return ts.updateTypleTypeNode(node, nodesVisitor(node.elementTypes, visitor, ts.isTypeNode));
            case 166:
            case 167:
                return ts.updateUnionOrIntersectionTypeNode(node, nodesVisitor(node.types, visitor, ts.isTypeNode));
            case 168:
                throw ts.Debug.fail("not implemented.");
            case 170:
                return ts.updateTypeOperatorNode(node, visitNode(node.type, visitor, ts.isTypeNode));
            case 171:
                return ts.updateIndexedAccessTypeNode(node, visitNode(node.objectType, visitor, ts.isTypeNode), visitNode(node.indexType, visitor, ts.isTypeNode));
            case 172:
                return ts.updateMappedTypeNode(node, visitNode(node.readonlyToken, tokenVisitor, ts.isToken), visitNode(node.typeParameter, visitor, ts.isTypeParameter), visitNode(node.questionToken, tokenVisitor, ts.isToken), visitNode(node.type, visitor, ts.isTypeNode));
            case 173:
                return ts.updateLiteralTypeNode(node, visitNode(node.literal, visitor, ts.isExpression));
            case 145:
                return ts.updateTypeParameterDeclaration(node, visitNode(node.name, visitor, ts.isIdentifier), visitNode(node.constraint, visitor, ts.isTypeNode), visitNode(node.default, visitor, ts.isTypeNode));
            case 148:
                return ts.updatePropertySignature(node, visitNode(node.name, visitor, ts.isPropertyName), visitNode(node.questionToken, tokenVisitor, ts.isToken), visitNode(node.type, visitor, ts.isTypeNode), visitNode(node.initializer, visitor, ts.isExpression));
            case 149:
                return ts.updateProperty(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.name, visitor, ts.isPropertyName), visitNode(node.type, visitor, ts.isTypeNode), visitNode(node.initializer, visitor, ts.isExpression));
            case 151:
                return ts.updateMethod(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.asteriskToken, tokenVisitor, ts.isToken), visitNode(node.name, visitor, ts.isPropertyName), visitNode(node.questionToken, tokenVisitor, ts.isToken), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context));
            case 152:
                return ts.updateConstructor(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitFunctionBody(node.body, visitor, context));
            case 153:
                return ts.updateGetAccessor(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.name, visitor, ts.isPropertyName), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context));
            case 154:
                return ts.updateSetAccessor(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.name, visitor, ts.isPropertyName), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitFunctionBody(node.body, visitor, context));
            case 174:
                return ts.updateObjectBindingPattern(node, nodesVisitor(node.elements, visitor, ts.isBindingElement));
            case 175:
                return ts.updateArrayBindingPattern(node, nodesVisitor(node.elements, visitor, ts.isArrayBindingElement));
            case 176:
                return ts.updateBindingElement(node, visitNode(node.dotDotDotToken, tokenVisitor, ts.isToken), visitNode(node.propertyName, visitor, ts.isPropertyName), visitNode(node.name, visitor, ts.isBindingName), visitNode(node.initializer, visitor, ts.isExpression));
            case 177:
                return ts.updateArrayLiteral(node, nodesVisitor(node.elements, visitor, ts.isExpression));
            case 178:
                return ts.updateObjectLiteral(node, nodesVisitor(node.properties, visitor, ts.isObjectLiteralElementLike));
            case 179:
                return ts.updatePropertyAccess(node, visitNode(node.expression, visitor, ts.isExpression), visitNode(node.name, visitor, ts.isIdentifier));
            case 180:
                return ts.updateElementAccess(node, visitNode(node.expression, visitor, ts.isExpression), visitNode(node.argumentExpression, visitor, ts.isExpression));
            case 181:
                return ts.updateCall(node, visitNode(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression));
            case 182:
                return ts.updateNew(node, visitNode(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression));
            case 183:
                return ts.updateTaggedTemplate(node, visitNode(node.tag, visitor, ts.isExpression), visitNode(node.template, visitor, ts.isTemplateLiteral));
            case 184:
                return ts.updateTypeAssertion(node, visitNode(node.type, visitor, ts.isTypeNode), visitNode(node.expression, visitor, ts.isExpression));
            case 185:
                return ts.updateParen(node, visitNode(node.expression, visitor, ts.isExpression));
            case 186:
                return ts.updateFunctionExpression(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.asteriskToken, tokenVisitor, ts.isToken), visitNode(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context));
            case 187:
                return ts.updateArrowFunction(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context));
            case 188:
                return ts.updateDelete(node, visitNode(node.expression, visitor, ts.isExpression));
            case 189:
                return ts.updateTypeOf(node, visitNode(node.expression, visitor, ts.isExpression));
            case 190:
                return ts.updateVoid(node, visitNode(node.expression, visitor, ts.isExpression));
            case 191:
                return ts.updateAwait(node, visitNode(node.expression, visitor, ts.isExpression));
            case 194:
                return ts.updateBinary(node, visitNode(node.left, visitor, ts.isExpression), visitNode(node.right, visitor, ts.isExpression));
            case 192:
                return ts.updatePrefix(node, visitNode(node.operand, visitor, ts.isExpression));
            case 193:
                return ts.updatePostfix(node, visitNode(node.operand, visitor, ts.isExpression));
            case 195:
                return ts.updateConditional(node, visitNode(node.condition, visitor, ts.isExpression), visitNode(node.whenTrue, visitor, ts.isExpression), visitNode(node.whenFalse, visitor, ts.isExpression));
            case 196:
                return ts.updateTemplateExpression(node, visitNode(node.head, visitor, ts.isTemplateHead), nodesVisitor(node.templateSpans, visitor, ts.isTemplateSpan));
            case 197:
                return ts.updateYield(node, visitNode(node.asteriskToken, tokenVisitor, ts.isToken), visitNode(node.expression, visitor, ts.isExpression));
            case 198:
                return ts.updateSpread(node, visitNode(node.expression, visitor, ts.isExpression));
            case 199:
                return ts.updateClassExpression(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isClassElement));
            case 201:
                return ts.updateExpressionWithTypeArguments(node, nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), visitNode(node.expression, visitor, ts.isExpression));
            case 202:
                return ts.updateAsExpression(node, visitNode(node.expression, visitor, ts.isExpression), visitNode(node.type, visitor, ts.isTypeNode));
            case 203:
                return ts.updateNonNullExpression(node, visitNode(node.expression, visitor, ts.isExpression));
            case 205:
                return ts.updateTemplateSpan(node, visitNode(node.expression, visitor, ts.isExpression), visitNode(node.literal, visitor, ts.isTemplateMiddleOrTemplateTail));
            case 207:
                return ts.updateBlock(node, nodesVisitor(node.statements, visitor, ts.isStatement));
            case 208:
                return ts.updateVariableStatement(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.declarationList, visitor, ts.isVariableDeclarationList));
            case 210:
                return ts.updateStatement(node, visitNode(node.expression, visitor, ts.isExpression));
            case 211:
                return ts.updateIf(node, visitNode(node.expression, visitor, ts.isExpression), visitNode(node.thenStatement, visitor, ts.isStatement, ts.liftToBlock), visitNode(node.elseStatement, visitor, ts.isStatement, ts.liftToBlock));
            case 212:
                return ts.updateDo(node, visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock), visitNode(node.expression, visitor, ts.isExpression));
            case 213:
                return ts.updateWhile(node, visitNode(node.expression, visitor, ts.isExpression), visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock));
            case 214:
                return ts.updateFor(node, visitNode(node.initializer, visitor, ts.isForInitializer), visitNode(node.condition, visitor, ts.isExpression), visitNode(node.incrementor, visitor, ts.isExpression), visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock));
            case 215:
                return ts.updateForIn(node, visitNode(node.initializer, visitor, ts.isForInitializer), visitNode(node.expression, visitor, ts.isExpression), visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock));
            case 216:
                return ts.updateForOf(node, node.awaitModifier, visitNode(node.initializer, visitor, ts.isForInitializer), visitNode(node.expression, visitor, ts.isExpression), visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock));
            case 217:
                return ts.updateContinue(node, visitNode(node.label, visitor, ts.isIdentifier));
            case 218:
                return ts.updateBreak(node, visitNode(node.label, visitor, ts.isIdentifier));
            case 219:
                return ts.updateReturn(node, visitNode(node.expression, visitor, ts.isExpression));
            case 220:
                return ts.updateWith(node, visitNode(node.expression, visitor, ts.isExpression), visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock));
            case 221:
                return ts.updateSwitch(node, visitNode(node.expression, visitor, ts.isExpression), visitNode(node.caseBlock, visitor, ts.isCaseBlock));
            case 222:
                return ts.updateLabel(node, visitNode(node.label, visitor, ts.isIdentifier), visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock));
            case 223:
                return ts.updateThrow(node, visitNode(node.expression, visitor, ts.isExpression));
            case 224:
                return ts.updateTry(node, visitNode(node.tryBlock, visitor, ts.isBlock), visitNode(node.catchClause, visitor, ts.isCatchClause), visitNode(node.finallyBlock, visitor, ts.isBlock));
            case 226:
                return ts.updateVariableDeclaration(node, visitNode(node.name, visitor, ts.isBindingName), visitNode(node.type, visitor, ts.isTypeNode), visitNode(node.initializer, visitor, ts.isExpression));
            case 227:
                return ts.updateVariableDeclarationList(node, nodesVisitor(node.declarations, visitor, ts.isVariableDeclaration));
            case 228:
                return ts.updateFunctionDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.asteriskToken, tokenVisitor, ts.isToken), visitNode(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitNode(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context));
            case 229:
                return ts.updateClassDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameter), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isClassElement));
            case 232:
                return ts.updateEnumDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.name, visitor, ts.isIdentifier), nodesVisitor(node.members, visitor, ts.isEnumMember));
            case 233:
                return ts.updateModuleDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.name, visitor, ts.isIdentifier), visitNode(node.body, visitor, ts.isModuleBody));
            case 234:
                return ts.updateModuleBlock(node, nodesVisitor(node.statements, visitor, ts.isStatement));
            case 235:
                return ts.updateCaseBlock(node, nodesVisitor(node.clauses, visitor, ts.isCaseOrDefaultClause));
            case 237:
                return ts.updateImportEqualsDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.name, visitor, ts.isIdentifier), visitNode(node.moduleReference, visitor, ts.isModuleReference));
            case 238:
                return ts.updateImportDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.importClause, visitor, ts.isImportClause), visitNode(node.moduleSpecifier, visitor, ts.isExpression));
            case 239:
                return ts.updateImportClause(node, visitNode(node.name, visitor, ts.isIdentifier), visitNode(node.namedBindings, visitor, ts.isNamedImportBindings));
            case 240:
                return ts.updateNamespaceImport(node, visitNode(node.name, visitor, ts.isIdentifier));
            case 241:
                return ts.updateNamedImports(node, nodesVisitor(node.elements, visitor, ts.isImportSpecifier));
            case 242:
                return ts.updateImportSpecifier(node, visitNode(node.propertyName, visitor, ts.isIdentifier), visitNode(node.name, visitor, ts.isIdentifier));
            case 243:
                return ts.updateExportAssignment(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.expression, visitor, ts.isExpression));
            case 244:
                return ts.updateExportDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitNode(node.exportClause, visitor, ts.isNamedExports), visitNode(node.moduleSpecifier, visitor, ts.isExpression));
            case 245:
                return ts.updateNamedExports(node, nodesVisitor(node.elements, visitor, ts.isExportSpecifier));
            case 246:
                return ts.updateExportSpecifier(node, visitNode(node.propertyName, visitor, ts.isIdentifier), visitNode(node.name, visitor, ts.isIdentifier));
            case 248:
                return ts.updateExternalModuleReference(node, visitNode(node.expression, visitor, ts.isExpression));
            case 249:
                return ts.updateJsxElement(node, visitNode(node.openingElement, visitor, ts.isJsxOpeningElement), nodesVisitor(node.children, visitor, ts.isJsxChild), visitNode(node.closingElement, visitor, ts.isJsxClosingElement));
            case 254:
                return ts.updateJsxAttributes(node, nodesVisitor(node.properties, visitor, ts.isJsxAttributeLike));
            case 250:
                return ts.updateJsxSelfClosingElement(node, visitNode(node.tagName, visitor, ts.isJsxTagNameExpression), visitNode(node.attributes, visitor, ts.isJsxAttributes));
            case 251:
                return ts.updateJsxOpeningElement(node, visitNode(node.tagName, visitor, ts.isJsxTagNameExpression), visitNode(node.attributes, visitor, ts.isJsxAttributes));
            case 252:
                return ts.updateJsxClosingElement(node, visitNode(node.tagName, visitor, ts.isJsxTagNameExpression));
            case 253:
                return ts.updateJsxAttribute(node, visitNode(node.name, visitor, ts.isIdentifier), visitNode(node.initializer, visitor, ts.isStringLiteralOrJsxExpression));
            case 255:
                return ts.updateJsxSpreadAttribute(node, visitNode(node.expression, visitor, ts.isExpression));
            case 256:
                return ts.updateJsxExpression(node, visitNode(node.expression, visitor, ts.isExpression));
            case 257:
                return ts.updateCaseClause(node, visitNode(node.expression, visitor, ts.isExpression), nodesVisitor(node.statements, visitor, ts.isStatement));
            case 258:
                return ts.updateDefaultClause(node, nodesVisitor(node.statements, visitor, ts.isStatement));
            case 259:
                return ts.updateHeritageClause(node, nodesVisitor(node.types, visitor, ts.isExpressionWithTypeArguments));
            case 260:
                return ts.updateCatchClause(node, visitNode(node.variableDeclaration, visitor, ts.isVariableDeclaration), visitNode(node.block, visitor, ts.isBlock));
            case 261:
                return ts.updatePropertyAssignment(node, visitNode(node.name, visitor, ts.isPropertyName), visitNode(node.initializer, visitor, ts.isExpression));
            case 262:
                return ts.updateShorthandPropertyAssignment(node, visitNode(node.name, visitor, ts.isIdentifier), visitNode(node.objectAssignmentInitializer, visitor, ts.isExpression));
            case 263:
                return ts.updateSpreadAssignment(node, visitNode(node.expression, visitor, ts.isExpression));
            case 264:
                return ts.updateEnumMember(node, visitNode(node.name, visitor, ts.isPropertyName), visitNode(node.initializer, visitor, ts.isExpression));
            case 265:
                return ts.updateSourceFileNode(node, visitLexicalEnvironment(node.statements, visitor, context));
            case 296:
                return ts.updatePartiallyEmittedExpression(node, visitNode(node.expression, visitor, ts.isExpression));
            default:
                return node;
        }
    }
    ts.visitEachChild = visitEachChild;
    function extractSingleNode(nodes) {
        ts.Debug.assert(nodes.length <= 1, "Too many nodes written to output.");
        return ts.singleOrUndefined(nodes);
    }
})(ts || (ts = {}));
(function (ts) {
    function reduceNode(node, f, initial) {
        return node ? f(initial, node) : initial;
    }
    function reduceNodeArray(nodes, f, initial) {
        return nodes ? f(initial, nodes) : initial;
    }
    function reduceEachChild(node, initial, cbNode, cbNodeArray) {
        if (node === undefined) {
            return initial;
        }
        var reduceNodes = cbNodeArray ? reduceNodeArray : ts.reduceLeft;
        var cbNodes = cbNodeArray || cbNode;
        var kind = node.kind;
        if ((kind > 0 && kind <= 142)) {
            return initial;
        }
        if ((kind >= 158 && kind <= 173)) {
            return initial;
        }
        var result = initial;
        switch (node.kind) {
            case 206:
            case 209:
            case 200:
            case 225:
            case 295:
                break;
            case 143:
                result = reduceNode(node.left, cbNode, result);
                result = reduceNode(node.right, cbNode, result);
                break;
            case 144:
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 146:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.type, cbNode, result);
                result = reduceNode(node.initializer, cbNode, result);
                break;
            case 147:
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 149:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.type, cbNode, result);
                result = reduceNode(node.initializer, cbNode, result);
                break;
            case 151:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNodes(node.typeParameters, cbNodes, result);
                result = reduceNodes(node.parameters, cbNodes, result);
                result = reduceNode(node.type, cbNode, result);
                result = reduceNode(node.body, cbNode, result);
                break;
            case 152:
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNodes(node.parameters, cbNodes, result);
                result = reduceNode(node.body, cbNode, result);
                break;
            case 153:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNodes(node.parameters, cbNodes, result);
                result = reduceNode(node.type, cbNode, result);
                result = reduceNode(node.body, cbNode, result);
                break;
            case 154:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNodes(node.parameters, cbNodes, result);
                result = reduceNode(node.body, cbNode, result);
                break;
            case 174:
            case 175:
                result = reduceNodes(node.elements, cbNodes, result);
                break;
            case 176:
                result = reduceNode(node.propertyName, cbNode, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.initializer, cbNode, result);
                break;
            case 177:
                result = reduceNodes(node.elements, cbNodes, result);
                break;
            case 178:
                result = reduceNodes(node.properties, cbNodes, result);
                break;
            case 179:
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNode(node.name, cbNode, result);
                break;
            case 180:
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNode(node.argumentExpression, cbNode, result);
                break;
            case 181:
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNodes(node.typeArguments, cbNodes, result);
                result = reduceNodes(node.arguments, cbNodes, result);
                break;
            case 182:
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNodes(node.typeArguments, cbNodes, result);
                result = reduceNodes(node.arguments, cbNodes, result);
                break;
            case 183:
                result = reduceNode(node.tag, cbNode, result);
                result = reduceNode(node.template, cbNode, result);
                break;
            case 184:
                result = reduceNode(node.type, cbNode, result);
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 186:
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNodes(node.typeParameters, cbNodes, result);
                result = reduceNodes(node.parameters, cbNodes, result);
                result = reduceNode(node.type, cbNode, result);
                result = reduceNode(node.body, cbNode, result);
                break;
            case 187:
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNodes(node.typeParameters, cbNodes, result);
                result = reduceNodes(node.parameters, cbNodes, result);
                result = reduceNode(node.type, cbNode, result);
                result = reduceNode(node.body, cbNode, result);
                break;
            case 185:
            case 188:
            case 189:
            case 190:
            case 191:
            case 197:
            case 198:
            case 203:
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 192:
            case 193:
                result = reduceNode(node.operand, cbNode, result);
                break;
            case 194:
                result = reduceNode(node.left, cbNode, result);
                result = reduceNode(node.right, cbNode, result);
                break;
            case 195:
                result = reduceNode(node.condition, cbNode, result);
                result = reduceNode(node.whenTrue, cbNode, result);
                result = reduceNode(node.whenFalse, cbNode, result);
                break;
            case 196:
                result = reduceNode(node.head, cbNode, result);
                result = reduceNodes(node.templateSpans, cbNodes, result);
                break;
            case 199:
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNodes(node.typeParameters, cbNodes, result);
                result = reduceNodes(node.heritageClauses, cbNodes, result);
                result = reduceNodes(node.members, cbNodes, result);
                break;
            case 201:
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNodes(node.typeArguments, cbNodes, result);
                break;
            case 202:
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNode(node.type, cbNode, result);
                break;
            case 203:
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 205:
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNode(node.literal, cbNode, result);
                break;
            case 207:
                result = reduceNodes(node.statements, cbNodes, result);
                break;
            case 208:
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.declarationList, cbNode, result);
                break;
            case 210:
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 211:
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNode(node.thenStatement, cbNode, result);
                result = reduceNode(node.elseStatement, cbNode, result);
                break;
            case 212:
                result = reduceNode(node.statement, cbNode, result);
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 213:
            case 220:
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNode(node.statement, cbNode, result);
                break;
            case 214:
                result = reduceNode(node.initializer, cbNode, result);
                result = reduceNode(node.condition, cbNode, result);
                result = reduceNode(node.incrementor, cbNode, result);
                result = reduceNode(node.statement, cbNode, result);
                break;
            case 215:
            case 216:
                result = reduceNode(node.initializer, cbNode, result);
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNode(node.statement, cbNode, result);
                break;
            case 219:
            case 223:
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 221:
                result = reduceNode(node.expression, cbNode, result);
                result = reduceNode(node.caseBlock, cbNode, result);
                break;
            case 222:
                result = reduceNode(node.label, cbNode, result);
                result = reduceNode(node.statement, cbNode, result);
                break;
            case 224:
                result = reduceNode(node.tryBlock, cbNode, result);
                result = reduceNode(node.catchClause, cbNode, result);
                result = reduceNode(node.finallyBlock, cbNode, result);
                break;
            case 226:
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.type, cbNode, result);
                result = reduceNode(node.initializer, cbNode, result);
                break;
            case 227:
                result = reduceNodes(node.declarations, cbNodes, result);
                break;
            case 228:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNodes(node.typeParameters, cbNodes, result);
                result = reduceNodes(node.parameters, cbNodes, result);
                result = reduceNode(node.type, cbNode, result);
                result = reduceNode(node.body, cbNode, result);
                break;
            case 229:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNodes(node.typeParameters, cbNodes, result);
                result = reduceNodes(node.heritageClauses, cbNodes, result);
                result = reduceNodes(node.members, cbNodes, result);
                break;
            case 232:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNodes(node.members, cbNodes, result);
                break;
            case 233:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.body, cbNode, result);
                break;
            case 234:
                result = reduceNodes(node.statements, cbNodes, result);
                break;
            case 235:
                result = reduceNodes(node.clauses, cbNodes, result);
                break;
            case 237:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.moduleReference, cbNode, result);
                break;
            case 238:
                result = reduceNodes(node.decorators, cbNodes, result);
                result = reduceNodes(node.modifiers, cbNodes, result);
                result = reduceNode(node.importClause, cbNode, result);
                result = reduceNode(node.moduleSpecifier, cbNode, result);
                break;
            case 239:
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.namedBindings, cbNode, result);
                break;
            case 240:
                result = reduceNode(node.name, cbNode, result);
                break;
            case 241:
            case 245:
                result = reduceNodes(node.elements, cbNodes, result);
                break;
            case 242:
            case 246:
                result = reduceNode(node.propertyName, cbNode, result);
                result = reduceNode(node.name, cbNode, result);
                break;
            case 243:
                result = ts.reduceLeft(node.decorators, cbNode, result);
                result = ts.reduceLeft(node.modifiers, cbNode, result);
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 244:
                result = ts.reduceLeft(node.decorators, cbNode, result);
                result = ts.reduceLeft(node.modifiers, cbNode, result);
                result = reduceNode(node.exportClause, cbNode, result);
                result = reduceNode(node.moduleSpecifier, cbNode, result);
                break;
            case 248:
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 249:
                result = reduceNode(node.openingElement, cbNode, result);
                result = ts.reduceLeft(node.children, cbNode, result);
                result = reduceNode(node.closingElement, cbNode, result);
                break;
            case 250:
            case 251:
                result = reduceNode(node.tagName, cbNode, result);
                result = reduceNode(node.attributes, cbNode, result);
                break;
            case 254:
                result = reduceNodes(node.properties, cbNodes, result);
                break;
            case 252:
                result = reduceNode(node.tagName, cbNode, result);
                break;
            case 253:
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.initializer, cbNode, result);
                break;
            case 255:
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 256:
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 257:
                result = reduceNode(node.expression, cbNode, result);
            case 258:
                result = reduceNodes(node.statements, cbNodes, result);
                break;
            case 259:
                result = reduceNodes(node.types, cbNodes, result);
                break;
            case 260:
                result = reduceNode(node.variableDeclaration, cbNode, result);
                result = reduceNode(node.block, cbNode, result);
                break;
            case 261:
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.initializer, cbNode, result);
                break;
            case 262:
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.objectAssignmentInitializer, cbNode, result);
                break;
            case 263:
                result = reduceNode(node.expression, cbNode, result);
                break;
            case 264:
                result = reduceNode(node.name, cbNode, result);
                result = reduceNode(node.initializer, cbNode, result);
                break;
            case 265:
                result = reduceNodes(node.statements, cbNodes, result);
                break;
            case 296:
                result = reduceNode(node.expression, cbNode, result);
                break;
            default:
                break;
        }
        return result;
    }
    ts.reduceEachChild = reduceEachChild;
    function mergeLexicalEnvironment(statements, declarations) {
        if (!ts.some(declarations)) {
            return statements;
        }
        return ts.isNodeArray(statements)
            ? ts.setTextRange(ts.createNodeArray(ts.concatenate(statements, declarations)), statements)
            : ts.addRange(statements, declarations);
    }
    ts.mergeLexicalEnvironment = mergeLexicalEnvironment;
    function liftToBlock(nodes) {
        Debug.assert(ts.every(nodes, ts.isStatement), "Cannot lift nodes to a Block.");
        return ts.singleOrUndefined(nodes) || ts.createBlock(nodes);
    }
    ts.liftToBlock = liftToBlock;
    function aggregateTransformFlags(node) {
        aggregateTransformFlagsForNode(node);
        return node;
    }
    ts.aggregateTransformFlags = aggregateTransformFlags;
    function aggregateTransformFlagsForNode(node) {
        if (node === undefined) {
            return 0;
        }
        if (node.transformFlags & 536870912) {
            return node.transformFlags & ~ts.getTransformFlagsSubtreeExclusions(node.kind);
        }
        var subtreeFlags = aggregateTransformFlagsForSubtree(node);
        return ts.computeTransformFlagsForNode(node, subtreeFlags);
    }
    function aggregateTransformFlagsForNodeArray(nodes) {
        if (nodes === undefined) {
            return 0;
        }
        var subtreeFlags = 0;
        var nodeArrayFlags = 0;
        for (var _i = 0, nodes_3 = nodes; _i < nodes_3.length; _i++) {
            var node = nodes_3[_i];
            subtreeFlags |= aggregateTransformFlagsForNode(node);
            nodeArrayFlags |= node.transformFlags & ~536870912;
        }
        nodes.transformFlags = nodeArrayFlags | 536870912;
        return subtreeFlags;
    }
    function aggregateTransformFlagsForSubtree(node) {
        if (ts.hasModifier(node, 2) || (ts.isTypeNode(node) && node.kind !== 201)) {
            return 0;
        }
        return reduceEachChild(node, 0, aggregateTransformFlagsForChildNode, aggregateTransformFlagsForChildNodes);
    }
    function aggregateTransformFlagsForChildNode(transformFlags, node) {
        return transformFlags | aggregateTransformFlagsForNode(node);
    }
    function aggregateTransformFlagsForChildNodes(transformFlags, nodes) {
        return transformFlags | aggregateTransformFlagsForNodeArray(nodes);
    }
    var Debug;
    (function (Debug) {
        Debug.failBadSyntaxKind = Debug.shouldAssert(1)
            ? function (node, message) { return Debug.assert(false, message || "Unexpected node.", function () { return "Node " + ts.formatSyntaxKind(node.kind) + " was unexpected."; }); }
            : ts.noop;
        Debug.assertEachNode = Debug.shouldAssert(1)
            ? function (nodes, test, message) { return Debug.assert(test === undefined || ts.every(nodes, test), message || "Unexpected node.", function () { return "Node array did not pass test '" + getFunctionName(test) + "'."; }); }
            : ts.noop;
        Debug.assertNode = Debug.shouldAssert(1)
            ? function (node, test, message) { return Debug.assert(test === undefined || test(node), message || "Unexpected node.", function () { return "Node " + ts.formatSyntaxKind(node.kind) + " did not pass test '" + getFunctionName(test) + "'."; }); }
            : ts.noop;
        Debug.assertOptionalNode = Debug.shouldAssert(1)
            ? function (node, test, message) { return Debug.assert(test === undefined || node === undefined || test(node), message || "Unexpected node.", function () { return "Node " + ts.formatSyntaxKind(node.kind) + " did not pass test '" + getFunctionName(test) + "'."; }); }
            : ts.noop;
        Debug.assertOptionalToken = Debug.shouldAssert(1)
            ? function (node, kind, message) { return Debug.assert(kind === undefined || node === undefined || node.kind === kind, message || "Unexpected node.", function () { return "Node " + ts.formatSyntaxKind(node.kind) + " was not a '" + ts.formatSyntaxKind(kind) + "' token."; }); }
            : ts.noop;
        Debug.assertMissingNode = Debug.shouldAssert(1)
            ? function (node, message) { return Debug.assert(node === undefined, message || "Unexpected node.", function () { return "Node " + ts.formatSyntaxKind(node.kind) + " was unexpected'."; }); }
            : ts.noop;
        function getFunctionName(func) {
            if (typeof func !== "function") {
                return "";
            }
            else if (func.hasOwnProperty("name")) {
                return func.name;
            }
            else {
                var text = Function.prototype.toString.call(func);
                var match = /^function\s+([\w\$]+)\s*\(/.exec(text);
                return match ? match[1] : "";
            }
        }
    })(Debug = ts.Debug || (ts.Debug = {}));
})(ts || (ts = {}));
var ts;
(function (ts) {
    var FlattenLevel;
    (function (FlattenLevel) {
        FlattenLevel[FlattenLevel["All"] = 0] = "All";
        FlattenLevel[FlattenLevel["ObjectRest"] = 1] = "ObjectRest";
    })(FlattenLevel = ts.FlattenLevel || (ts.FlattenLevel = {}));
    function flattenDestructuringAssignment(node, visitor, context, level, needsValue, createAssignmentCallback) {
        var location = node;
        var value;
        if (ts.isDestructuringAssignment(node)) {
            value = node.right;
            while (ts.isEmptyArrayLiteral(node.left) || ts.isEmptyObjectLiteral(node.left)) {
                if (ts.isDestructuringAssignment(value)) {
                    location = node = value;
                    value = node.right;
                }
                else {
                    return value;
                }
            }
        }
        var expressions;
        var flattenContext = {
            context: context,
            level: level,
            downlevelIteration: context.getCompilerOptions().downlevelIteration,
            hoistTempVariables: true,
            emitExpression: emitExpression,
            emitBindingOrAssignment: emitBindingOrAssignment,
            createArrayBindingOrAssignmentPattern: makeArrayAssignmentPattern,
            createObjectBindingOrAssignmentPattern: makeObjectAssignmentPattern,
            createArrayBindingOrAssignmentElement: makeAssignmentElement,
            visitor: visitor
        };
        if (value) {
            value = ts.visitNode(value, visitor, ts.isExpression);
            if (needsValue) {
                value = ensureIdentifier(flattenContext, value, true, location);
            }
            else if (ts.nodeIsSynthesized(node)) {
                location = value;
            }
        }
        flattenBindingOrAssignmentElement(flattenContext, node, value, location, ts.isDestructuringAssignment(node));
        if (value && needsValue) {
            if (!ts.some(expressions)) {
                return value;
            }
            expressions.push(value);
        }
        return ts.aggregateTransformFlags(ts.inlineExpressions(expressions)) || ts.createOmittedExpression();
        function emitExpression(expression) {
            ts.setEmitFlags(expression, 64);
            ts.aggregateTransformFlags(expression);
            expressions = ts.append(expressions, expression);
        }
        function emitBindingOrAssignment(target, value, location, original) {
            ts.Debug.assertNode(target, createAssignmentCallback ? ts.isIdentifier : ts.isExpression);
            var expression = createAssignmentCallback
                ? createAssignmentCallback(target, value, location)
                : ts.setTextRange(ts.createAssignment(ts.visitNode(target, visitor, ts.isExpression), value), location);
            expression.original = original;
            emitExpression(expression);
        }
    }
    ts.flattenDestructuringAssignment = flattenDestructuringAssignment;
    function flattenDestructuringBinding(node, visitor, context, level, rval, hoistTempVariables, skipInitializer) {
        var pendingExpressions;
        var pendingDeclarations = [];
        var declarations = [];
        var flattenContext = {
            context: context,
            level: level,
            downlevelIteration: context.getCompilerOptions().downlevelIteration,
            hoistTempVariables: hoistTempVariables,
            emitExpression: emitExpression,
            emitBindingOrAssignment: emitBindingOrAssignment,
            createArrayBindingOrAssignmentPattern: makeArrayBindingPattern,
            createObjectBindingOrAssignmentPattern: makeObjectBindingPattern,
            createArrayBindingOrAssignmentElement: makeBindingElement,
            visitor: visitor
        };
        flattenBindingOrAssignmentElement(flattenContext, node, rval, node, skipInitializer);
        if (pendingExpressions) {
            var temp = ts.createTempVariable(undefined);
            if (hoistTempVariables) {
                var value = ts.inlineExpressions(pendingExpressions);
                pendingExpressions = undefined;
                emitBindingOrAssignment(temp, value, undefined, undefined);
            }
            else {
                context.hoistVariableDeclaration(temp);
                var pendingDeclaration = ts.lastOrUndefined(pendingDeclarations);
                pendingDeclaration.pendingExpressions = ts.append(pendingDeclaration.pendingExpressions, ts.createAssignment(temp, pendingDeclaration.value));
                ts.addRange(pendingDeclaration.pendingExpressions, pendingExpressions);
                pendingDeclaration.value = temp;
            }
        }
        for (var _i = 0, pendingDeclarations_1 = pendingDeclarations; _i < pendingDeclarations_1.length; _i++) {
            var _a = pendingDeclarations_1[_i], pendingExpressions_1 = _a.pendingExpressions, name = _a.name, value = _a.value, location = _a.location, original = _a.original;
            var variable = ts.createVariableDeclaration(name, undefined, pendingExpressions_1 ? ts.inlineExpressions(ts.append(pendingExpressions_1, value)) : value);
            variable.original = original;
            ts.setTextRange(variable, location);
            if (ts.isIdentifier(name)) {
                ts.setEmitFlags(variable, 64);
            }
            ts.aggregateTransformFlags(variable);
            declarations.push(variable);
        }
        return declarations;
        function emitExpression(value) {
            pendingExpressions = ts.append(pendingExpressions, value);
        }
        function emitBindingOrAssignment(target, value, location, original) {
            ts.Debug.assertNode(target, ts.isBindingName);
            if (pendingExpressions) {
                value = ts.inlineExpressions(ts.append(pendingExpressions, value));
                pendingExpressions = undefined;
            }
            pendingDeclarations.push({ pendingExpressions: pendingExpressions, name: target, value: value, location: location, original: original });
        }
    }
    ts.flattenDestructuringBinding = flattenDestructuringBinding;
    function flattenBindingOrAssignmentElement(flattenContext, element, value, location, skipInitializer) {
        if (!skipInitializer) {
            var initializer = ts.visitNode(ts.getInitializerOfBindingOrAssignmentElement(element), flattenContext.visitor, ts.isExpression);
            if (initializer) {
                value = value ? createDefaultValueCheck(flattenContext, value, initializer, location) : initializer;
            }
            else if (!value) {
                value = ts.createVoidZero();
            }
        }
        var bindingTarget = ts.getTargetOfBindingOrAssignmentElement(element);
        if (ts.isObjectBindingOrAssignmentPattern(bindingTarget)) {
            flattenObjectBindingOrAssignmentPattern(flattenContext, element, bindingTarget, value, location);
        }
        else if (ts.isArrayBindingOrAssignmentPattern(bindingTarget)) {
            flattenArrayBindingOrAssignmentPattern(flattenContext, element, bindingTarget, value, location);
        }
        else {
            flattenContext.emitBindingOrAssignment(bindingTarget, value, location, element);
        }
    }
    function flattenObjectBindingOrAssignmentPattern(flattenContext, parent, pattern, value, location) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        var numElements = elements.length;
        if (numElements !== 1) {
            var reuseIdentifierExpressions = !ts.isDeclarationBindingElement(parent) || numElements !== 0;
            value = ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location);
        }
        var bindingElements;
        var computedTempVariables;
        for (var i = 0; i < numElements; i++) {
            var element = elements[i];
            if (!ts.getRestIndicatorOfBindingOrAssignmentElement(element)) {
                var propertyName = ts.getPropertyNameOfBindingOrAssignmentElement(element);
                if (flattenContext.level >= 1
                    && !(element.transformFlags & (524288 | 1048576))
                    && !(ts.getTargetOfBindingOrAssignmentElement(element).transformFlags & (524288 | 1048576))
                    && !ts.isComputedPropertyName(propertyName)) {
                    bindingElements = ts.append(bindingElements, element);
                }
                else {
                    if (bindingElements) {
                        flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
                        bindingElements = undefined;
                    }
                    var rhsValue = createDestructuringPropertyAccess(flattenContext, value, propertyName);
                    if (ts.isComputedPropertyName(propertyName)) {
                        computedTempVariables = ts.append(computedTempVariables, rhsValue.argumentExpression);
                    }
                    flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
                }
            }
            else if (i === numElements - 1) {
                if (bindingElements) {
                    flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
                    bindingElements = undefined;
                }
                var rhsValue = createRestCall(flattenContext.context, value, elements, computedTempVariables, pattern);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
            }
        }
        if (bindingElements) {
            flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
        }
    }
    function flattenArrayBindingOrAssignmentPattern(flattenContext, parent, pattern, value, location) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        var numElements = elements.length;
        if (flattenContext.level < 1 && flattenContext.downlevelIteration) {
            value = ensureIdentifier(flattenContext, ts.createReadHelper(flattenContext.context, value, numElements > 0 && ts.getRestIndicatorOfBindingOrAssignmentElement(elements[numElements - 1])
                ? undefined
                : numElements, location), false, location);
        }
        else if (numElements !== 1 && (flattenContext.level < 1 || numElements === 0)) {
            var reuseIdentifierExpressions = !ts.isDeclarationBindingElement(parent) || numElements !== 0;
            value = ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location);
        }
        var bindingElements;
        var restContainingElements;
        for (var i = 0; i < numElements; i++) {
            var element = elements[i];
            if (flattenContext.level >= 1) {
                if (element.transformFlags & 1048576) {
                    var temp = ts.createTempVariable(undefined);
                    if (flattenContext.hoistTempVariables) {
                        flattenContext.context.hoistVariableDeclaration(temp);
                    }
                    restContainingElements = ts.append(restContainingElements, [temp, element]);
                    bindingElements = ts.append(bindingElements, flattenContext.createArrayBindingOrAssignmentElement(temp));
                }
                else {
                    bindingElements = ts.append(bindingElements, element);
                }
            }
            else if (ts.isOmittedExpression(element)) {
                continue;
            }
            else if (!ts.getRestIndicatorOfBindingOrAssignmentElement(element)) {
                var rhsValue = ts.createElementAccess(value, i);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
            }
            else if (i === numElements - 1) {
                var rhsValue = ts.createArraySlice(value, i);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
            }
        }
        if (bindingElements) {
            flattenContext.emitBindingOrAssignment(flattenContext.createArrayBindingOrAssignmentPattern(bindingElements), value, location, pattern);
        }
        if (restContainingElements) {
            for (var _i = 0, restContainingElements_1 = restContainingElements; _i < restContainingElements_1.length; _i++) {
                var _a = restContainingElements_1[_i], id = _a[0], element = _a[1];
                flattenBindingOrAssignmentElement(flattenContext, element, id, element);
            }
        }
    }
    function createDefaultValueCheck(flattenContext, value, defaultValue, location) {
        value = ensureIdentifier(flattenContext, value, true, location);
        return ts.createConditional(ts.createTypeCheck(value, "undefined"), defaultValue, value);
    }
    function createDestructuringPropertyAccess(flattenContext, value, propertyName) {
        if (ts.isComputedPropertyName(propertyName)) {
            var argumentExpression = ensureIdentifier(flattenContext, propertyName.expression, false, propertyName);
            return ts.createElementAccess(value, argumentExpression);
        }
        else if (ts.isStringOrNumericLiteral(propertyName)) {
            var argumentExpression = ts.getSynthesizedClone(propertyName);
            argumentExpression.text = ts.unescapeIdentifier(argumentExpression.text);
            return ts.createElementAccess(value, argumentExpression);
        }
        else {
            var name = ts.createIdentifier(ts.unescapeIdentifier(propertyName.text));
            return ts.createPropertyAccess(value, name);
        }
    }
    function ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location) {
        if (ts.isIdentifier(value) && reuseIdentifierExpressions) {
            return value;
        }
        else {
            var temp = ts.createTempVariable(undefined);
            if (flattenContext.hoistTempVariables) {
                flattenContext.context.hoistVariableDeclaration(temp);
                flattenContext.emitExpression(ts.setTextRange(ts.createAssignment(temp, value), location));
            }
            else {
                flattenContext.emitBindingOrAssignment(temp, value, location, undefined);
            }
            return temp;
        }
    }
    function makeArrayBindingPattern(elements) {
        ts.Debug.assertEachNode(elements, ts.isArrayBindingElement);
        return ts.createArrayBindingPattern(elements);
    }
    function makeArrayAssignmentPattern(elements) {
        return ts.createArrayLiteral(ts.map(elements, ts.convertToArrayAssignmentElement));
    }
    function makeObjectBindingPattern(elements) {
        ts.Debug.assertEachNode(elements, ts.isBindingElement);
        return ts.createObjectBindingPattern(elements);
    }
    function makeObjectAssignmentPattern(elements) {
        return ts.createObjectLiteral(ts.map(elements, ts.convertToObjectAssignmentElement));
    }
    function makeBindingElement(name) {
        return ts.createBindingElement(undefined, undefined, name);
    }
    function makeAssignmentElement(name) {
        return name;
    }
    var restHelper = {
        name: "typescript:rest",
        scoped: false,
        text: "\n            var __rest = (this && this.__rest) || function (s, e) {\n                var t = {};\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n                    t[p] = s[p];\n                if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n                        t[p[i]] = s[p[i]];\n                return t;\n            };"
    };
    function createRestCall(context, value, elements, computedTempVariables, location) {
        context.requestEmitHelper(restHelper);
        var propertyNames = [];
        var computedTempVariableOffset = 0;
        for (var i = 0; i < elements.length - 1; i++) {
            var propertyName = ts.getPropertyNameOfBindingOrAssignmentElement(elements[i]);
            if (propertyName) {
                if (ts.isComputedPropertyName(propertyName)) {
                    var temp = computedTempVariables[computedTempVariableOffset];
                    computedTempVariableOffset++;
                    propertyNames.push(ts.createConditional(ts.createTypeCheck(temp, "symbol"), temp, ts.createAdd(temp, ts.createLiteral(""))));
                }
                else {
                    propertyNames.push(ts.createLiteral(propertyName));
                }
            }
        }
        return ts.createCall(ts.getHelperName("__rest"), undefined, [
            value,
            ts.setTextRange(ts.createArrayLiteral(propertyNames), location)
        ]);
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    var USE_NEW_TYPE_METADATA_FORMAT = false;
    var TypeScriptSubstitutionFlags;
    (function (TypeScriptSubstitutionFlags) {
        TypeScriptSubstitutionFlags[TypeScriptSubstitutionFlags["ClassAliases"] = 1] = "ClassAliases";
        TypeScriptSubstitutionFlags[TypeScriptSubstitutionFlags["NamespaceExports"] = 2] = "NamespaceExports";
        TypeScriptSubstitutionFlags[TypeScriptSubstitutionFlags["NonQualifiedEnumMembers"] = 8] = "NonQualifiedEnumMembers";
    })(TypeScriptSubstitutionFlags || (TypeScriptSubstitutionFlags = {}));
    function transformTypeScript(context) {
        var startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var moduleKind = ts.getEmitModuleKind(compilerOptions);
        var previousOnEmitNode = context.onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        context.enableSubstitution(179);
        context.enableSubstitution(180);
        var currentSourceFile;
        var currentNamespace;
        var currentNamespaceContainerName;
        var currentScope;
        var currentScopeFirstDeclarationsOfName;
        var enabledSubstitutions;
        var classAliases;
        var applicableSubstitutions;
        return transformSourceFile;
        function transformSourceFile(node) {
            if (ts.isDeclarationFile(node)) {
                return node;
            }
            currentSourceFile = node;
            var visited = saveStateAndInvoke(node, visitSourceFile);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            return visited;
        }
        function saveStateAndInvoke(node, f) {
            var savedCurrentScope = currentScope;
            var savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;
            onBeforeVisitNode(node);
            var visited = f(node);
            if (currentScope !== savedCurrentScope) {
                currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;
            }
            currentScope = savedCurrentScope;
            return visited;
        }
        function onBeforeVisitNode(node) {
            switch (node.kind) {
                case 265:
                case 235:
                case 234:
                case 207:
                    currentScope = node;
                    currentScopeFirstDeclarationsOfName = undefined;
                    break;
                case 229:
                case 228:
                    if (ts.hasModifier(node, 2)) {
                        break;
                    }
                    recordEmittedDeclarationInScope(node);
                    break;
            }
        }
        function visitor(node) {
            return saveStateAndInvoke(node, visitorWorker);
        }
        function visitorWorker(node) {
            if (node.transformFlags & 1) {
                return visitTypeScript(node);
            }
            else if (node.transformFlags & 2) {
                return ts.visitEachChild(node, visitor, context);
            }
            return node;
        }
        function sourceElementVisitor(node) {
            return saveStateAndInvoke(node, sourceElementVisitorWorker);
        }
        function sourceElementVisitorWorker(node) {
            switch (node.kind) {
                case 238:
                    return visitImportDeclaration(node);
                case 237:
                    return visitImportEqualsDeclaration(node);
                case 243:
                    return visitExportAssignment(node);
                case 244:
                    return visitExportDeclaration(node);
                default:
                    return visitorWorker(node);
            }
        }
        function namespaceElementVisitor(node) {
            return saveStateAndInvoke(node, namespaceElementVisitorWorker);
        }
        function namespaceElementVisitorWorker(node) {
            if (node.kind === 244 ||
                node.kind === 238 ||
                node.kind === 239 ||
                (node.kind === 237 &&
                    node.moduleReference.kind === 248)) {
                return undefined;
            }
            else if (node.transformFlags & 1 || ts.hasModifier(node, 1)) {
                return visitTypeScript(node);
            }
            else if (node.transformFlags & 2) {
                return ts.visitEachChild(node, visitor, context);
            }
            return node;
        }
        function classElementVisitor(node) {
            return saveStateAndInvoke(node, classElementVisitorWorker);
        }
        function classElementVisitorWorker(node) {
            switch (node.kind) {
                case 152:
                    return undefined;
                case 149:
                case 157:
                case 153:
                case 154:
                case 151:
                    return visitorWorker(node);
                case 206:
                    return node;
                default:
                    ts.Debug.failBadSyntaxKind(node);
                    return undefined;
            }
        }
        function modifierVisitor(node) {
            if (ts.modifierToFlag(node.kind) & 2270) {
                return undefined;
            }
            else if (currentNamespace && node.kind === 84) {
                return undefined;
            }
            return node;
        }
        function visitTypeScript(node) {
            if (ts.hasModifier(node, 2) && ts.isStatement(node)) {
                return ts.createNotEmittedStatement(node);
            }
            switch (node.kind) {
                case 84:
                case 79:
                    return currentNamespace ? undefined : node;
                case 114:
                case 112:
                case 113:
                case 117:
                case 76:
                case 124:
                case 131:
                case 164:
                case 165:
                case 163:
                case 158:
                case 145:
                case 119:
                case 122:
                case 136:
                case 133:
                case 130:
                case 105:
                case 137:
                case 161:
                case 160:
                case 162:
                case 159:
                case 166:
                case 167:
                case 168:
                case 169:
                case 170:
                case 171:
                case 172:
                case 173:
                case 157:
                case 147:
                case 231:
                case 149:
                    return undefined;
                case 152:
                    return visitConstructor(node);
                case 230:
                    return ts.createNotEmittedStatement(node);
                case 229:
                    return visitClassDeclaration(node);
                case 199:
                    return visitClassExpression(node);
                case 259:
                    return visitHeritageClause(node);
                case 201:
                    return visitExpressionWithTypeArguments(node);
                case 151:
                    return visitMethodDeclaration(node);
                case 153:
                    return visitGetAccessor(node);
                case 154:
                    return visitSetAccessor(node);
                case 228:
                    return visitFunctionDeclaration(node);
                case 186:
                    return visitFunctionExpression(node);
                case 187:
                    return visitArrowFunction(node);
                case 146:
                    return visitParameter(node);
                case 185:
                    return visitParenthesizedExpression(node);
                case 184:
                case 202:
                    return visitAssertionExpression(node);
                case 181:
                    return visitCallExpression(node);
                case 182:
                    return visitNewExpression(node);
                case 203:
                    return visitNonNullExpression(node);
                case 232:
                    return visitEnumDeclaration(node);
                case 208:
                    return visitVariableStatement(node);
                case 226:
                    return visitVariableDeclaration(node);
                case 233:
                    return visitModuleDeclaration(node);
                case 237:
                    return visitImportEqualsDeclaration(node);
                default:
                    ts.Debug.failBadSyntaxKind(node);
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitSourceFile(node) {
            var alwaysStrict = (compilerOptions.alwaysStrict === undefined ? compilerOptions.strict : compilerOptions.alwaysStrict) &&
                !(ts.isExternalModule(node) && moduleKind === ts.ModuleKind.ES2015);
            return ts.updateSourceFileNode(node, ts.visitLexicalEnvironment(node.statements, sourceElementVisitor, context, 0, alwaysStrict));
        }
        function shouldEmitDecorateCallForClass(node) {
            if (node.decorators && node.decorators.length > 0) {
                return true;
            }
            var constructor = ts.getFirstConstructorWithBody(node);
            if (constructor) {
                return ts.forEach(constructor.parameters, shouldEmitDecorateCallForParameter);
            }
            return false;
        }
        function shouldEmitDecorateCallForParameter(parameter) {
            return parameter.decorators !== undefined && parameter.decorators.length > 0;
        }
        function visitClassDeclaration(node) {
            var staticProperties = getInitializedProperties(node, true);
            var hasExtendsClause = ts.getClassExtendsHeritageClauseElement(node) !== undefined;
            var isDecoratedClass = shouldEmitDecorateCallForClass(node);
            var name = node.name;
            if (!name && (staticProperties.length > 0 || ts.childIsDecorated(node))) {
                name = ts.getGeneratedNameForNode(node);
            }
            var classStatement = isDecoratedClass
                ? createClassDeclarationHeadWithDecorators(node, name, hasExtendsClause)
                : createClassDeclarationHeadWithoutDecorators(node, name, hasExtendsClause, staticProperties.length > 0);
            var statements = [classStatement];
            if (staticProperties.length) {
                addInitializedPropertyStatements(statements, staticProperties, ts.getLocalName(node));
            }
            addClassElementDecorationStatements(statements, node, false);
            addClassElementDecorationStatements(statements, node, true);
            addConstructorDecorationStatement(statements, node);
            if (isNamespaceExport(node)) {
                addExportMemberAssignment(statements, node);
            }
            else if (isDecoratedClass) {
                if (isDefaultExternalModuleExport(node)) {
                    statements.push(ts.createExportDefault(ts.getLocalName(node, false, true)));
                }
                else if (isNamedExternalModuleExport(node)) {
                    statements.push(ts.createExternalModuleExport(ts.getLocalName(node, false, true)));
                }
            }
            if (statements.length > 1) {
                statements.push(ts.createEndOfDeclarationMarker(node));
                ts.setEmitFlags(classStatement, ts.getEmitFlags(classStatement) | 4194304);
            }
            return ts.singleOrMany(statements);
        }
        function createClassDeclarationHeadWithoutDecorators(node, name, hasExtendsClause, hasStaticProperties) {
            var classDeclaration = ts.createClassDeclaration(undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), name, undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), transformClassMembers(node, hasExtendsClause));
            var emitFlags = ts.getEmitFlags(node);
            if (hasStaticProperties) {
                emitFlags |= 32;
            }
            ts.setTextRange(classDeclaration, node);
            ts.setOriginalNode(classDeclaration, node);
            ts.setEmitFlags(classDeclaration, emitFlags);
            return classDeclaration;
        }
        function createClassDeclarationHeadWithDecorators(node, name, hasExtendsClause) {
            var location = ts.moveRangePastDecorators(node);
            var classAlias = getClassAliasIfNeeded(node);
            var declName = ts.getLocalName(node, false, true);
            var heritageClauses = ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause);
            var members = transformClassMembers(node, hasExtendsClause);
            var classExpression = ts.createClassExpression(undefined, name, undefined, heritageClauses, members);
            ts.setOriginalNode(classExpression, node);
            ts.setTextRange(classExpression, location);
            var statement = ts.createVariableStatement(undefined, ts.createVariableDeclarationList([
                ts.createVariableDeclaration(declName, undefined, classAlias ? ts.createAssignment(classAlias, classExpression) : classExpression)
            ], 1));
            ts.setOriginalNode(statement, node);
            ts.setTextRange(statement, location);
            ts.setCommentRange(statement, node);
            return statement;
        }
        function visitClassExpression(node) {
            var staticProperties = getInitializedProperties(node, true);
            var heritageClauses = ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause);
            var members = transformClassMembers(node, ts.some(heritageClauses, function (c) { return c.token === 85; }));
            var classExpression = ts.createClassExpression(undefined, node.name, undefined, heritageClauses, members);
            ts.setOriginalNode(classExpression, node);
            ts.setTextRange(classExpression, node);
            if (staticProperties.length > 0) {
                var expressions = [];
                var temp = ts.createTempVariable(hoistVariableDeclaration);
                if (resolver.getNodeCheckFlags(node) & 8388608) {
                    enableSubstitutionForClassAliases();
                    classAliases[ts.getOriginalNodeId(node)] = ts.getSynthesizedClone(temp);
                }
                ts.setEmitFlags(classExpression, 65536 | ts.getEmitFlags(classExpression));
                expressions.push(ts.startOnNewLine(ts.createAssignment(temp, classExpression)));
                ts.addRange(expressions, generateInitializedPropertyExpressions(staticProperties, temp));
                expressions.push(ts.startOnNewLine(temp));
                return ts.inlineExpressions(expressions);
            }
            return classExpression;
        }
        function transformClassMembers(node, hasExtendsClause) {
            var members = [];
            var constructor = transformConstructor(node, hasExtendsClause);
            if (constructor) {
                members.push(constructor);
            }
            ts.addRange(members, ts.visitNodes(node.members, classElementVisitor, ts.isClassElement));
            return ts.setTextRange(ts.createNodeArray(members), node.members);
        }
        function transformConstructor(node, hasExtendsClause) {
            var hasInstancePropertyWithInitializer = ts.forEach(node.members, isInstanceInitializedProperty);
            var hasParameterPropertyAssignments = node.transformFlags & 262144;
            var constructor = ts.getFirstConstructorWithBody(node);
            if (!hasInstancePropertyWithInitializer && !hasParameterPropertyAssignments) {
                return ts.visitEachChild(constructor, visitor, context);
            }
            var parameters = transformConstructorParameters(constructor);
            var body = transformConstructorBody(node, constructor, hasExtendsClause);
            return ts.startOnNewLine(ts.setOriginalNode(ts.setTextRange(ts.createConstructor(undefined, undefined, parameters, body), constructor || node), constructor));
        }
        function transformConstructorParameters(constructor) {
            return ts.visitParameterList(constructor && constructor.parameters, visitor, context)
                || [];
        }
        function transformConstructorBody(node, constructor, hasExtendsClause) {
            var statements = [];
            var indexOfFirstStatement = 0;
            resumeLexicalEnvironment();
            if (constructor) {
                indexOfFirstStatement = addPrologueDirectivesAndInitialSuperCall(constructor, statements);
                var propertyAssignments = getParametersWithPropertyAssignments(constructor);
                ts.addRange(statements, ts.map(propertyAssignments, transformParameterWithPropertyAssignment));
            }
            else if (hasExtendsClause) {
                statements.push(ts.createStatement(ts.createCall(ts.createSuper(), undefined, [ts.createSpread(ts.createIdentifier("arguments"))])));
            }
            var properties = getInitializedProperties(node, false);
            addInitializedPropertyStatements(statements, properties, ts.createThis());
            if (constructor) {
                ts.addRange(statements, ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, indexOfFirstStatement));
            }
            statements = ts.mergeLexicalEnvironment(statements, endLexicalEnvironment());
            return ts.setTextRange(ts.createBlock(ts.setTextRange(ts.createNodeArray(statements), constructor ? constructor.body.statements : node.members), true), constructor ? constructor.body : undefined);
        }
        function addPrologueDirectivesAndInitialSuperCall(ctor, result) {
            if (ctor.body) {
                var statements = ctor.body.statements;
                var index = ts.addPrologue(result, statements, false, visitor);
                if (index === statements.length) {
                    return index;
                }
                var statement = statements[index];
                if (statement.kind === 210 && ts.isSuperCall(statement.expression)) {
                    result.push(ts.visitNode(statement, visitor, ts.isStatement));
                    return index + 1;
                }
                return index;
            }
            return 0;
        }
        function getParametersWithPropertyAssignments(node) {
            return ts.filter(node.parameters, isParameterWithPropertyAssignment);
        }
        function isParameterWithPropertyAssignment(parameter) {
            return ts.hasModifier(parameter, 92)
                && ts.isIdentifier(parameter.name);
        }
        function transformParameterWithPropertyAssignment(node) {
            ts.Debug.assert(ts.isIdentifier(node.name));
            var name = node.name;
            var propertyName = ts.getMutableClone(name);
            ts.setEmitFlags(propertyName, 1536 | 48);
            var localName = ts.getMutableClone(name);
            ts.setEmitFlags(localName, 1536);
            return ts.startOnNewLine(ts.setTextRange(ts.createStatement(ts.createAssignment(ts.setTextRange(ts.createPropertyAccess(ts.createThis(), propertyName), node.name), localName)), ts.moveRangePos(node, -1)));
        }
        function getInitializedProperties(node, isStatic) {
            return ts.filter(node.members, isStatic ? isStaticInitializedProperty : isInstanceInitializedProperty);
        }
        function isStaticInitializedProperty(member) {
            return isInitializedProperty(member, true);
        }
        function isInstanceInitializedProperty(member) {
            return isInitializedProperty(member, false);
        }
        function isInitializedProperty(member, isStatic) {
            return member.kind === 149
                && isStatic === ts.hasModifier(member, 32)
                && member.initializer !== undefined;
        }
        function addInitializedPropertyStatements(statements, properties, receiver) {
            for (var _i = 0, properties_9 = properties; _i < properties_9.length; _i++) {
                var property = properties_9[_i];
                var statement = ts.createStatement(transformInitializedProperty(property, receiver));
                ts.setSourceMapRange(statement, ts.moveRangePastModifiers(property));
                ts.setCommentRange(statement, property);
                statements.push(statement);
            }
        }
        function generateInitializedPropertyExpressions(properties, receiver) {
            var expressions = [];
            for (var _i = 0, properties_10 = properties; _i < properties_10.length; _i++) {
                var property = properties_10[_i];
                var expression = transformInitializedProperty(property, receiver);
                expression.startsOnNewLine = true;
                ts.setSourceMapRange(expression, ts.moveRangePastModifiers(property));
                ts.setCommentRange(expression, property);
                expressions.push(expression);
            }
            return expressions;
        }
        function transformInitializedProperty(property, receiver) {
            var propertyName = visitPropertyNameOfClassElement(property);
            var initializer = ts.visitNode(property.initializer, visitor, ts.isExpression);
            var memberAccess = ts.createMemberAccessForPropertyName(receiver, propertyName, propertyName);
            return ts.createAssignment(memberAccess, initializer);
        }
        function getDecoratedClassElements(node, isStatic) {
            return ts.filter(node.members, isStatic ? isStaticDecoratedClassElement : isInstanceDecoratedClassElement);
        }
        function isStaticDecoratedClassElement(member) {
            return isDecoratedClassElement(member, true);
        }
        function isInstanceDecoratedClassElement(member) {
            return isDecoratedClassElement(member, false);
        }
        function isDecoratedClassElement(member, isStatic) {
            return ts.nodeOrChildIsDecorated(member)
                && isStatic === ts.hasModifier(member, 32);
        }
        function getDecoratorsOfParameters(node) {
            var decorators;
            if (node) {
                var parameters = node.parameters;
                for (var i = 0; i < parameters.length; i++) {
                    var parameter = parameters[i];
                    if (decorators || parameter.decorators) {
                        if (!decorators) {
                            decorators = new Array(parameters.length);
                        }
                        decorators[i] = parameter.decorators;
                    }
                }
            }
            return decorators;
        }
        function getAllDecoratorsOfConstructor(node) {
            var decorators = node.decorators;
            var parameters = getDecoratorsOfParameters(ts.getFirstConstructorWithBody(node));
            if (!decorators && !parameters) {
                return undefined;
            }
            return {
                decorators: decorators,
                parameters: parameters
            };
        }
        function getAllDecoratorsOfClassElement(node, member) {
            switch (member.kind) {
                case 153:
                case 154:
                    return getAllDecoratorsOfAccessors(node, member);
                case 151:
                    return getAllDecoratorsOfMethod(member);
                case 149:
                    return getAllDecoratorsOfProperty(member);
                default:
                    return undefined;
            }
        }
        function getAllDecoratorsOfAccessors(node, accessor) {
            if (!accessor.body) {
                return undefined;
            }
            var _a = ts.getAllAccessorDeclarations(node.members, accessor), firstAccessor = _a.firstAccessor, secondAccessor = _a.secondAccessor, setAccessor = _a.setAccessor;
            var firstAccessorWithDecorators = firstAccessor.decorators ? firstAccessor : secondAccessor && secondAccessor.decorators ? secondAccessor : undefined;
            if (!firstAccessorWithDecorators || accessor !== firstAccessorWithDecorators) {
                return undefined;
            }
            var decorators = firstAccessorWithDecorators.decorators;
            var parameters = getDecoratorsOfParameters(setAccessor);
            if (!decorators && !parameters) {
                return undefined;
            }
            return { decorators: decorators, parameters: parameters };
        }
        function getAllDecoratorsOfMethod(method) {
            if (!method.body) {
                return undefined;
            }
            var decorators = method.decorators;
            var parameters = getDecoratorsOfParameters(method);
            if (!decorators && !parameters) {
                return undefined;
            }
            return { decorators: decorators, parameters: parameters };
        }
        function getAllDecoratorsOfProperty(property) {
            var decorators = property.decorators;
            if (!decorators) {
                return undefined;
            }
            return { decorators: decorators };
        }
        function transformAllDecoratorsOfDeclaration(node, container, allDecorators) {
            if (!allDecorators) {
                return undefined;
            }
            var decoratorExpressions = [];
            ts.addRange(decoratorExpressions, ts.map(allDecorators.decorators, transformDecorator));
            ts.addRange(decoratorExpressions, ts.flatMap(allDecorators.parameters, transformDecoratorsOfParameter));
            addTypeMetadata(node, container, decoratorExpressions);
            return decoratorExpressions;
        }
        function addClassElementDecorationStatements(statements, node, isStatic) {
            ts.addRange(statements, ts.map(generateClassElementDecorationExpressions(node, isStatic), expressionToStatement));
        }
        function generateClassElementDecorationExpressions(node, isStatic) {
            var members = getDecoratedClassElements(node, isStatic);
            var expressions;
            for (var _i = 0, members_2 = members; _i < members_2.length; _i++) {
                var member = members_2[_i];
                var expression = generateClassElementDecorationExpression(node, member);
                if (expression) {
                    if (!expressions) {
                        expressions = [expression];
                    }
                    else {
                        expressions.push(expression);
                    }
                }
            }
            return expressions;
        }
        function generateClassElementDecorationExpression(node, member) {
            var allDecorators = getAllDecoratorsOfClassElement(node, member);
            var decoratorExpressions = transformAllDecoratorsOfDeclaration(member, node, allDecorators);
            if (!decoratorExpressions) {
                return undefined;
            }
            var prefix = getClassMemberPrefix(node, member);
            var memberName = getExpressionForPropertyName(member, true);
            var descriptor = languageVersion > 0
                ? member.kind === 149
                    ? ts.createVoidZero()
                    : ts.createNull()
                : undefined;
            var helper = createDecorateHelper(context, decoratorExpressions, prefix, memberName, descriptor, ts.moveRangePastDecorators(member));
            ts.setEmitFlags(helper, 1536);
            return helper;
        }
        function addConstructorDecorationStatement(statements, node) {
            var expression = generateConstructorDecorationExpression(node);
            if (expression) {
                statements.push(ts.setOriginalNode(ts.createStatement(expression), node));
            }
        }
        function generateConstructorDecorationExpression(node) {
            var allDecorators = getAllDecoratorsOfConstructor(node);
            var decoratorExpressions = transformAllDecoratorsOfDeclaration(node, node, allDecorators);
            if (!decoratorExpressions) {
                return undefined;
            }
            var classAlias = classAliases && classAliases[ts.getOriginalNodeId(node)];
            var localName = ts.getLocalName(node, false, true);
            var decorate = createDecorateHelper(context, decoratorExpressions, localName);
            var expression = ts.createAssignment(localName, classAlias ? ts.createAssignment(classAlias, decorate) : decorate);
            ts.setEmitFlags(expression, 1536);
            ts.setSourceMapRange(expression, ts.moveRangePastDecorators(node));
            return expression;
        }
        function transformDecorator(decorator) {
            return ts.visitNode(decorator.expression, visitor, ts.isExpression);
        }
        function transformDecoratorsOfParameter(decorators, parameterOffset) {
            var expressions;
            if (decorators) {
                expressions = [];
                for (var _i = 0, decorators_1 = decorators; _i < decorators_1.length; _i++) {
                    var decorator = decorators_1[_i];
                    var helper = createParamHelper(context, transformDecorator(decorator), parameterOffset, decorator.expression);
                    ts.setEmitFlags(helper, 1536);
                    expressions.push(helper);
                }
            }
            return expressions;
        }
        function addTypeMetadata(node, container, decoratorExpressions) {
            if (USE_NEW_TYPE_METADATA_FORMAT) {
                addNewTypeMetadata(node, container, decoratorExpressions);
            }
            else {
                addOldTypeMetadata(node, container, decoratorExpressions);
            }
        }
        function addOldTypeMetadata(node, container, decoratorExpressions) {
            if (compilerOptions.emitDecoratorMetadata) {
                if (shouldAddTypeMetadata(node)) {
                    decoratorExpressions.push(createMetadataHelper(context, "design:type", serializeTypeOfNode(node)));
                }
                if (shouldAddParamTypesMetadata(node)) {
                    decoratorExpressions.push(createMetadataHelper(context, "design:paramtypes", serializeParameterTypesOfNode(node, container)));
                }
                if (shouldAddReturnTypeMetadata(node)) {
                    decoratorExpressions.push(createMetadataHelper(context, "design:returntype", serializeReturnTypeOfNode(node)));
                }
            }
        }
        function addNewTypeMetadata(node, container, decoratorExpressions) {
            if (compilerOptions.emitDecoratorMetadata) {
                var properties = void 0;
                if (shouldAddTypeMetadata(node)) {
                    (properties || (properties = [])).push(ts.createPropertyAssignment("type", ts.createArrowFunction(undefined, undefined, [], undefined, ts.createToken(36), serializeTypeOfNode(node))));
                }
                if (shouldAddParamTypesMetadata(node)) {
                    (properties || (properties = [])).push(ts.createPropertyAssignment("paramTypes", ts.createArrowFunction(undefined, undefined, [], undefined, ts.createToken(36), serializeParameterTypesOfNode(node, container))));
                }
                if (shouldAddReturnTypeMetadata(node)) {
                    (properties || (properties = [])).push(ts.createPropertyAssignment("returnType", ts.createArrowFunction(undefined, undefined, [], undefined, ts.createToken(36), serializeReturnTypeOfNode(node))));
                }
                if (properties) {
                    decoratorExpressions.push(createMetadataHelper(context, "design:typeinfo", ts.createObjectLiteral(properties, true)));
                }
            }
        }
        function shouldAddTypeMetadata(node) {
            var kind = node.kind;
            return kind === 151
                || kind === 153
                || kind === 154
                || kind === 149;
        }
        function shouldAddReturnTypeMetadata(node) {
            return node.kind === 151;
        }
        function shouldAddParamTypesMetadata(node) {
            switch (node.kind) {
                case 229:
                case 199:
                    return ts.getFirstConstructorWithBody(node) !== undefined;
                case 151:
                case 153:
                case 154:
                    return true;
            }
            return false;
        }
        function serializeTypeOfNode(node) {
            switch (node.kind) {
                case 149:
                case 146:
                case 153:
                    return serializeTypeNode(node.type);
                case 154:
                    return serializeTypeNode(ts.getSetAccessorTypeAnnotationNode(node));
                case 229:
                case 199:
                case 151:
                    return ts.createIdentifier("Function");
                default:
                    return ts.createVoidZero();
            }
        }
        function serializeParameterTypesOfNode(node, container) {
            var valueDeclaration = ts.isClassLike(node)
                ? ts.getFirstConstructorWithBody(node)
                : ts.isFunctionLike(node) && ts.nodeIsPresent(node.body)
                    ? node
                    : undefined;
            var expressions = [];
            if (valueDeclaration) {
                var parameters = getParametersOfDecoratedDeclaration(valueDeclaration, container);
                var numParameters = parameters.length;
                for (var i = 0; i < numParameters; i++) {
                    var parameter = parameters[i];
                    if (i === 0 && ts.isIdentifier(parameter.name) && parameter.name.text === "this") {
                        continue;
                    }
                    if (parameter.dotDotDotToken) {
                        expressions.push(serializeTypeNode(ts.getRestParameterElementType(parameter.type)));
                    }
                    else {
                        expressions.push(serializeTypeOfNode(parameter));
                    }
                }
            }
            return ts.createArrayLiteral(expressions);
        }
        function getParametersOfDecoratedDeclaration(node, container) {
            if (container && node.kind === 153) {
                var setAccessor = ts.getAllAccessorDeclarations(container.members, node).setAccessor;
                if (setAccessor) {
                    return setAccessor.parameters;
                }
            }
            return node.parameters;
        }
        function serializeReturnTypeOfNode(node) {
            if (ts.isFunctionLike(node) && node.type) {
                return serializeTypeNode(node.type);
            }
            else if (ts.isAsyncFunction(node)) {
                return ts.createIdentifier("Promise");
            }
            return ts.createVoidZero();
        }
        function serializeTypeNode(node) {
            if (node === undefined) {
                return ts.createIdentifier("Object");
            }
            switch (node.kind) {
                case 105:
                case 139:
                case 95:
                case 130:
                    return ts.createVoidZero();
                case 168:
                    return serializeTypeNode(node.type);
                case 160:
                case 161:
                    return ts.createIdentifier("Function");
                case 164:
                case 165:
                    return ts.createIdentifier("Array");
                case 158:
                case 122:
                    return ts.createIdentifier("Boolean");
                case 136:
                    return ts.createIdentifier("String");
                case 134:
                    return ts.createIdentifier("Object");
                case 173:
                    switch (node.literal.kind) {
                        case 9:
                            return ts.createIdentifier("String");
                        case 8:
                            return ts.createIdentifier("Number");
                        case 101:
                        case 86:
                            return ts.createIdentifier("Boolean");
                        default:
                            ts.Debug.failBadSyntaxKind(node.literal);
                            break;
                    }
                    break;
                case 133:
                    return ts.createIdentifier("Number");
                case 137:
                    return languageVersion < 2
                        ? getGlobalSymbolNameWithFallback()
                        : ts.createIdentifier("Symbol");
                case 159:
                    return serializeTypeReferenceNode(node);
                case 167:
                case 166:
                    return serializeUnionOrIntersectionType(node);
                case 162:
                case 170:
                case 171:
                case 172:
                case 163:
                case 119:
                case 169:
                    break;
                default:
                    ts.Debug.failBadSyntaxKind(node);
                    break;
            }
            return ts.createIdentifier("Object");
        }
        function serializeUnionOrIntersectionType(node) {
            var serializedUnion;
            for (var _i = 0, _a = node.types; _i < _a.length; _i++) {
                var typeNode = _a[_i];
                var serializedIndividual = serializeTypeNode(typeNode);
                if (ts.isVoidExpression(serializedIndividual)) {
                    if (!serializedUnion) {
                        serializedUnion = serializedIndividual;
                    }
                }
                else if (ts.isIdentifier(serializedIndividual) && serializedIndividual.text === "Object") {
                    return serializedIndividual;
                }
                else if (serializedUnion && !ts.isVoidExpression(serializedUnion)) {
                    if (!ts.isIdentifier(serializedUnion) ||
                        !ts.isIdentifier(serializedIndividual) ||
                        serializedUnion.text !== serializedIndividual.text) {
                        return ts.createIdentifier("Object");
                    }
                }
                else {
                    serializedUnion = serializedIndividual;
                }
            }
            return serializedUnion;
        }
        function serializeTypeReferenceNode(node) {
            switch (resolver.getTypeReferenceSerializationKind(node.typeName, currentScope)) {
                case ts.TypeReferenceSerializationKind.Unknown:
                    var serialized = serializeEntityNameAsExpression(node.typeName, true);
                    var temp = ts.createTempVariable(hoistVariableDeclaration);
                    return ts.createLogicalOr(ts.createLogicalAnd(ts.createTypeCheck(ts.createAssignment(temp, serialized), "function"), temp), ts.createIdentifier("Object"));
                case ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue:
                    return serializeEntityNameAsExpression(node.typeName, false);
                case ts.TypeReferenceSerializationKind.VoidNullableOrNeverType:
                    return ts.createVoidZero();
                case ts.TypeReferenceSerializationKind.BooleanType:
                    return ts.createIdentifier("Boolean");
                case ts.TypeReferenceSerializationKind.NumberLikeType:
                    return ts.createIdentifier("Number");
                case ts.TypeReferenceSerializationKind.StringLikeType:
                    return ts.createIdentifier("String");
                case ts.TypeReferenceSerializationKind.ArrayLikeType:
                    return ts.createIdentifier("Array");
                case ts.TypeReferenceSerializationKind.ESSymbolType:
                    return languageVersion < 2
                        ? getGlobalSymbolNameWithFallback()
                        : ts.createIdentifier("Symbol");
                case ts.TypeReferenceSerializationKind.TypeWithCallSignature:
                    return ts.createIdentifier("Function");
                case ts.TypeReferenceSerializationKind.Promise:
                    return ts.createIdentifier("Promise");
                case ts.TypeReferenceSerializationKind.ObjectType:
                default:
                    return ts.createIdentifier("Object");
            }
        }
        function serializeEntityNameAsExpression(node, useFallback) {
            switch (node.kind) {
                case 71:
                    var name = ts.getMutableClone(node);
                    name.flags &= ~8;
                    name.original = undefined;
                    name.parent = currentScope;
                    if (useFallback) {
                        return ts.createLogicalAnd(ts.createStrictInequality(ts.createTypeOf(name), ts.createLiteral("undefined")), name);
                    }
                    return name;
                case 143:
                    return serializeQualifiedNameAsExpression(node, useFallback);
            }
        }
        function serializeQualifiedNameAsExpression(node, useFallback) {
            var left;
            if (node.left.kind === 71) {
                left = serializeEntityNameAsExpression(node.left, useFallback);
            }
            else if (useFallback) {
                var temp = ts.createTempVariable(hoistVariableDeclaration);
                left = ts.createLogicalAnd(ts.createAssignment(temp, serializeEntityNameAsExpression(node.left, true)), temp);
            }
            else {
                left = serializeEntityNameAsExpression(node.left, false);
            }
            return ts.createPropertyAccess(left, node.right);
        }
        function getGlobalSymbolNameWithFallback() {
            return ts.createConditional(ts.createTypeCheck(ts.createIdentifier("Symbol"), "function"), ts.createIdentifier("Symbol"), ts.createIdentifier("Object"));
        }
        function getExpressionForPropertyName(member, generateNameForComputedPropertyName) {
            var name = member.name;
            if (ts.isComputedPropertyName(name)) {
                return generateNameForComputedPropertyName
                    ? ts.getGeneratedNameForNode(name)
                    : name.expression;
            }
            else if (ts.isIdentifier(name)) {
                return ts.createLiteral(ts.unescapeIdentifier(name.text));
            }
            else {
                return ts.getSynthesizedClone(name);
            }
        }
        function visitPropertyNameOfClassElement(member) {
            var name = member.name;
            if (ts.isComputedPropertyName(name)) {
                var expression = ts.visitNode(name.expression, visitor, ts.isExpression);
                if (member.decorators) {
                    var generatedName = ts.getGeneratedNameForNode(name);
                    hoistVariableDeclaration(generatedName);
                    expression = ts.createAssignment(generatedName, expression);
                }
                return ts.updateComputedPropertyName(name, expression);
            }
            else {
                return name;
            }
        }
        function visitHeritageClause(node) {
            if (node.token === 85) {
                var types = ts.visitNodes(node.types, visitor, ts.isExpressionWithTypeArguments, 0, 1);
                return ts.setTextRange(ts.createHeritageClause(85, types), node);
            }
            return undefined;
        }
        function visitExpressionWithTypeArguments(node) {
            return ts.updateExpressionWithTypeArguments(node, undefined, ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression));
        }
        function shouldEmitFunctionLikeDeclaration(node) {
            return !ts.nodeIsMissing(node.body);
        }
        function visitConstructor(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return undefined;
            }
            return ts.updateConstructor(node, ts.visitNodes(node.decorators, visitor, ts.isDecorator), ts.visitNodes(node.modifiers, visitor, ts.isModifier), ts.visitParameterList(node.parameters, visitor, context), ts.visitFunctionBody(node.body, visitor, context));
        }
        function visitMethodDeclaration(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return undefined;
            }
            var updated = ts.updateMethod(node, undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, visitPropertyNameOfClassElement(node), undefined, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.visitFunctionBody(node.body, visitor, context));
            if (updated !== node) {
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        function shouldEmitAccessorDeclaration(node) {
            return !(ts.nodeIsMissing(node.body) && ts.hasModifier(node, 128));
        }
        function visitGetAccessor(node) {
            if (!shouldEmitAccessorDeclaration(node)) {
                return undefined;
            }
            var updated = ts.updateGetAccessor(node, undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), visitPropertyNameOfClassElement(node), ts.visitParameterList(node.parameters, visitor, context), undefined, ts.visitFunctionBody(node.body, visitor, context) || ts.createBlock([]));
            if (updated !== node) {
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        function visitSetAccessor(node) {
            if (!shouldEmitAccessorDeclaration(node)) {
                return undefined;
            }
            var updated = ts.updateSetAccessor(node, undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), visitPropertyNameOfClassElement(node), ts.visitParameterList(node.parameters, visitor, context), ts.visitFunctionBody(node.body, visitor, context) || ts.createBlock([]));
            if (updated !== node) {
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        function visitFunctionDeclaration(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return ts.createNotEmittedStatement(node);
            }
            var updated = ts.updateFunctionDeclaration(node, undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.visitFunctionBody(node.body, visitor, context) || ts.createBlock([]));
            if (isNamespaceExport(node)) {
                var statements = [updated];
                addExportMemberAssignment(statements, node);
                return statements;
            }
            return updated;
        }
        function visitFunctionExpression(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return ts.createOmittedExpression();
            }
            var updated = ts.updateFunctionExpression(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.visitFunctionBody(node.body, visitor, context) || ts.createBlock([]));
            return updated;
        }
        function visitArrowFunction(node) {
            var updated = ts.updateArrowFunction(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.visitFunctionBody(node.body, visitor, context));
            return updated;
        }
        function visitParameter(node) {
            if (ts.parameterIsThisKeyword(node)) {
                return undefined;
            }
            var parameter = ts.createParameter(undefined, undefined, node.dotDotDotToken, ts.visitNode(node.name, visitor, ts.isBindingName), undefined, undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            ts.setOriginalNode(parameter, node);
            ts.setTextRange(parameter, ts.moveRangePastModifiers(node));
            ts.setCommentRange(parameter, node);
            ts.setSourceMapRange(parameter, ts.moveRangePastModifiers(node));
            ts.setEmitFlags(parameter.name, 32);
            return parameter;
        }
        function visitVariableStatement(node) {
            if (isNamespaceExport(node)) {
                var variables = ts.getInitializedVariables(node.declarationList);
                if (variables.length === 0) {
                    return undefined;
                }
                return ts.setTextRange(ts.createStatement(ts.inlineExpressions(ts.map(variables, transformInitializedVariable))), node);
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformInitializedVariable(node) {
            var name = node.name;
            if (ts.isBindingPattern(name)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0, false, createNamespaceExportExpression);
            }
            else {
                return ts.setTextRange(ts.createAssignment(getNamespaceMemberNameWithSourceMapsAndWithoutComments(name), ts.visitNode(node.initializer, visitor, ts.isExpression)), node);
            }
        }
        function visitVariableDeclaration(node) {
            return ts.updateVariableDeclaration(node, ts.visitNode(node.name, visitor, ts.isBindingName), undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
        }
        function visitParenthesizedExpression(node) {
            var innerExpression = ts.skipOuterExpressions(node.expression, ~2);
            if (ts.isAssertionExpression(innerExpression)) {
                var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
                return ts.createPartiallyEmittedExpression(expression, node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitAssertionExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            return ts.createPartiallyEmittedExpression(expression, node);
        }
        function visitNonNullExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression);
            return ts.createPartiallyEmittedExpression(expression, node);
        }
        function visitCallExpression(node) {
            return ts.updateCall(node, ts.visitNode(node.expression, visitor, ts.isExpression), undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function visitNewExpression(node) {
            return ts.updateNew(node, ts.visitNode(node.expression, visitor, ts.isExpression), undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function shouldEmitEnumDeclaration(node) {
            return !ts.isConst(node)
                || compilerOptions.preserveConstEnums
                || compilerOptions.isolatedModules;
        }
        function visitEnumDeclaration(node) {
            if (!shouldEmitEnumDeclaration(node)) {
                return undefined;
            }
            var statements = [];
            var emitFlags = 2;
            if (addVarForEnumOrModuleDeclaration(statements, node)) {
                if (moduleKind !== ts.ModuleKind.System || currentScope !== currentSourceFile) {
                    emitFlags |= 512;
                }
            }
            var parameterName = getNamespaceParameterName(node);
            var containerName = getNamespaceContainerName(node);
            var exportName = ts.hasModifier(node, 1)
                ? ts.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, false, true)
                : ts.getLocalName(node, false, true);
            var moduleArg = ts.createLogicalOr(exportName, ts.createAssignment(exportName, ts.createObjectLiteral()));
            if (hasNamespaceQualifiedExportName(node)) {
                var localName = ts.getLocalName(node, false, true);
                moduleArg = ts.createAssignment(localName, moduleArg);
            }
            var enumStatement = ts.createStatement(ts.createCall(ts.createFunctionExpression(undefined, undefined, undefined, undefined, [ts.createParameter(undefined, undefined, undefined, parameterName)], undefined, transformEnumBody(node, containerName)), undefined, [moduleArg]));
            ts.setOriginalNode(enumStatement, node);
            ts.setTextRange(enumStatement, node);
            ts.setEmitFlags(enumStatement, emitFlags);
            statements.push(enumStatement);
            statements.push(ts.createEndOfDeclarationMarker(node));
            return statements;
        }
        function transformEnumBody(node, localName) {
            var savedCurrentNamespaceLocalName = currentNamespaceContainerName;
            currentNamespaceContainerName = localName;
            var statements = [];
            startLexicalEnvironment();
            ts.addRange(statements, ts.map(node.members, transformEnumMember));
            ts.addRange(statements, endLexicalEnvironment());
            currentNamespaceContainerName = savedCurrentNamespaceLocalName;
            return ts.createBlock(ts.setTextRange(ts.createNodeArray(statements), node.members), true);
        }
        function transformEnumMember(member) {
            var name = getExpressionForPropertyName(member, false);
            return ts.setTextRange(ts.createStatement(ts.setTextRange(ts.createAssignment(ts.createElementAccess(currentNamespaceContainerName, ts.createAssignment(ts.createElementAccess(currentNamespaceContainerName, name), transformEnumMemberDeclarationValue(member))), name), member)), member);
        }
        function transformEnumMemberDeclarationValue(member) {
            var value = resolver.getConstantValue(member);
            if (value !== undefined) {
                return ts.createLiteral(value);
            }
            else {
                enableSubstitutionForNonQualifiedEnumMembers();
                if (member.initializer) {
                    return ts.visitNode(member.initializer, visitor, ts.isExpression);
                }
                else {
                    return ts.createVoidZero();
                }
            }
        }
        function shouldEmitModuleDeclaration(node) {
            return ts.isInstantiatedModule(node, compilerOptions.preserveConstEnums || compilerOptions.isolatedModules);
        }
        function hasNamespaceQualifiedExportName(node) {
            return isNamespaceExport(node)
                || (isExternalModuleExport(node)
                    && moduleKind !== ts.ModuleKind.ES2015
                    && moduleKind !== ts.ModuleKind.System);
        }
        function recordEmittedDeclarationInScope(node) {
            var name = node.symbol && node.symbol.name;
            if (name) {
                if (!currentScopeFirstDeclarationsOfName) {
                    currentScopeFirstDeclarationsOfName = ts.createMap();
                }
                if (!currentScopeFirstDeclarationsOfName.has(name)) {
                    currentScopeFirstDeclarationsOfName.set(name, node);
                }
            }
        }
        function isFirstEmittedDeclarationInScope(node) {
            if (currentScopeFirstDeclarationsOfName) {
                var name = node.symbol && node.symbol.name;
                if (name) {
                    return currentScopeFirstDeclarationsOfName.get(name) === node;
                }
            }
            return false;
        }
        function addVarForEnumOrModuleDeclaration(statements, node) {
            var statement = ts.createVariableStatement(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), [
                ts.createVariableDeclaration(ts.getLocalName(node, false, true))
            ]);
            ts.setOriginalNode(statement, node);
            recordEmittedDeclarationInScope(node);
            if (isFirstEmittedDeclarationInScope(node)) {
                if (node.kind === 232) {
                    ts.setSourceMapRange(statement.declarationList, node);
                }
                else {
                    ts.setSourceMapRange(statement, node);
                }
                ts.setCommentRange(statement, node);
                ts.setEmitFlags(statement, 1024 | 4194304);
                statements.push(statement);
                return true;
            }
            else {
                var mergeMarker = ts.createMergeDeclarationMarker(statement);
                ts.setEmitFlags(mergeMarker, 1536 | 4194304);
                statements.push(mergeMarker);
                return false;
            }
        }
        function visitModuleDeclaration(node) {
            if (!shouldEmitModuleDeclaration(node)) {
                return ts.createNotEmittedStatement(node);
            }
            ts.Debug.assert(ts.isIdentifier(node.name), "TypeScript module should have an Identifier name.");
            enableSubstitutionForNamespaceExports();
            var statements = [];
            var emitFlags = 2;
            if (addVarForEnumOrModuleDeclaration(statements, node)) {
                if (moduleKind !== ts.ModuleKind.System || currentScope !== currentSourceFile) {
                    emitFlags |= 512;
                }
            }
            var parameterName = getNamespaceParameterName(node);
            var containerName = getNamespaceContainerName(node);
            var exportName = ts.hasModifier(node, 1)
                ? ts.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, false, true)
                : ts.getLocalName(node, false, true);
            var moduleArg = ts.createLogicalOr(exportName, ts.createAssignment(exportName, ts.createObjectLiteral()));
            if (hasNamespaceQualifiedExportName(node)) {
                var localName = ts.getLocalName(node, false, true);
                moduleArg = ts.createAssignment(localName, moduleArg);
            }
            var moduleStatement = ts.createStatement(ts.createCall(ts.createFunctionExpression(undefined, undefined, undefined, undefined, [ts.createParameter(undefined, undefined, undefined, parameterName)], undefined, transformModuleBody(node, containerName)), undefined, [moduleArg]));
            ts.setOriginalNode(moduleStatement, node);
            ts.setTextRange(moduleStatement, node);
            ts.setEmitFlags(moduleStatement, emitFlags);
            statements.push(moduleStatement);
            statements.push(ts.createEndOfDeclarationMarker(node));
            return statements;
        }
        function transformModuleBody(node, namespaceLocalName) {
            var savedCurrentNamespaceContainerName = currentNamespaceContainerName;
            var savedCurrentNamespace = currentNamespace;
            var savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;
            currentNamespaceContainerName = namespaceLocalName;
            currentNamespace = node;
            currentScopeFirstDeclarationsOfName = undefined;
            var statements = [];
            startLexicalEnvironment();
            var statementsLocation;
            var blockLocation;
            var body = node.body;
            if (body.kind === 234) {
                saveStateAndInvoke(body, function (body) { return ts.addRange(statements, ts.visitNodes(body.statements, namespaceElementVisitor, ts.isStatement)); });
                statementsLocation = body.statements;
                blockLocation = body;
            }
            else {
                var result = visitModuleDeclaration(body);
                if (result) {
                    if (ts.isArray(result)) {
                        ts.addRange(statements, result);
                    }
                    else {
                        statements.push(result);
                    }
                }
                var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;
                statementsLocation = ts.moveRangePos(moduleBlock.statements, -1);
            }
            ts.addRange(statements, endLexicalEnvironment());
            currentNamespaceContainerName = savedCurrentNamespaceContainerName;
            currentNamespace = savedCurrentNamespace;
            currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;
            var block = ts.createBlock(ts.setTextRange(ts.createNodeArray(statements), statementsLocation), true);
            ts.setTextRange(block, blockLocation);
            if (body.kind !== 234) {
                ts.setEmitFlags(block, ts.getEmitFlags(block) | 1536);
            }
            return block;
        }
        function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {
            if (moduleDeclaration.body.kind === 233) {
                var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);
                return recursiveInnerModule || moduleDeclaration.body;
            }
        }
        function visitImportDeclaration(node) {
            if (!node.importClause) {
                return node;
            }
            var importClause = ts.visitNode(node.importClause, visitImportClause, ts.isImportClause);
            return importClause
                ? ts.updateImportDeclaration(node, undefined, undefined, importClause, node.moduleSpecifier)
                : undefined;
        }
        function visitImportClause(node) {
            var name = resolver.isReferencedAliasDeclaration(node) ? node.name : undefined;
            var namedBindings = ts.visitNode(node.namedBindings, visitNamedImportBindings, ts.isNamedImportBindings);
            return (name || namedBindings) ? ts.updateImportClause(node, name, namedBindings) : undefined;
        }
        function visitNamedImportBindings(node) {
            if (node.kind === 240) {
                return resolver.isReferencedAliasDeclaration(node) ? node : undefined;
            }
            else {
                var elements = ts.visitNodes(node.elements, visitImportSpecifier, ts.isImportSpecifier);
                return ts.some(elements) ? ts.updateNamedImports(node, elements) : undefined;
            }
        }
        function visitImportSpecifier(node) {
            return resolver.isReferencedAliasDeclaration(node) ? node : undefined;
        }
        function visitExportAssignment(node) {
            return resolver.isValueAliasDeclaration(node)
                ? ts.visitEachChild(node, visitor, context)
                : undefined;
        }
        function visitExportDeclaration(node) {
            if (!node.exportClause) {
                return resolver.moduleExportsSomeValue(node.moduleSpecifier) ? node : undefined;
            }
            if (!resolver.isValueAliasDeclaration(node)) {
                return undefined;
            }
            var exportClause = ts.visitNode(node.exportClause, visitNamedExports, ts.isNamedExports);
            return exportClause
                ? ts.updateExportDeclaration(node, undefined, undefined, exportClause, node.moduleSpecifier)
                : undefined;
        }
        function visitNamedExports(node) {
            var elements = ts.visitNodes(node.elements, visitExportSpecifier, ts.isExportSpecifier);
            return ts.some(elements) ? ts.updateNamedExports(node, elements) : undefined;
        }
        function visitExportSpecifier(node) {
            return resolver.isValueAliasDeclaration(node) ? node : undefined;
        }
        function shouldEmitImportEqualsDeclaration(node) {
            return resolver.isReferencedAliasDeclaration(node)
                || (!ts.isExternalModule(currentSourceFile)
                    && resolver.isTopLevelValueImportEqualsWithEntityName(node));
        }
        function visitImportEqualsDeclaration(node) {
            if (ts.isExternalModuleImportEqualsDeclaration(node)) {
                return resolver.isReferencedAliasDeclaration(node)
                    ? ts.visitEachChild(node, visitor, context)
                    : undefined;
            }
            if (!shouldEmitImportEqualsDeclaration(node)) {
                return undefined;
            }
            var moduleReference = ts.createExpressionFromEntityName(node.moduleReference);
            ts.setEmitFlags(moduleReference, 1536 | 2048);
            if (isNamedExternalModuleExport(node) || !isNamespaceExport(node)) {
                return ts.setOriginalNode(ts.setTextRange(ts.createVariableStatement(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), ts.createVariableDeclarationList([
                    ts.setOriginalNode(ts.createVariableDeclaration(node.name, undefined, moduleReference), node)
                ])), node), node);
            }
            else {
                return ts.setOriginalNode(createNamespaceExport(node.name, moduleReference, node), node);
            }
        }
        function isNamespaceExport(node) {
            return currentNamespace !== undefined && ts.hasModifier(node, 1);
        }
        function isExternalModuleExport(node) {
            return currentNamespace === undefined && ts.hasModifier(node, 1);
        }
        function isNamedExternalModuleExport(node) {
            return isExternalModuleExport(node)
                && !ts.hasModifier(node, 512);
        }
        function isDefaultExternalModuleExport(node) {
            return isExternalModuleExport(node)
                && ts.hasModifier(node, 512);
        }
        function expressionToStatement(expression) {
            return ts.createStatement(expression);
        }
        function addExportMemberAssignment(statements, node) {
            var expression = ts.createAssignment(ts.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, false, true), ts.getLocalName(node));
            ts.setSourceMapRange(expression, ts.createRange(node.name.pos, node.end));
            var statement = ts.createStatement(expression);
            ts.setSourceMapRange(statement, ts.createRange(-1, node.end));
            statements.push(statement);
        }
        function createNamespaceExport(exportName, exportValue, location) {
            return ts.setTextRange(ts.createStatement(ts.createAssignment(ts.getNamespaceMemberName(currentNamespaceContainerName, exportName, false, true), exportValue)), location);
        }
        function createNamespaceExportExpression(exportName, exportValue, location) {
            return ts.setTextRange(ts.createAssignment(getNamespaceMemberNameWithSourceMapsAndWithoutComments(exportName), exportValue), location);
        }
        function getNamespaceMemberNameWithSourceMapsAndWithoutComments(name) {
            return ts.getNamespaceMemberName(currentNamespaceContainerName, name, false, true);
        }
        function getNamespaceParameterName(node) {
            var name = ts.getGeneratedNameForNode(node);
            ts.setSourceMapRange(name, node.name);
            return name;
        }
        function getNamespaceContainerName(node) {
            return ts.getGeneratedNameForNode(node);
        }
        function getClassAliasIfNeeded(node) {
            if (resolver.getNodeCheckFlags(node) & 8388608) {
                enableSubstitutionForClassAliases();
                var classAlias = ts.createUniqueName(node.name && !ts.isGeneratedIdentifier(node.name) ? ts.unescapeIdentifier(node.name.text) : "default");
                classAliases[ts.getOriginalNodeId(node)] = classAlias;
                hoistVariableDeclaration(classAlias);
                return classAlias;
            }
        }
        function getClassPrototype(node) {
            return ts.createPropertyAccess(ts.getDeclarationName(node), "prototype");
        }
        function getClassMemberPrefix(node, member) {
            return ts.hasModifier(member, 32)
                ? ts.getDeclarationName(node)
                : getClassPrototype(node);
        }
        function enableSubstitutionForNonQualifiedEnumMembers() {
            if ((enabledSubstitutions & 8) === 0) {
                enabledSubstitutions |= 8;
                context.enableSubstitution(71);
            }
        }
        function enableSubstitutionForClassAliases() {
            if ((enabledSubstitutions & 1) === 0) {
                enabledSubstitutions |= 1;
                context.enableSubstitution(71);
                classAliases = [];
            }
        }
        function enableSubstitutionForNamespaceExports() {
            if ((enabledSubstitutions & 2) === 0) {
                enabledSubstitutions |= 2;
                context.enableSubstitution(71);
                context.enableSubstitution(262);
                context.enableEmitNotification(233);
            }
        }
        function isTransformedModuleDeclaration(node) {
            return ts.getOriginalNode(node).kind === 233;
        }
        function isTransformedEnumDeclaration(node) {
            return ts.getOriginalNode(node).kind === 232;
        }
        function onEmitNode(hint, node, emitCallback) {
            var savedApplicableSubstitutions = applicableSubstitutions;
            var savedCurrentSourceFile = currentSourceFile;
            if (ts.isSourceFile(node)) {
                currentSourceFile = node;
            }
            if (enabledSubstitutions & 2 && isTransformedModuleDeclaration(node)) {
                applicableSubstitutions |= 2;
            }
            if (enabledSubstitutions & 8 && isTransformedEnumDeclaration(node)) {
                applicableSubstitutions |= 8;
            }
            previousOnEmitNode(hint, node, emitCallback);
            applicableSubstitutions = savedApplicableSubstitutions;
            currentSourceFile = savedCurrentSourceFile;
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1) {
                return substituteExpression(node);
            }
            else if (ts.isShorthandPropertyAssignment(node)) {
                return substituteShorthandPropertyAssignment(node);
            }
            return node;
        }
        function substituteShorthandPropertyAssignment(node) {
            if (enabledSubstitutions & 2) {
                var name = node.name;
                var exportedName = trySubstituteNamespaceExportedName(name);
                if (exportedName) {
                    if (node.objectAssignmentInitializer) {
                        var initializer = ts.createAssignment(exportedName, node.objectAssignmentInitializer);
                        return ts.setTextRange(ts.createPropertyAssignment(name, initializer), node);
                    }
                    return ts.setTextRange(ts.createPropertyAssignment(name, exportedName), node);
                }
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 71:
                    return substituteExpressionIdentifier(node);
                case 179:
                    return substitutePropertyAccessExpression(node);
                case 180:
                    return substituteElementAccessExpression(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            return trySubstituteClassAlias(node)
                || trySubstituteNamespaceExportedName(node)
                || node;
        }
        function trySubstituteClassAlias(node) {
            if (enabledSubstitutions & 1) {
                if (resolver.getNodeCheckFlags(node) & 16777216) {
                    var declaration = resolver.getReferencedValueDeclaration(node);
                    if (declaration) {
                        var classAlias = classAliases[declaration.id];
                        if (classAlias) {
                            var clone_2 = ts.getSynthesizedClone(classAlias);
                            ts.setSourceMapRange(clone_2, node);
                            ts.setCommentRange(clone_2, node);
                            return clone_2;
                        }
                    }
                }
            }
            return undefined;
        }
        function trySubstituteNamespaceExportedName(node) {
            if (enabledSubstitutions & applicableSubstitutions && !ts.isGeneratedIdentifier(node) && !ts.isLocalName(node)) {
                var container = resolver.getReferencedExportContainer(node, false);
                if (container && container.kind !== 265) {
                    var substitute = (applicableSubstitutions & 2 && container.kind === 233) ||
                        (applicableSubstitutions & 8 && container.kind === 232);
                    if (substitute) {
                        return ts.setTextRange(ts.createPropertyAccess(ts.getGeneratedNameForNode(container), node), node);
                    }
                }
            }
            return undefined;
        }
        function substitutePropertyAccessExpression(node) {
            return substituteConstantValue(node);
        }
        function substituteElementAccessExpression(node) {
            return substituteConstantValue(node);
        }
        function substituteConstantValue(node) {
            var constantValue = tryGetConstEnumValue(node);
            if (constantValue !== undefined) {
                ts.setConstantValue(node, constantValue);
                var substitute = ts.createLiteral(constantValue);
                if (!compilerOptions.removeComments) {
                    var propertyName = ts.isPropertyAccessExpression(node)
                        ? ts.declarationNameToString(node.name)
                        : ts.getTextOfNode(node.argumentExpression);
                    ts.addSyntheticTrailingComment(substitute, 3, " " + propertyName + " ");
                }
                return substitute;
            }
            return node;
        }
        function tryGetConstEnumValue(node) {
            if (compilerOptions.isolatedModules) {
                return undefined;
            }
            return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node)
                ? resolver.getConstantValue(node)
                : undefined;
        }
    }
    ts.transformTypeScript = transformTypeScript;
    function createDecorateHelper(context, decoratorExpressions, target, memberName, descriptor, location) {
        var argumentsArray = [];
        argumentsArray.push(ts.createArrayLiteral(decoratorExpressions, true));
        argumentsArray.push(target);
        if (memberName) {
            argumentsArray.push(memberName);
            if (descriptor) {
                argumentsArray.push(descriptor);
            }
        }
        context.requestEmitHelper(decorateHelper);
        return ts.setTextRange(ts.createCall(ts.getHelperName("__decorate"), undefined, argumentsArray), location);
    }
    var decorateHelper = {
        name: "typescript:decorate",
        scoped: false,
        priority: 2,
        text: "\n            var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n                var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n                if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n                else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n                return c > 3 && r && Object.defineProperty(target, key, r), r;\n            };"
    };
    function createMetadataHelper(context, metadataKey, metadataValue) {
        context.requestEmitHelper(metadataHelper);
        return ts.createCall(ts.getHelperName("__metadata"), undefined, [
            ts.createLiteral(metadataKey),
            metadataValue
        ]);
    }
    var metadataHelper = {
        name: "typescript:metadata",
        scoped: false,
        priority: 3,
        text: "\n            var __metadata = (this && this.__metadata) || function (k, v) {\n                if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n            };"
    };
    function createParamHelper(context, expression, parameterOffset, location) {
        context.requestEmitHelper(paramHelper);
        return ts.setTextRange(ts.createCall(ts.getHelperName("__param"), undefined, [
            ts.createLiteral(parameterOffset),
            expression
        ]), location);
    }
    var paramHelper = {
        name: "typescript:param",
        scoped: false,
        priority: 4,
        text: "\n            var __param = (this && this.__param) || function (paramIndex, decorator) {\n                return function (target, key) { decorator(target, key, paramIndex); }\n            };"
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var ES2017SubstitutionFlags;
    (function (ES2017SubstitutionFlags) {
        ES2017SubstitutionFlags[ES2017SubstitutionFlags["AsyncMethodsWithSuper"] = 1] = "AsyncMethodsWithSuper";
    })(ES2017SubstitutionFlags || (ES2017SubstitutionFlags = {}));
    function transformES2017(context) {
        var startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var currentSourceFile;
        var enabledSubstitutions;
        var enclosingSuperContainerFlags = 0;
        var previousOnEmitNode = context.onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        return transformSourceFile;
        function transformSourceFile(node) {
            if (ts.isDeclarationFile(node)) {
                return node;
            }
            currentSourceFile = node;
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            return visited;
        }
        function visitor(node) {
            if ((node.transformFlags & 16) === 0) {
                return node;
            }
            switch (node.kind) {
                case 120:
                    return undefined;
                case 191:
                    return visitAwaitExpression(node);
                case 151:
                    return visitMethodDeclaration(node);
                case 228:
                    return visitFunctionDeclaration(node);
                case 186:
                    return visitFunctionExpression(node);
                case 187:
                    return visitArrowFunction(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitAwaitExpression(node) {
            return ts.setOriginalNode(ts.setTextRange(ts.createYield(undefined, ts.visitNode(node.expression, visitor, ts.isExpression)), node), node);
        }
        function visitMethodDeclaration(node) {
            return ts.updateMethod(node, undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, undefined, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.getFunctionFlags(node) & 2
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        function visitFunctionDeclaration(node) {
            return ts.updateFunctionDeclaration(node, undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.getFunctionFlags(node) & 2
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        function visitFunctionExpression(node) {
            return ts.updateFunctionExpression(node, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.getFunctionFlags(node) & 2
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        function visitArrowFunction(node) {
            return ts.updateArrowFunction(node, ts.visitNodes(node.modifiers, visitor, ts.isModifier), undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, ts.getFunctionFlags(node) & 2
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        function transformAsyncFunctionBody(node) {
            resumeLexicalEnvironment();
            var original = ts.getOriginalNode(node, ts.isFunctionLike);
            var nodeType = original.type;
            var promiseConstructor = languageVersion < 2 ? getPromiseConstructor(nodeType) : undefined;
            var isArrowFunction = node.kind === 187;
            var hasLexicalArguments = (resolver.getNodeCheckFlags(node) & 8192) !== 0;
            if (!isArrowFunction) {
                var statements = [];
                var statementOffset = ts.addPrologue(statements, node.body.statements, false, visitor);
                statements.push(ts.createReturn(createAwaiterHelper(context, hasLexicalArguments, promiseConstructor, transformFunctionBodyWorker(node.body, statementOffset))));
                ts.addRange(statements, endLexicalEnvironment());
                var block = ts.createBlock(statements, true);
                ts.setTextRange(block, node.body);
                if (languageVersion >= 2) {
                    if (resolver.getNodeCheckFlags(node) & 4096) {
                        enableSubstitutionForAsyncMethodsWithSuper();
                        ts.addEmitHelper(block, ts.advancedAsyncSuperHelper);
                    }
                    else if (resolver.getNodeCheckFlags(node) & 2048) {
                        enableSubstitutionForAsyncMethodsWithSuper();
                        ts.addEmitHelper(block, ts.asyncSuperHelper);
                    }
                }
                return block;
            }
            else {
                var expression = createAwaiterHelper(context, hasLexicalArguments, promiseConstructor, transformFunctionBodyWorker(node.body));
                var declarations = endLexicalEnvironment();
                if (ts.some(declarations)) {
                    var block = ts.convertToFunctionBody(expression);
                    return ts.updateBlock(block, ts.setTextRange(ts.createNodeArray(ts.concatenate(block.statements, declarations)), block.statements));
                }
                return expression;
            }
        }
        function transformFunctionBodyWorker(body, start) {
            if (ts.isBlock(body)) {
                return ts.updateBlock(body, ts.visitLexicalEnvironment(body.statements, visitor, context, start));
            }
            else {
                startLexicalEnvironment();
                var visited = ts.convertToFunctionBody(ts.visitNode(body, visitor, ts.isConciseBody));
                var declarations = endLexicalEnvironment();
                return ts.updateBlock(visited, ts.setTextRange(ts.createNodeArray(ts.concatenate(visited.statements, declarations)), visited.statements));
            }
        }
        function getPromiseConstructor(type) {
            var typeName = type && ts.getEntityNameFromTypeNode(type);
            if (typeName && ts.isEntityName(typeName)) {
                var serializationKind = resolver.getTypeReferenceSerializationKind(typeName);
                if (serializationKind === ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue
                    || serializationKind === ts.TypeReferenceSerializationKind.Unknown) {
                    return typeName;
                }
            }
            return undefined;
        }
        function enableSubstitutionForAsyncMethodsWithSuper() {
            if ((enabledSubstitutions & 1) === 0) {
                enabledSubstitutions |= 1;
                context.enableSubstitution(181);
                context.enableSubstitution(179);
                context.enableSubstitution(180);
                context.enableEmitNotification(229);
                context.enableEmitNotification(151);
                context.enableEmitNotification(153);
                context.enableEmitNotification(154);
                context.enableEmitNotification(152);
            }
        }
        function onEmitNode(hint, node, emitCallback) {
            if (enabledSubstitutions & 1 && isSuperContainer(node)) {
                var superContainerFlags = resolver.getNodeCheckFlags(node) & (2048 | 4096);
                if (superContainerFlags !== enclosingSuperContainerFlags) {
                    var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                    enclosingSuperContainerFlags = superContainerFlags;
                    previousOnEmitNode(hint, node, emitCallback);
                    enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                    return;
                }
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 && enclosingSuperContainerFlags) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 179:
                    return substitutePropertyAccessExpression(node);
                case 180:
                    return substituteElementAccessExpression(node);
                case 181:
                    return substituteCallExpression(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (node.expression.kind === 97) {
                return createSuperAccessInAsyncMethod(ts.createLiteral(node.name.text), node);
            }
            return node;
        }
        function substituteElementAccessExpression(node) {
            if (node.expression.kind === 97) {
                return createSuperAccessInAsyncMethod(node.argumentExpression, node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            var expression = node.expression;
            if (ts.isSuperProperty(expression)) {
                var argumentExpression = ts.isPropertyAccessExpression(expression)
                    ? substitutePropertyAccessExpression(expression)
                    : substituteElementAccessExpression(expression);
                return ts.createCall(ts.createPropertyAccess(argumentExpression, "call"), undefined, [
                    ts.createThis()
                ].concat(node.arguments));
            }
            return node;
        }
        function isSuperContainer(node) {
            var kind = node.kind;
            return kind === 229
                || kind === 152
                || kind === 151
                || kind === 153
                || kind === 154;
        }
        function createSuperAccessInAsyncMethod(argumentExpression, location) {
            if (enclosingSuperContainerFlags & 4096) {
                return ts.setTextRange(ts.createPropertyAccess(ts.createCall(ts.createIdentifier("_super"), undefined, [argumentExpression]), "value"), location);
            }
            else {
                return ts.setTextRange(ts.createCall(ts.createIdentifier("_super"), undefined, [argumentExpression]), location);
            }
        }
    }
    ts.transformES2017 = transformES2017;
    var awaiterHelper = {
        name: "typescript:awaiter",
        scoped: false,
        priority: 5,
        text: "\n            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n                return new (P || (P = Promise))(function (resolve, reject) {\n                    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n                    function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n                    function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n                    step((generator = generator.apply(thisArg, _arguments || [])).next());\n                });\n            };"
    };
    function createAwaiterHelper(context, hasLexicalArguments, promiseConstructor, body) {
        context.requestEmitHelper(awaiterHelper);
        var generatorFunc = ts.createFunctionExpression(undefined, ts.createToken(39), undefined, undefined, [], undefined, body);
        (generatorFunc.emitNode || (generatorFunc.emitNode = {})).flags |= 262144;
        return ts.createCall(ts.getHelperName("__awaiter"), undefined, [
            ts.createThis(),
            hasLexicalArguments ? ts.createIdentifier("arguments") : ts.createVoidZero(),
            promiseConstructor ? ts.createExpressionFromEntityName(promiseConstructor) : ts.createVoidZero(),
            generatorFunc
        ]);
    }
    ts.asyncSuperHelper = {
        name: "typescript:async-super",
        scoped: true,
        text: "\n            const _super = name => super[name];\n        "
    };
    ts.advancedAsyncSuperHelper = {
        name: "typescript:advanced-async-super",
        scoped: true,
        text: "\n            const _super = (function (geti, seti) {\n                const cache = Object.create(null);\n                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });\n            })(name => super[name], (name, value) => super[name] = value);\n        "
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var ESNextSubstitutionFlags;
    (function (ESNextSubstitutionFlags) {
        ESNextSubstitutionFlags[ESNextSubstitutionFlags["AsyncMethodsWithSuper"] = 1] = "AsyncMethodsWithSuper";
    })(ESNextSubstitutionFlags || (ESNextSubstitutionFlags = {}));
    function transformESNext(context) {
        var resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var enabledSubstitutions;
        var enclosingFunctionFlags;
        var enclosingSuperContainerFlags = 0;
        return transformSourceFile;
        function transformSourceFile(node) {
            if (ts.isDeclarationFile(node)) {
                return node;
            }
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function visitor(node) {
            return visitorWorker(node, false);
        }
        function visitorNoDestructuringValue(node) {
            return visitorWorker(node, true);
        }
        function visitorNoAsyncModifier(node) {
            if (node.kind === 120) {
                return undefined;
            }
            return node;
        }
        function visitorWorker(node, noDestructuringValue) {
            if ((node.transformFlags & 8) === 0) {
                return node;
            }
            switch (node.kind) {
                case 191:
                    return visitAwaitExpression(node);
                case 197:
                    return visitYieldExpression(node);
                case 222:
                    return visitLabeledStatement(node);
                case 178:
                    return visitObjectLiteralExpression(node);
                case 194:
                    return visitBinaryExpression(node, noDestructuringValue);
                case 226:
                    return visitVariableDeclaration(node);
                case 216:
                    return visitForOfStatement(node, undefined);
                case 214:
                    return visitForStatement(node);
                case 190:
                    return visitVoidExpression(node);
                case 152:
                    return visitConstructorDeclaration(node);
                case 151:
                    return visitMethodDeclaration(node);
                case 153:
                    return visitGetAccessorDeclaration(node);
                case 154:
                    return visitSetAccessorDeclaration(node);
                case 228:
                    return visitFunctionDeclaration(node);
                case 186:
                    return visitFunctionExpression(node);
                case 187:
                    return visitArrowFunction(node);
                case 146:
                    return visitParameter(node);
                case 210:
                    return visitExpressionStatement(node);
                case 185:
                    return visitParenthesizedExpression(node, noDestructuringValue);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitAwaitExpression(node) {
            if (enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1) {
                return ts.setOriginalNode(ts.setTextRange(ts.createYield(createAwaitHelper(context, ts.visitNode(node.expression, visitor, ts.isExpression))), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitYieldExpression(node) {
            if (enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1 && node.asteriskToken) {
                var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
                return ts.setOriginalNode(ts.setTextRange(ts.createYield(createAwaitHelper(context, ts.updateYield(node, node.asteriskToken, createAsyncDelegatorHelper(context, createAsyncValuesHelper(context, expression, expression), expression)))), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitLabeledStatement(node) {
            if (enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1) {
                var statement = ts.unwrapInnermostStatementOfLabel(node);
                if (statement.kind === 216 && statement.awaitModifier) {
                    return visitForOfStatement(statement, node);
                }
                return ts.restoreEnclosingLabel(ts.visitEachChild(node, visitor, context), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function chunkObjectLiteralElements(elements) {
            var chunkObject;
            var objects = [];
            for (var _i = 0, elements_4 = elements; _i < elements_4.length; _i++) {
                var e = elements_4[_i];
                if (e.kind === 263) {
                    if (chunkObject) {
                        objects.push(ts.createObjectLiteral(chunkObject));
                        chunkObject = undefined;
                    }
                    var target = e.expression;
                    objects.push(ts.visitNode(target, visitor, ts.isExpression));
                }
                else {
                    if (!chunkObject) {
                        chunkObject = [];
                    }
                    if (e.kind === 261) {
                        var p = e;
                        chunkObject.push(ts.createPropertyAssignment(p.name, ts.visitNode(p.initializer, visitor, ts.isExpression)));
                    }
                    else {
                        chunkObject.push(e);
                    }
                }
            }
            if (chunkObject) {
                objects.push(ts.createObjectLiteral(chunkObject));
            }
            return objects;
        }
        function visitObjectLiteralExpression(node) {
            if (node.transformFlags & 1048576) {
                var objects = chunkObjectLiteralElements(node.properties);
                if (objects.length && objects[0].kind !== 178) {
                    objects.unshift(ts.createObjectLiteral());
                }
                return createAssignHelper(context, objects);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitExpressionStatement(node) {
            return ts.visitEachChild(node, visitorNoDestructuringValue, context);
        }
        function visitParenthesizedExpression(node, noDestructuringValue) {
            return ts.visitEachChild(node, noDestructuringValue ? visitorNoDestructuringValue : visitor, context);
        }
        function visitBinaryExpression(node, noDestructuringValue) {
            if (ts.isDestructuringAssignment(node) && node.left.transformFlags & 1048576) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 1, !noDestructuringValue);
            }
            else if (node.operatorToken.kind === 26) {
                return ts.updateBinary(node, ts.visitNode(node.left, visitorNoDestructuringValue, ts.isExpression), ts.visitNode(node.right, noDestructuringValue ? visitorNoDestructuringValue : visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableDeclaration(node) {
            if (ts.isBindingPattern(node.name) && node.name.transformFlags & 1048576) {
                return ts.flattenDestructuringBinding(node, visitor, context, 1);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return ts.updateFor(node, ts.visitNode(node.initializer, visitorNoDestructuringValue, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitor, ts.isExpression), ts.visitNode(node.statement, visitor, ts.isStatement));
        }
        function visitVoidExpression(node) {
            return ts.visitEachChild(node, visitorNoDestructuringValue, context);
        }
        function visitForOfStatement(node, outermostLabeledStatement) {
            if (node.initializer.transformFlags & 1048576) {
                node = transformForOfStatementWithObjectRest(node);
            }
            if (node.awaitModifier) {
                return transformForAwaitOfStatement(node, outermostLabeledStatement);
            }
            else {
                return ts.restoreEnclosingLabel(ts.visitEachChild(node, visitor, context), outermostLabeledStatement);
            }
        }
        function transformForOfStatementWithObjectRest(node) {
            var initializerWithoutParens = ts.skipParentheses(node.initializer);
            if (ts.isVariableDeclarationList(initializerWithoutParens) || ts.isAssignmentPattern(initializerWithoutParens)) {
                var bodyLocation = void 0;
                var statementsLocation = void 0;
                var temp = ts.createTempVariable(undefined);
                var statements = [ts.createForOfBindingStatement(initializerWithoutParens, temp)];
                if (ts.isBlock(node.statement)) {
                    ts.addRange(statements, node.statement.statements);
                    bodyLocation = node.statement;
                    statementsLocation = node.statement.statements;
                }
                return ts.updateForOf(node, node.awaitModifier, ts.setTextRange(ts.createVariableDeclarationList([
                    ts.setTextRange(ts.createVariableDeclaration(temp), node.initializer)
                ], 1), node.initializer), node.expression, ts.setTextRange(ts.createBlock(ts.setTextRange(ts.createNodeArray(statements), statementsLocation), true), bodyLocation));
            }
            return node;
        }
        function convertForOfStatementHead(node, boundValue) {
            var binding = ts.createForOfBindingStatement(node.initializer, boundValue);
            var bodyLocation;
            var statementsLocation;
            var statements = [ts.visitNode(binding, visitor, ts.isStatement)];
            var statement = ts.visitNode(node.statement, visitor, ts.isStatement);
            if (ts.isBlock(statement)) {
                ts.addRange(statements, statement.statements);
                bodyLocation = statement;
                statementsLocation = statement.statements;
            }
            else {
                statements.push(statement);
            }
            return ts.setEmitFlags(ts.setTextRange(ts.createBlock(ts.setTextRange(ts.createNodeArray(statements), statementsLocation), true), bodyLocation), 48 | 384);
        }
        function awaitAsYield(expression) {
            return ts.createYield(undefined, enclosingFunctionFlags & 1 ? createAwaitHelper(context, expression) : expression);
        }
        function transformForAwaitOfStatement(node, outermostLabeledStatement) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var iterator = ts.isIdentifier(expression) ? ts.getGeneratedNameForNode(expression) : ts.createTempVariable(undefined);
            var result = ts.isIdentifier(expression) ? ts.getGeneratedNameForNode(iterator) : ts.createTempVariable(undefined);
            var errorRecord = ts.createUniqueName("e");
            var catchVariable = ts.getGeneratedNameForNode(errorRecord);
            var returnMethod = ts.createTempVariable(undefined);
            var callValues = createAsyncValuesHelper(context, expression, node.expression);
            var callNext = ts.createCall(ts.createPropertyAccess(iterator, "next"), undefined, []);
            var getDone = ts.createPropertyAccess(result, "done");
            var getValue = ts.createPropertyAccess(result, "value");
            var callReturn = ts.createFunctionCall(returnMethod, iterator, []);
            hoistVariableDeclaration(errorRecord);
            hoistVariableDeclaration(returnMethod);
            var forStatement = ts.setEmitFlags(ts.setTextRange(ts.createFor(ts.setEmitFlags(ts.setTextRange(ts.createVariableDeclarationList([
                ts.setTextRange(ts.createVariableDeclaration(iterator, undefined, callValues), node.expression),
                ts.createVariableDeclaration(result)
            ]), node.expression), 2097152), ts.createComma(ts.createAssignment(result, awaitAsYield(callNext)), ts.createLogicalNot(getDone)), undefined, convertForOfStatementHead(node, awaitAsYield(getValue))), node), 256);
            return ts.createTry(ts.createBlock([
                ts.restoreEnclosingLabel(forStatement, outermostLabeledStatement)
            ]), ts.createCatchClause(ts.createVariableDeclaration(catchVariable), ts.setEmitFlags(ts.createBlock([
                ts.createStatement(ts.createAssignment(errorRecord, ts.createObjectLiteral([
                    ts.createPropertyAssignment("error", catchVariable)
                ])))
            ]), 1)), ts.createBlock([
                ts.createTry(ts.createBlock([
                    ts.setEmitFlags(ts.createIf(ts.createLogicalAnd(ts.createLogicalAnd(result, ts.createLogicalNot(getDone)), ts.createAssignment(returnMethod, ts.createPropertyAccess(iterator, "return"))), ts.createStatement(awaitAsYield(callReturn))), 1)
                ]), undefined, ts.setEmitFlags(ts.createBlock([
                    ts.setEmitFlags(ts.createIf(errorRecord, ts.createThrow(ts.createPropertyAccess(errorRecord, "error"))), 1)
                ]), 1))
            ]));
        }
        function visitParameter(node) {
            if (node.transformFlags & 1048576) {
                return ts.updateParameter(node, undefined, undefined, node.dotDotDotToken, ts.getGeneratedNameForNode(node), undefined, undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitConstructorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = 0;
            var updated = ts.updateConstructor(node, undefined, node.modifiers, ts.visitParameterList(node.parameters, visitor, context), transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitGetAccessorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = 0;
            var updated = ts.updateGetAccessor(node, undefined, node.modifiers, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitParameterList(node.parameters, visitor, context), undefined, transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitSetAccessorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = 0;
            var updated = ts.updateSetAccessor(node, undefined, node.modifiers, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitParameterList(node.parameters, visitor, context), transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitMethodDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            var updated = ts.updateMethod(node, undefined, enclosingFunctionFlags & 1
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2
                ? undefined
                : node.asteriskToken, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitNode(undefined, visitor, ts.isToken), undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitFunctionDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            var updated = ts.updateFunctionDeclaration(node, undefined, enclosingFunctionFlags & 1
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2
                ? undefined
                : node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitArrowFunction(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            var updated = ts.updateArrowFunction(node, node.modifiers, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function visitFunctionExpression(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            var updated = ts.updateFunctionExpression(node, enclosingFunctionFlags & 1
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2
                ? undefined
                : node.asteriskToken, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, enclosingFunctionFlags & 2 && enclosingFunctionFlags & 1
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            return updated;
        }
        function transformAsyncGeneratorFunctionBody(node) {
            resumeLexicalEnvironment();
            var statements = [];
            var statementOffset = ts.addPrologue(statements, node.body.statements, false, visitor);
            appendObjectRestAssignmentsIfNeeded(statements, node);
            statements.push(ts.createReturn(createAsyncGeneratorHelper(context, ts.createFunctionExpression(undefined, ts.createToken(39), node.name && ts.getGeneratedNameForNode(node.name), undefined, [], undefined, ts.updateBlock(node.body, ts.visitLexicalEnvironment(node.body.statements, visitor, context, statementOffset))))));
            ts.addRange(statements, endLexicalEnvironment());
            var block = ts.updateBlock(node.body, statements);
            if (languageVersion >= 2) {
                if (resolver.getNodeCheckFlags(node) & 4096) {
                    enableSubstitutionForAsyncMethodsWithSuper();
                    ts.addEmitHelper(block, ts.advancedAsyncSuperHelper);
                }
                else if (resolver.getNodeCheckFlags(node) & 2048) {
                    enableSubstitutionForAsyncMethodsWithSuper();
                    ts.addEmitHelper(block, ts.asyncSuperHelper);
                }
            }
            return block;
        }
        function transformFunctionBody(node) {
            resumeLexicalEnvironment();
            var statementOffset = 0;
            var statements = [];
            var body = ts.visitNode(node.body, visitor, ts.isConciseBody);
            if (ts.isBlock(body)) {
                statementOffset = ts.addPrologue(statements, body.statements, false, visitor);
            }
            ts.addRange(statements, appendObjectRestAssignmentsIfNeeded(undefined, node));
            var trailingStatements = endLexicalEnvironment();
            if (statementOffset > 0 || ts.some(statements) || ts.some(trailingStatements)) {
                var block = ts.convertToFunctionBody(body, true);
                ts.addRange(statements, block.statements.slice(statementOffset));
                ts.addRange(statements, trailingStatements);
                return ts.updateBlock(block, ts.setTextRange(ts.createNodeArray(statements), block.statements));
            }
            return body;
        }
        function appendObjectRestAssignmentsIfNeeded(statements, node) {
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                if (parameter.transformFlags & 1048576) {
                    var temp = ts.getGeneratedNameForNode(parameter);
                    var declarations = ts.flattenDestructuringBinding(parameter, visitor, context, 1, temp, false, true);
                    if (ts.some(declarations)) {
                        var statement = ts.createVariableStatement(undefined, ts.createVariableDeclarationList(declarations));
                        ts.setEmitFlags(statement, 1048576);
                        statements = ts.append(statements, statement);
                    }
                }
            }
            return statements;
        }
        function enableSubstitutionForAsyncMethodsWithSuper() {
            if ((enabledSubstitutions & 1) === 0) {
                enabledSubstitutions |= 1;
                context.enableSubstitution(181);
                context.enableSubstitution(179);
                context.enableSubstitution(180);
                context.enableEmitNotification(229);
                context.enableEmitNotification(151);
                context.enableEmitNotification(153);
                context.enableEmitNotification(154);
                context.enableEmitNotification(152);
            }
        }
        function onEmitNode(hint, node, emitCallback) {
            if (enabledSubstitutions & 1 && isSuperContainer(node)) {
                var superContainerFlags = resolver.getNodeCheckFlags(node) & (2048 | 4096);
                if (superContainerFlags !== enclosingSuperContainerFlags) {
                    var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                    enclosingSuperContainerFlags = superContainerFlags;
                    previousOnEmitNode(hint, node, emitCallback);
                    enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                    return;
                }
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 && enclosingSuperContainerFlags) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 179:
                    return substitutePropertyAccessExpression(node);
                case 180:
                    return substituteElementAccessExpression(node);
                case 181:
                    return substituteCallExpression(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (node.expression.kind === 97) {
                return createSuperAccessInAsyncMethod(ts.createLiteral(node.name.text), node);
            }
            return node;
        }
        function substituteElementAccessExpression(node) {
            if (node.expression.kind === 97) {
                return createSuperAccessInAsyncMethod(node.argumentExpression, node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            var expression = node.expression;
            if (ts.isSuperProperty(expression)) {
                var argumentExpression = ts.isPropertyAccessExpression(expression)
                    ? substitutePropertyAccessExpression(expression)
                    : substituteElementAccessExpression(expression);
                return ts.createCall(ts.createPropertyAccess(argumentExpression, "call"), undefined, [
                    ts.createThis()
                ].concat(node.arguments));
            }
            return node;
        }
        function isSuperContainer(node) {
            var kind = node.kind;
            return kind === 229
                || kind === 152
                || kind === 151
                || kind === 153
                || kind === 154;
        }
        function createSuperAccessInAsyncMethod(argumentExpression, location) {
            if (enclosingSuperContainerFlags & 4096) {
                return ts.setTextRange(ts.createPropertyAccess(ts.createCall(ts.createIdentifier("_super"), undefined, [argumentExpression]), "value"), location);
            }
            else {
                return ts.setTextRange(ts.createCall(ts.createIdentifier("_super"), undefined, [argumentExpression]), location);
            }
        }
    }
    ts.transformESNext = transformESNext;
    var assignHelper = {
        name: "typescript:assign",
        scoped: false,
        priority: 1,
        text: "\n            var __assign = (this && this.__assign) || Object.assign || function(t) {\n                for (var s, i = 1, n = arguments.length; i < n; i++) {\n                    s = arguments[i];\n                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                        t[p] = s[p];\n                }\n                return t;\n            };"
    };
    function createAssignHelper(context, attributesSegments) {
        if (context.getCompilerOptions().target >= 2) {
            return ts.createCall(ts.createPropertyAccess(ts.createIdentifier("Object"), "assign"), undefined, attributesSegments);
        }
        context.requestEmitHelper(assignHelper);
        return ts.createCall(ts.getHelperName("__assign"), undefined, attributesSegments);
    }
    ts.createAssignHelper = createAssignHelper;
    var awaitHelper = {
        name: "typescript:await",
        scoped: false,
        text: "\n            var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\n        "
    };
    function createAwaitHelper(context, expression) {
        context.requestEmitHelper(awaitHelper);
        return ts.createCall(ts.getHelperName("__await"), undefined, [expression]);
    }
    var asyncGeneratorHelper = {
        name: "typescript:asyncGenerator",
        scoped: false,
        text: "\n            var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n                if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n                var g = generator.apply(thisArg, _arguments || []), i, q = [];\n                return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n                function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n                function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n                function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\n                function fulfill(value) { resume(\"next\", value); }\n                function reject(value) { resume(\"throw\", value); }\n                function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n            };\n        "
    };
    function createAsyncGeneratorHelper(context, generatorFunc) {
        context.requestEmitHelper(awaitHelper);
        context.requestEmitHelper(asyncGeneratorHelper);
        (generatorFunc.emitNode || (generatorFunc.emitNode = {})).flags |= 262144;
        return ts.createCall(ts.getHelperName("__asyncGenerator"), undefined, [
            ts.createThis(),
            ts.createIdentifier("arguments"),
            generatorFunc
        ]);
    }
    var asyncDelegator = {
        name: "typescript:asyncDelegator",
        scoped: false,
        text: "\n            var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {\n                var i, p;\n                return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n                function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\n            };\n        "
    };
    function createAsyncDelegatorHelper(context, expression, location) {
        context.requestEmitHelper(awaitHelper);
        context.requestEmitHelper(asyncDelegator);
        return ts.setTextRange(ts.createCall(ts.getHelperName("__asyncDelegator"), undefined, [expression]), location);
    }
    var asyncValues = {
        name: "typescript:asyncValues",
        scoped: false,
        text: "\n            var __asyncValues = (this && this.__asyncIterator) || function (o) {\n                if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n                var m = o[Symbol.asyncIterator];\n                return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\n            };\n        "
    };
    function createAsyncValuesHelper(context, expression, location) {
        context.requestEmitHelper(asyncValues);
        return ts.setTextRange(ts.createCall(ts.getHelperName("__asyncValues"), undefined, [expression]), location);
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformJsx(context) {
        var compilerOptions = context.getCompilerOptions();
        return transformSourceFile;
        function transformSourceFile(node) {
            if (ts.isDeclarationFile(node)) {
                return node;
            }
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function visitor(node) {
            if (node.transformFlags & 4) {
                return visitorWorker(node);
            }
            else {
                return node;
            }
        }
        function visitorWorker(node) {
            switch (node.kind) {
                case 249:
                    return visitJsxElement(node, false);
                case 250:
                    return visitJsxSelfClosingElement(node, false);
                case 256:
                    return visitJsxExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformJsxChildToExpression(node) {
            switch (node.kind) {
                case 10:
                    return visitJsxText(node);
                case 256:
                    return visitJsxExpression(node);
                case 249:
                    return visitJsxElement(node, true);
                case 250:
                    return visitJsxSelfClosingElement(node, true);
                default:
                    ts.Debug.failBadSyntaxKind(node);
                    return undefined;
            }
        }
        function visitJsxElement(node, isChild) {
            return visitJsxOpeningLikeElement(node.openingElement, node.children, isChild, node);
        }
        function visitJsxSelfClosingElement(node, isChild) {
            return visitJsxOpeningLikeElement(node, undefined, isChild, node);
        }
        function visitJsxOpeningLikeElement(node, children, isChild, location) {
            var tagName = getTagName(node);
            var objectProperties;
            var attrs = node.attributes.properties;
            if (attrs.length === 0) {
                objectProperties = ts.createNull();
            }
            else {
                var segments = ts.flatten(ts.spanMap(attrs, ts.isJsxSpreadAttribute, function (attrs, isSpread) { return isSpread
                    ? ts.map(attrs, transformJsxSpreadAttributeToExpression)
                    : ts.createObjectLiteral(ts.map(attrs, transformJsxAttributeToObjectLiteralElement)); }));
                if (ts.isJsxSpreadAttribute(attrs[0])) {
                    segments.unshift(ts.createObjectLiteral());
                }
                objectProperties = ts.singleOrUndefined(segments);
                if (!objectProperties) {
                    objectProperties = ts.createAssignHelper(context, segments);
                }
            }
            var element = ts.createExpressionForJsxElement(context.getEmitResolver().getJsxFactoryEntity(), compilerOptions.reactNamespace, tagName, objectProperties, ts.filter(ts.map(children, transformJsxChildToExpression), ts.isDefined), node, location);
            if (isChild) {
                ts.startOnNewLine(element);
            }
            return element;
        }
        function transformJsxSpreadAttributeToExpression(node) {
            return ts.visitNode(node.expression, visitor, ts.isExpression);
        }
        function transformJsxAttributeToObjectLiteralElement(node) {
            var name = getAttributeName(node);
            var expression = transformJsxAttributeInitializer(node.initializer);
            return ts.createPropertyAssignment(name, expression);
        }
        function transformJsxAttributeInitializer(node) {
            if (node === undefined) {
                return ts.createTrue();
            }
            else if (node.kind === 9) {
                var decoded = tryDecodeEntities(node.text);
                return decoded ? ts.setTextRange(ts.createLiteral(decoded), node) : node;
            }
            else if (node.kind === 256) {
                if (node.expression === undefined) {
                    return ts.createTrue();
                }
                return visitJsxExpression(node);
            }
            else {
                ts.Debug.failBadSyntaxKind(node);
            }
        }
        function visitJsxText(node) {
            var fixed = fixupWhitespaceAndDecodeEntities(ts.getTextOfNode(node, true));
            return fixed === undefined ? undefined : ts.createLiteral(fixed);
        }
        function fixupWhitespaceAndDecodeEntities(text) {
            var acc;
            var firstNonWhitespace = 0;
            var lastNonWhitespace = -1;
            for (var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);
                if (ts.isLineBreak(c)) {
                    if (firstNonWhitespace !== -1 && lastNonWhitespace !== -1) {
                        acc = addLineOfJsxText(acc, text.substr(firstNonWhitespace, lastNonWhitespace - firstNonWhitespace + 1));
                    }
                    firstNonWhitespace = -1;
                }
                else if (!ts.isWhiteSpaceSingleLine(c)) {
                    lastNonWhitespace = i;
                    if (firstNonWhitespace === -1) {
                        firstNonWhitespace = i;
                    }
                }
            }
            return firstNonWhitespace !== -1
                ? addLineOfJsxText(acc, text.substr(firstNonWhitespace))
                : acc;
        }
        function addLineOfJsxText(acc, trimmedLine) {
            var decoded = decodeEntities(trimmedLine);
            return acc === undefined ? decoded : acc + " " + decoded;
        }
        function decodeEntities(text) {
            return text.replace(/&((#((\d+)|x([\da-fA-F]+)))|(\w+));/g, function (match, _all, _number, _digits, decimal, hex, word) {
                if (decimal) {
                    return String.fromCharCode(parseInt(decimal, 10));
                }
                else if (hex) {
                    return String.fromCharCode(parseInt(hex, 16));
                }
                else {
                    var ch = entities.get(word);
                    return ch ? String.fromCharCode(ch) : match;
                }
            });
        }
        function tryDecodeEntities(text) {
            var decoded = decodeEntities(text);
            return decoded === text ? undefined : decoded;
        }
        function getTagName(node) {
            if (node.kind === 249) {
                return getTagName(node.openingElement);
            }
            else {
                var name = node.tagName;
                if (ts.isIdentifier(name) && ts.isIntrinsicJsxName(name.text)) {
                    return ts.createLiteral(name.text);
                }
                else {
                    return ts.createExpressionFromEntityName(name);
                }
            }
        }
        function getAttributeName(node) {
            var name = node.name;
            if (/^[A-Za-z_]\w*$/.test(name.text)) {
                return name;
            }
            else {
                return ts.createLiteral(name.text);
            }
        }
        function visitJsxExpression(node) {
            return ts.visitNode(node.expression, visitor, ts.isExpression);
        }
    }
    ts.transformJsx = transformJsx;
    var entities = ts.createMapFromTemplate({
        "quot": 0x0022,
        "amp": 0x0026,
        "apos": 0x0027,
        "lt": 0x003C,
        "gt": 0x003E,
        "nbsp": 0x00A0,
        "iexcl": 0x00A1,
        "cent": 0x00A2,
        "pound": 0x00A3,
        "curren": 0x00A4,
        "yen": 0x00A5,
        "brvbar": 0x00A6,
        "sect": 0x00A7,
        "uml": 0x00A8,
        "copy": 0x00A9,
        "ordf": 0x00AA,
        "laquo": 0x00AB,
        "not": 0x00AC,
        "shy": 0x00AD,
        "reg": 0x00AE,
        "macr": 0x00AF,
        "deg": 0x00B0,
        "plusmn": 0x00B1,
        "sup2": 0x00B2,
        "sup3": 0x00B3,
        "acute": 0x00B4,
        "micro": 0x00B5,
        "para": 0x00B6,
        "middot": 0x00B7,
        "cedil": 0x00B8,
        "sup1": 0x00B9,
        "ordm": 0x00BA,
        "raquo": 0x00BB,
        "frac14": 0x00BC,
        "frac12": 0x00BD,
        "frac34": 0x00BE,
        "iquest": 0x00BF,
        "Agrave": 0x00C0,
        "Aacute": 0x00C1,
        "Acirc": 0x00C2,
        "Atilde": 0x00C3,
        "Auml": 0x00C4,
        "Aring": 0x00C5,
        "AElig": 0x00C6,
        "Ccedil": 0x00C7,
        "Egrave": 0x00C8,
        "Eacute": 0x00C9,
        "Ecirc": 0x00CA,
        "Euml": 0x00CB,
        "Igrave": 0x00CC,
        "Iacute": 0x00CD,
        "Icirc": 0x00CE,
        "Iuml": 0x00CF,
        "ETH": 0x00D0,
        "Ntilde": 0x00D1,
        "Ograve": 0x00D2,
        "Oacute": 0x00D3,
        "Ocirc": 0x00D4,
        "Otilde": 0x00D5,
        "Ouml": 0x00D6,
        "times": 0x00D7,
        "Oslash": 0x00D8,
        "Ugrave": 0x00D9,
        "Uacute": 0x00DA,
        "Ucirc": 0x00DB,
        "Uuml": 0x00DC,
        "Yacute": 0x00DD,
        "THORN": 0x00DE,
        "szlig": 0x00DF,
        "agrave": 0x00E0,
        "aacute": 0x00E1,
        "acirc": 0x00E2,
        "atilde": 0x00E3,
        "auml": 0x00E4,
        "aring": 0x00E5,
        "aelig": 0x00E6,
        "ccedil": 0x00E7,
        "egrave": 0x00E8,
        "eacute": 0x00E9,
        "ecirc": 0x00EA,
        "euml": 0x00EB,
        "igrave": 0x00EC,
        "iacute": 0x00ED,
        "icirc": 0x00EE,
        "iuml": 0x00EF,
        "eth": 0x00F0,
        "ntilde": 0x00F1,
        "ograve": 0x00F2,
        "oacute": 0x00F3,
        "ocirc": 0x00F4,
        "otilde": 0x00F5,
        "ouml": 0x00F6,
        "divide": 0x00F7,
        "oslash": 0x00F8,
        "ugrave": 0x00F9,
        "uacute": 0x00FA,
        "ucirc": 0x00FB,
        "uuml": 0x00FC,
        "yacute": 0x00FD,
        "thorn": 0x00FE,
        "yuml": 0x00FF,
        "OElig": 0x0152,
        "oelig": 0x0153,
        "Scaron": 0x0160,
        "scaron": 0x0161,
        "Yuml": 0x0178,
        "fnof": 0x0192,
        "circ": 0x02C6,
        "tilde": 0x02DC,
        "Alpha": 0x0391,
        "Beta": 0x0392,
        "Gamma": 0x0393,
        "Delta": 0x0394,
        "Epsilon": 0x0395,
        "Zeta": 0x0396,
        "Eta": 0x0397,
        "Theta": 0x0398,
        "Iota": 0x0399,
        "Kappa": 0x039A,
        "Lambda": 0x039B,
        "Mu": 0x039C,
        "Nu": 0x039D,
        "Xi": 0x039E,
        "Omicron": 0x039F,
        "Pi": 0x03A0,
        "Rho": 0x03A1,
        "Sigma": 0x03A3,
        "Tau": 0x03A4,
        "Upsilon": 0x03A5,
        "Phi": 0x03A6,
        "Chi": 0x03A7,
        "Psi": 0x03A8,
        "Omega": 0x03A9,
        "alpha": 0x03B1,
        "beta": 0x03B2,
        "gamma": 0x03B3,
        "delta": 0x03B4,
        "epsilon": 0x03B5,
        "zeta": 0x03B6,
        "eta": 0x03B7,
        "theta": 0x03B8,
        "iota": 0x03B9,
        "kappa": 0x03BA,
        "lambda": 0x03BB,
        "mu": 0x03BC,
        "nu": 0x03BD,
        "xi": 0x03BE,
        "omicron": 0x03BF,
        "pi": 0x03C0,
        "rho": 0x03C1,
        "sigmaf": 0x03C2,
        "sigma": 0x03C3,
        "tau": 0x03C4,
        "upsilon": 0x03C5,
        "phi": 0x03C6,
        "chi": 0x03C7,
        "psi": 0x03C8,
        "omega": 0x03C9,
        "thetasym": 0x03D1,
        "upsih": 0x03D2,
        "piv": 0x03D6,
        "ensp": 0x2002,
        "emsp": 0x2003,
        "thinsp": 0x2009,
        "zwnj": 0x200C,
        "zwj": 0x200D,
        "lrm": 0x200E,
        "rlm": 0x200F,
        "ndash": 0x2013,
        "mdash": 0x2014,
        "lsquo": 0x2018,
        "rsquo": 0x2019,
        "sbquo": 0x201A,
        "ldquo": 0x201C,
        "rdquo": 0x201D,
        "bdquo": 0x201E,
        "dagger": 0x2020,
        "Dagger": 0x2021,
        "bull": 0x2022,
        "hellip": 0x2026,
        "permil": 0x2030,
        "prime": 0x2032,
        "Prime": 0x2033,
        "lsaquo": 0x2039,
        "rsaquo": 0x203A,
        "oline": 0x203E,
        "frasl": 0x2044,
        "euro": 0x20AC,
        "image": 0x2111,
        "weierp": 0x2118,
        "real": 0x211C,
        "trade": 0x2122,
        "alefsym": 0x2135,
        "larr": 0x2190,
        "uarr": 0x2191,
        "rarr": 0x2192,
        "darr": 0x2193,
        "harr": 0x2194,
        "crarr": 0x21B5,
        "lArr": 0x21D0,
        "uArr": 0x21D1,
        "rArr": 0x21D2,
        "dArr": 0x21D3,
        "hArr": 0x21D4,
        "forall": 0x2200,
        "part": 0x2202,
        "exist": 0x2203,
        "empty": 0x2205,
        "nabla": 0x2207,
        "isin": 0x2208,
        "notin": 0x2209,
        "ni": 0x220B,
        "prod": 0x220F,
        "sum": 0x2211,
        "minus": 0x2212,
        "lowast": 0x2217,
        "radic": 0x221A,
        "prop": 0x221D,
        "infin": 0x221E,
        "ang": 0x2220,
        "and": 0x2227,
        "or": 0x2228,
        "cap": 0x2229,
        "cup": 0x222A,
        "int": 0x222B,
        "there4": 0x2234,
        "sim": 0x223C,
        "cong": 0x2245,
        "asymp": 0x2248,
        "ne": 0x2260,
        "equiv": 0x2261,
        "le": 0x2264,
        "ge": 0x2265,
        "sub": 0x2282,
        "sup": 0x2283,
        "nsub": 0x2284,
        "sube": 0x2286,
        "supe": 0x2287,
        "oplus": 0x2295,
        "otimes": 0x2297,
        "perp": 0x22A5,
        "sdot": 0x22C5,
        "lceil": 0x2308,
        "rceil": 0x2309,
        "lfloor": 0x230A,
        "rfloor": 0x230B,
        "lang": 0x2329,
        "rang": 0x232A,
        "loz": 0x25CA,
        "spades": 0x2660,
        "clubs": 0x2663,
        "hearts": 0x2665,
        "diams": 0x2666
    });
})(ts || (ts = {}));
var ts;
(function (ts) {
    function transformES2016(context) {
        var hoistVariableDeclaration = context.hoistVariableDeclaration;
        return transformSourceFile;
        function transformSourceFile(node) {
            if (ts.isDeclarationFile(node)) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 32) === 0) {
                return node;
            }
            switch (node.kind) {
                case 194:
                    return visitBinaryExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitBinaryExpression(node) {
            switch (node.operatorToken.kind) {
                case 62:
                    return visitExponentiationAssignmentExpression(node);
                case 40:
                    return visitExponentiationExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitExponentiationAssignmentExpression(node) {
            var target;
            var value;
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = ts.visitNode(node.right, visitor, ts.isExpression);
            if (ts.isElementAccessExpression(left)) {
                var expressionTemp = ts.createTempVariable(hoistVariableDeclaration);
                var argumentExpressionTemp = ts.createTempVariable(hoistVariableDeclaration);
                target = ts.setTextRange(ts.createElementAccess(ts.setTextRange(ts.createAssignment(expressionTemp, left.expression), left.expression), ts.setTextRange(ts.createAssignment(argumentExpressionTemp, left.argumentExpression), left.argumentExpression)), left);
                value = ts.setTextRange(ts.createElementAccess(expressionTemp, argumentExpressionTemp), left);
            }
            else if (ts.isPropertyAccessExpression(left)) {
                var expressionTemp = ts.createTempVariable(hoistVariableDeclaration);
                target = ts.setTextRange(ts.createPropertyAccess(ts.setTextRange(ts.createAssignment(expressionTemp, left.expression), left.expression), left.name), left);
                value = ts.setTextRange(ts.createPropertyAccess(expressionTemp, left.name), left);
            }
            else {
                target = left;
                value = left;
            }
            return ts.setTextRange(ts.createAssignment(target, ts.createMathPow(value, right, node)), node);
        }
        function visitExponentiationExpression(node) {
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = ts.visitNode(node.right, visitor, ts.isExpression);
            return ts.createMathPow(left, right, node);
        }
    }
    ts.transformES2016 = transformES2016;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var ES2015SubstitutionFlags;
    (function (ES2015SubstitutionFlags) {
        ES2015SubstitutionFlags[ES2015SubstitutionFlags["CapturedThis"] = 1] = "CapturedThis";
        ES2015SubstitutionFlags[ES2015SubstitutionFlags["BlockScopedBindings"] = 2] = "BlockScopedBindings";
    })(ES2015SubstitutionFlags || (ES2015SubstitutionFlags = {}));
    var CopyDirection;
    (function (CopyDirection) {
        CopyDirection[CopyDirection["ToOriginal"] = 0] = "ToOriginal";
        CopyDirection[CopyDirection["ToOutParameter"] = 1] = "ToOutParameter";
    })(CopyDirection || (CopyDirection = {}));
    var Jump;
    (function (Jump) {
        Jump[Jump["Break"] = 2] = "Break";
        Jump[Jump["Continue"] = 4] = "Continue";
        Jump[Jump["Return"] = 8] = "Return";
    })(Jump || (Jump = {}));
    var SuperCaptureResult;
    (function (SuperCaptureResult) {
        SuperCaptureResult[SuperCaptureResult["NoReplacement"] = 0] = "NoReplacement";
        SuperCaptureResult[SuperCaptureResult["ReplaceSuperCapture"] = 1] = "ReplaceSuperCapture";
        SuperCaptureResult[SuperCaptureResult["ReplaceWithReturn"] = 2] = "ReplaceWithReturn";
    })(SuperCaptureResult || (SuperCaptureResult = {}));
    var HierarchyFacts;
    (function (HierarchyFacts) {
        HierarchyFacts[HierarchyFacts["None"] = 0] = "None";
        HierarchyFacts[HierarchyFacts["Function"] = 1] = "Function";
        HierarchyFacts[HierarchyFacts["ArrowFunction"] = 2] = "ArrowFunction";
        HierarchyFacts[HierarchyFacts["AsyncFunctionBody"] = 4] = "AsyncFunctionBody";
        HierarchyFacts[HierarchyFacts["NonStaticClassElement"] = 8] = "NonStaticClassElement";
        HierarchyFacts[HierarchyFacts["CapturesThis"] = 16] = "CapturesThis";
        HierarchyFacts[HierarchyFacts["ExportedVariableStatement"] = 32] = "ExportedVariableStatement";
        HierarchyFacts[HierarchyFacts["TopLevel"] = 64] = "TopLevel";
        HierarchyFacts[HierarchyFacts["Block"] = 128] = "Block";
        HierarchyFacts[HierarchyFacts["IterationStatement"] = 256] = "IterationStatement";
        HierarchyFacts[HierarchyFacts["IterationStatementBlock"] = 512] = "IterationStatementBlock";
        HierarchyFacts[HierarchyFacts["ForStatement"] = 1024] = "ForStatement";
        HierarchyFacts[HierarchyFacts["ForInOrForOfStatement"] = 2048] = "ForInOrForOfStatement";
        HierarchyFacts[HierarchyFacts["ConstructorWithCapturedSuper"] = 4096] = "ConstructorWithCapturedSuper";
        HierarchyFacts[HierarchyFacts["ComputedPropertyName"] = 8192] = "ComputedPropertyName";
        HierarchyFacts[HierarchyFacts["AncestorFactsMask"] = 16383] = "AncestorFactsMask";
        HierarchyFacts[HierarchyFacts["BlockScopeIncludes"] = 0] = "BlockScopeIncludes";
        HierarchyFacts[HierarchyFacts["BlockScopeExcludes"] = 4032] = "BlockScopeExcludes";
        HierarchyFacts[HierarchyFacts["SourceFileIncludes"] = 64] = "SourceFileIncludes";
        HierarchyFacts[HierarchyFacts["SourceFileExcludes"] = 3968] = "SourceFileExcludes";
        HierarchyFacts[HierarchyFacts["FunctionIncludes"] = 65] = "FunctionIncludes";
        HierarchyFacts[HierarchyFacts["FunctionExcludes"] = 16286] = "FunctionExcludes";
        HierarchyFacts[HierarchyFacts["AsyncFunctionBodyIncludes"] = 69] = "AsyncFunctionBodyIncludes";
        HierarchyFacts[HierarchyFacts["AsyncFunctionBodyExcludes"] = 16278] = "AsyncFunctionBodyExcludes";
        HierarchyFacts[HierarchyFacts["ArrowFunctionIncludes"] = 66] = "ArrowFunctionIncludes";
        HierarchyFacts[HierarchyFacts["ArrowFunctionExcludes"] = 16256] = "ArrowFunctionExcludes";
        HierarchyFacts[HierarchyFacts["ConstructorIncludes"] = 73] = "ConstructorIncludes";
        HierarchyFacts[HierarchyFacts["ConstructorExcludes"] = 16278] = "ConstructorExcludes";
        HierarchyFacts[HierarchyFacts["DoOrWhileStatementIncludes"] = 256] = "DoOrWhileStatementIncludes";
        HierarchyFacts[HierarchyFacts["DoOrWhileStatementExcludes"] = 0] = "DoOrWhileStatementExcludes";
        HierarchyFacts[HierarchyFacts["ForStatementIncludes"] = 1280] = "ForStatementIncludes";
        HierarchyFacts[HierarchyFacts["ForStatementExcludes"] = 3008] = "ForStatementExcludes";
        HierarchyFacts[HierarchyFacts["ForInOrForOfStatementIncludes"] = 2304] = "ForInOrForOfStatementIncludes";
        HierarchyFacts[HierarchyFacts["ForInOrForOfStatementExcludes"] = 1984] = "ForInOrForOfStatementExcludes";
        HierarchyFacts[HierarchyFacts["BlockIncludes"] = 128] = "BlockIncludes";
        HierarchyFacts[HierarchyFacts["BlockExcludes"] = 3904] = "BlockExcludes";
        HierarchyFacts[HierarchyFacts["IterationStatementBlockIncludes"] = 512] = "IterationStatementBlockIncludes";
        HierarchyFacts[HierarchyFacts["IterationStatementBlockExcludes"] = 4032] = "IterationStatementBlockExcludes";
        HierarchyFacts[HierarchyFacts["ComputedPropertyNameIncludes"] = 8192] = "ComputedPropertyNameIncludes";
        HierarchyFacts[HierarchyFacts["ComputedPropertyNameExcludes"] = 0] = "ComputedPropertyNameExcludes";
        HierarchyFacts[HierarchyFacts["NewTarget"] = 16384] = "NewTarget";
        HierarchyFacts[HierarchyFacts["NewTargetInComputedPropertyName"] = 32768] = "NewTargetInComputedPropertyName";
        HierarchyFacts[HierarchyFacts["SubtreeFactsMask"] = -16384] = "SubtreeFactsMask";
        HierarchyFacts[HierarchyFacts["PropagateNewTargetMask"] = 49152] = "PropagateNewTargetMask";
    })(HierarchyFacts || (HierarchyFacts = {}));
    function transformES2015(context) {
        var startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var compilerOptions = context.getCompilerOptions();
        var resolver = context.getEmitResolver();
        var previousOnSubstituteNode = context.onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        var currentSourceFile;
        var currentText;
        var hierarchyFacts;
        var convertedLoopState;
        var enabledSubstitutions;
        return transformSourceFile;
        function transformSourceFile(node) {
            if (ts.isDeclarationFile(node)) {
                return node;
            }
            currentSourceFile = node;
            currentText = node.text;
            var visited = visitSourceFile(node);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            currentText = undefined;
            hierarchyFacts = 0;
            return visited;
        }
        function enterSubtree(excludeFacts, includeFacts) {
            var ancestorFacts = hierarchyFacts;
            hierarchyFacts = (hierarchyFacts & ~excludeFacts | includeFacts) & 16383;
            return ancestorFacts;
        }
        function exitSubtree(ancestorFacts, excludeFacts, includeFacts) {
            hierarchyFacts = (hierarchyFacts & ~excludeFacts | includeFacts) & -16384 | ancestorFacts;
        }
        function isReturnVoidStatementInConstructorWithCapturedSuper(node) {
            return hierarchyFacts & 4096
                && node.kind === 219
                && !node.expression;
        }
        function shouldVisitNode(node) {
            return (node.transformFlags & 128) !== 0
                || convertedLoopState !== undefined
                || (hierarchyFacts & 4096 && ts.isStatement(node))
                || (ts.isIterationStatement(node, false) && shouldConvertIterationStatementBody(node));
        }
        function visitor(node) {
            if (shouldVisitNode(node)) {
                return visitJavaScript(node);
            }
            else {
                return node;
            }
        }
        function functionBodyVisitor(node) {
            if (shouldVisitNode(node)) {
                return visitBlock(node, true);
            }
            return node;
        }
        function callExpressionVisitor(node) {
            if (node.kind === 97) {
                return visitSuperKeyword(true);
            }
            return visitor(node);
        }
        function visitJavaScript(node) {
            switch (node.kind) {
                case 115:
                    return undefined;
                case 229:
                    return visitClassDeclaration(node);
                case 199:
                    return visitClassExpression(node);
                case 146:
                    return visitParameter(node);
                case 228:
                    return visitFunctionDeclaration(node);
                case 187:
                    return visitArrowFunction(node);
                case 186:
                    return visitFunctionExpression(node);
                case 226:
                    return visitVariableDeclaration(node);
                case 71:
                    return visitIdentifier(node);
                case 227:
                    return visitVariableDeclarationList(node);
                case 221:
                    return visitSwitchStatement(node);
                case 235:
                    return visitCaseBlock(node);
                case 207:
                    return visitBlock(node, false);
                case 218:
                case 217:
                    return visitBreakOrContinueStatement(node);
                case 222:
                    return visitLabeledStatement(node);
                case 212:
                case 213:
                    return visitDoOrWhileStatement(node, undefined);
                case 214:
                    return visitForStatement(node, undefined);
                case 215:
                    return visitForInStatement(node, undefined);
                case 216:
                    return visitForOfStatement(node, undefined);
                case 210:
                    return visitExpressionStatement(node);
                case 178:
                    return visitObjectLiteralExpression(node);
                case 260:
                    return visitCatchClause(node);
                case 262:
                    return visitShorthandPropertyAssignment(node);
                case 144:
                    return visitComputedPropertyName(node);
                case 177:
                    return visitArrayLiteralExpression(node);
                case 181:
                    return visitCallExpression(node);
                case 182:
                    return visitNewExpression(node);
                case 185:
                    return visitParenthesizedExpression(node, true);
                case 194:
                    return visitBinaryExpression(node, true);
                case 13:
                case 14:
                case 15:
                case 16:
                    return visitTemplateLiteral(node);
                case 9:
                    return visitStringLiteral(node);
                case 8:
                    return visitNumericLiteral(node);
                case 183:
                    return visitTaggedTemplateExpression(node);
                case 196:
                    return visitTemplateExpression(node);
                case 197:
                    return visitYieldExpression(node);
                case 198:
                    return visitSpreadElement(node);
                case 97:
                    return visitSuperKeyword(false);
                case 99:
                    return visitThisKeyword(node);
                case 204:
                    return visitMetaProperty(node);
                case 151:
                    return visitMethodDeclaration(node);
                case 153:
                case 154:
                    return visitAccessorDeclaration(node);
                case 208:
                    return visitVariableStatement(node);
                case 219:
                    return visitReturnStatement(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitSourceFile(node) {
            var ancestorFacts = enterSubtree(3968, 64);
            var statements = [];
            startLexicalEnvironment();
            var statementOffset = ts.addStandardPrologue(statements, node.statements, false);
            addCaptureThisForNodeIfNeeded(statements, node);
            statementOffset = ts.addCustomPrologue(statements, node.statements, statementOffset, visitor);
            ts.addRange(statements, ts.visitNodes(node.statements, visitor, ts.isStatement, statementOffset));
            ts.addRange(statements, endLexicalEnvironment());
            exitSubtree(ancestorFacts, 0, 0);
            return ts.updateSourceFileNode(node, ts.setTextRange(ts.createNodeArray(statements), node.statements));
        }
        function visitSwitchStatement(node) {
            if (convertedLoopState !== undefined) {
                var savedAllowedNonLabeledJumps = convertedLoopState.allowedNonLabeledJumps;
                convertedLoopState.allowedNonLabeledJumps |= 2;
                var result = ts.visitEachChild(node, visitor, context);
                convertedLoopState.allowedNonLabeledJumps = savedAllowedNonLabeledJumps;
                return result;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCaseBlock(node) {
            var ancestorFacts = enterSubtree(4032, 0);
            var updated = ts.visitEachChild(node, visitor, context);
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function returnCapturedThis(node) {
            return ts.setOriginalNode(ts.createReturn(ts.createIdentifier("_this")), node);
        }
        function visitReturnStatement(node) {
            if (convertedLoopState) {
                convertedLoopState.nonLocalJumps |= 8;
                if (isReturnVoidStatementInConstructorWithCapturedSuper(node)) {
                    node = returnCapturedThis(node);
                }
                return ts.createReturn(ts.createObjectLiteral([
                    ts.createPropertyAssignment(ts.createIdentifier("value"), node.expression
                        ? ts.visitNode(node.expression, visitor, ts.isExpression)
                        : ts.createVoidZero())
                ]));
            }
            else if (isReturnVoidStatementInConstructorWithCapturedSuper(node)) {
                return returnCapturedThis(node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitThisKeyword(node) {
            if (convertedLoopState) {
                if (hierarchyFacts & 2) {
                    convertedLoopState.containsLexicalThis = true;
                    return node;
                }
                return convertedLoopState.thisName || (convertedLoopState.thisName = ts.createUniqueName("this"));
            }
            return node;
        }
        function visitIdentifier(node) {
            if (!convertedLoopState) {
                return node;
            }
            if (ts.isGeneratedIdentifier(node)) {
                return node;
            }
            if (node.text !== "arguments" || !resolver.isArgumentsLocalBinding(node)) {
                return node;
            }
            return convertedLoopState.argumentsName || (convertedLoopState.argumentsName = ts.createUniqueName("arguments"));
        }
        function visitBreakOrContinueStatement(node) {
            if (convertedLoopState) {
                var jump = node.kind === 218 ? 2 : 4;
                var canUseBreakOrContinue = (node.label && convertedLoopState.labels && convertedLoopState.labels.get(node.label.text)) ||
                    (!node.label && (convertedLoopState.allowedNonLabeledJumps & jump));
                if (!canUseBreakOrContinue) {
                    var labelMarker = void 0;
                    if (!node.label) {
                        if (node.kind === 218) {
                            convertedLoopState.nonLocalJumps |= 2;
                            labelMarker = "break";
                        }
                        else {
                            convertedLoopState.nonLocalJumps |= 4;
                            labelMarker = "continue";
                        }
                    }
                    else {
                        if (node.kind === 218) {
                            labelMarker = "break-" + node.label.text;
                            setLabeledJump(convertedLoopState, true, node.label.text, labelMarker);
                        }
                        else {
                            labelMarker = "continue-" + node.label.text;
                            setLabeledJump(convertedLoopState, false, node.label.text, labelMarker);
                        }
                    }
                    var returnExpression = ts.createLiteral(labelMarker);
                    if (convertedLoopState.loopOutParameters.length) {
                        var outParams = convertedLoopState.loopOutParameters;
                        var expr = void 0;
                        for (var i = 0; i < outParams.length; i++) {
                            var copyExpr = copyOutParameter(outParams[i], 1);
                            if (i === 0) {
                                expr = copyExpr;
                            }
                            else {
                                expr = ts.createBinary(expr, 26, copyExpr);
                            }
                        }
                        returnExpression = ts.createBinary(expr, 26, returnExpression);
                    }
                    return ts.createReturn(returnExpression);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitClassDeclaration(node) {
            var variable = ts.createVariableDeclaration(ts.getLocalName(node, true), undefined, transformClassLikeDeclarationToExpression(node));
            ts.setOriginalNode(variable, node);
            var statements = [];
            var statement = ts.createVariableStatement(undefined, ts.createVariableDeclarationList([variable]));
            ts.setOriginalNode(statement, node);
            ts.setTextRange(statement, node);
            ts.startOnNewLine(statement);
            statements.push(statement);
            if (ts.hasModifier(node, 1)) {
                var exportStatement = ts.hasModifier(node, 512)
                    ? ts.createExportDefault(ts.getLocalName(node))
                    : ts.createExternalModuleExport(ts.getLocalName(node));
                ts.setOriginalNode(exportStatement, statement);
                statements.push(exportStatement);
            }
            var emitFlags = ts.getEmitFlags(node);
            if ((emitFlags & 4194304) === 0) {
                statements.push(ts.createEndOfDeclarationMarker(node));
                ts.setEmitFlags(statement, emitFlags | 4194304);
            }
            return ts.singleOrMany(statements);
        }
        function visitClassExpression(node) {
            return transformClassLikeDeclarationToExpression(node);
        }
        function transformClassLikeDeclarationToExpression(node) {
            if (node.name) {
                enableSubstitutionsForBlockScopedBindings();
            }
            var extendsClauseElement = ts.getClassExtendsHeritageClauseElement(node);
            var classFunction = ts.createFunctionExpression(undefined, undefined, undefined, undefined, extendsClauseElement ? [ts.createParameter(undefined, undefined, undefined, "_super")] : [], undefined, transformClassBody(node, extendsClauseElement));
            if (ts.getEmitFlags(node) & 65536) {
                ts.setEmitFlags(classFunction, 65536);
            }
            var inner = ts.createPartiallyEmittedExpression(classFunction);
            inner.end = node.end;
            ts.setEmitFlags(inner, 1536);
            var outer = ts.createPartiallyEmittedExpression(inner);
            outer.end = ts.skipTrivia(currentText, node.pos);
            ts.setEmitFlags(outer, 1536);
            return ts.createParen(ts.createCall(outer, undefined, extendsClauseElement
                ? [ts.visitNode(extendsClauseElement.expression, visitor, ts.isExpression)]
                : []));
        }
        function transformClassBody(node, extendsClauseElement) {
            var statements = [];
            startLexicalEnvironment();
            addExtendsHelperIfNeeded(statements, node, extendsClauseElement);
            addConstructor(statements, node, extendsClauseElement);
            addClassMembers(statements, node);
            var closingBraceLocation = ts.createTokenRange(ts.skipTrivia(currentText, node.members.end), 18);
            var localName = ts.getInternalName(node);
            var outer = ts.createPartiallyEmittedExpression(localName);
            outer.end = closingBraceLocation.end;
            ts.setEmitFlags(outer, 1536);
            var statement = ts.createReturn(outer);
            statement.pos = closingBraceLocation.pos;
            ts.setEmitFlags(statement, 1536 | 384);
            statements.push(statement);
            ts.addRange(statements, endLexicalEnvironment());
            var block = ts.createBlock(ts.setTextRange(ts.createNodeArray(statements), node.members), true);
            ts.setEmitFlags(block, 1536);
            return block;
        }
        function addExtendsHelperIfNeeded(statements, node, extendsClauseElement) {
            if (extendsClauseElement) {
                statements.push(ts.setTextRange(ts.createStatement(createExtendsHelper(context, ts.getLocalName(node))), extendsClauseElement));
            }
        }
        function addConstructor(statements, node, extendsClauseElement) {
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(16278, 73);
            var constructor = ts.getFirstConstructorWithBody(node);
            var hasSynthesizedSuper = hasSynthesizedDefaultSuperCall(constructor, extendsClauseElement !== undefined);
            var constructorFunction = ts.createFunctionDeclaration(undefined, undefined, undefined, ts.getInternalName(node), undefined, transformConstructorParameters(constructor, hasSynthesizedSuper), undefined, transformConstructorBody(constructor, node, extendsClauseElement, hasSynthesizedSuper));
            ts.setTextRange(constructorFunction, constructor || node);
            if (extendsClauseElement) {
                ts.setEmitFlags(constructorFunction, 8);
            }
            statements.push(constructorFunction);
            exitSubtree(ancestorFacts, 49152, 0);
            convertedLoopState = savedConvertedLoopState;
        }
        function transformConstructorParameters(constructor, hasSynthesizedSuper) {
            return ts.visitParameterList(constructor && !hasSynthesizedSuper && constructor.parameters, visitor, context)
                || [];
        }
        function transformConstructorBody(constructor, node, extendsClauseElement, hasSynthesizedSuper) {
            var statements = [];
            resumeLexicalEnvironment();
            var statementOffset = -1;
            if (hasSynthesizedSuper) {
                statementOffset = 0;
            }
            else if (constructor) {
                statementOffset = ts.addStandardPrologue(statements, constructor.body.statements, false);
            }
            if (constructor) {
                addDefaultValueAssignmentsIfNeeded(statements, constructor);
                addRestParameterIfNeeded(statements, constructor, hasSynthesizedSuper);
                if (!hasSynthesizedSuper) {
                    statementOffset = ts.addCustomPrologue(statements, constructor.body.statements, statementOffset, visitor);
                }
                ts.Debug.assert(statementOffset >= 0, "statementOffset not initialized correctly!");
            }
            var isDerivedClass = extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 95;
            var superCaptureStatus = declareOrCaptureOrReturnThisForConstructorIfNeeded(statements, constructor, isDerivedClass, hasSynthesizedSuper, statementOffset);
            if (superCaptureStatus === 1 || superCaptureStatus === 2) {
                statementOffset++;
            }
            if (constructor) {
                if (superCaptureStatus === 1) {
                    hierarchyFacts |= 4096;
                }
                ts.addRange(statements, ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, statementOffset));
            }
            if (isDerivedClass
                && superCaptureStatus !== 2
                && !(constructor && isSufficientlyCoveredByReturnStatements(constructor.body))) {
                statements.push(ts.createReturn(ts.createIdentifier("_this")));
            }
            ts.addRange(statements, endLexicalEnvironment());
            if (constructor) {
                prependCaptureNewTargetIfNeeded(statements, constructor, false);
            }
            var block = ts.createBlock(ts.setTextRange(ts.createNodeArray(statements), constructor ? constructor.body.statements : node.members), true);
            ts.setTextRange(block, constructor ? constructor.body : node);
            if (!constructor) {
                ts.setEmitFlags(block, 1536);
            }
            return block;
        }
        function isSufficientlyCoveredByReturnStatements(statement) {
            if (statement.kind === 219) {
                return true;
            }
            else if (statement.kind === 211) {
                var ifStatement = statement;
                if (ifStatement.elseStatement) {
                    return isSufficientlyCoveredByReturnStatements(ifStatement.thenStatement) &&
                        isSufficientlyCoveredByReturnStatements(ifStatement.elseStatement);
                }
            }
            else if (statement.kind === 207) {
                var lastStatement = ts.lastOrUndefined(statement.statements);
                if (lastStatement && isSufficientlyCoveredByReturnStatements(lastStatement)) {
                    return true;
                }
            }
            return false;
        }
        function declareOrCaptureOrReturnThisForConstructorIfNeeded(statements, ctor, isDerivedClass, hasSynthesizedSuper, statementOffset) {
            if (!isDerivedClass) {
                if (ctor) {
                    addCaptureThisForNodeIfNeeded(statements, ctor);
                }
                return 0;
            }
            if (!ctor) {
                statements.push(ts.createReturn(createDefaultSuperCallOrThis()));
                return 2;
            }
            if (hasSynthesizedSuper) {
                captureThisForNode(statements, ctor, createDefaultSuperCallOrThis());
                enableSubstitutionsForCapturedThis();
                return 1;
            }
            var firstStatement;
            var superCallExpression;
            var ctorStatements = ctor.body.statements;
            if (statementOffset < ctorStatements.length) {
                firstStatement = ctorStatements[statementOffset];
                if (firstStatement.kind === 210 && ts.isSuperCall(firstStatement.expression)) {
                    superCallExpression = visitImmediateSuperCallInBody(firstStatement.expression);
                }
            }
            if (superCallExpression
                && statementOffset === ctorStatements.length - 1
                && !(ctor.transformFlags & (16384 | 32768))) {
                var returnStatement = ts.createReturn(superCallExpression);
                if (superCallExpression.kind !== 194
                    || superCallExpression.left.kind !== 181) {
                    ts.Debug.fail("Assumed generated super call would have form 'super.call(...) || this'.");
                }
                ts.setCommentRange(returnStatement, ts.getCommentRange(ts.setEmitFlags(superCallExpression.left, 1536)));
                statements.push(returnStatement);
                return 2;
            }
            captureThisForNode(statements, ctor, superCallExpression || createActualThis(), firstStatement);
            if (superCallExpression) {
                return 1;
            }
            return 0;
        }
        function createActualThis() {
            return ts.setEmitFlags(ts.createThis(), 4);
        }
        function createDefaultSuperCallOrThis() {
            return ts.createLogicalOr(ts.createLogicalAnd(ts.createStrictInequality(ts.createIdentifier("_super"), ts.createNull()), ts.createFunctionApply(ts.createIdentifier("_super"), createActualThis(), ts.createIdentifier("arguments"))), createActualThis());
        }
        function visitParameter(node) {
            if (node.dotDotDotToken) {
                return undefined;
            }
            else if (ts.isBindingPattern(node.name)) {
                return ts.setOriginalNode(ts.setTextRange(ts.createParameter(undefined, undefined, undefined, ts.getGeneratedNameForNode(node), undefined, undefined, undefined), node), node);
            }
            else if (node.initializer) {
                return ts.setOriginalNode(ts.setTextRange(ts.createParameter(undefined, undefined, undefined, node.name, undefined, undefined, undefined), node), node);
            }
            else {
                return node;
            }
        }
        function shouldAddDefaultValueAssignments(node) {
            return (node.transformFlags & 131072) !== 0;
        }
        function addDefaultValueAssignmentsIfNeeded(statements, node) {
            if (!shouldAddDefaultValueAssignments(node)) {
                return;
            }
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                var name = parameter.name, initializer = parameter.initializer, dotDotDotToken = parameter.dotDotDotToken;
                if (dotDotDotToken) {
                    continue;
                }
                if (ts.isBindingPattern(name)) {
                    addDefaultValueAssignmentForBindingPattern(statements, parameter, name, initializer);
                }
                else if (initializer) {
                    addDefaultValueAssignmentForInitializer(statements, parameter, name, initializer);
                }
            }
        }
        function addDefaultValueAssignmentForBindingPattern(statements, parameter, name, initializer) {
            var temp = ts.getGeneratedNameForNode(parameter);
            if (name.elements.length > 0) {
                statements.push(ts.setEmitFlags(ts.createVariableStatement(undefined, ts.createVariableDeclarationList(ts.flattenDestructuringBinding(parameter, visitor, context, 0, temp))), 1048576));
            }
            else if (initializer) {
                statements.push(ts.setEmitFlags(ts.createStatement(ts.createAssignment(temp, ts.visitNode(initializer, visitor, ts.isExpression))), 1048576));
            }
        }
        function addDefaultValueAssignmentForInitializer(statements, parameter, name, initializer) {
            initializer = ts.visitNode(initializer, visitor, ts.isExpression);
            var statement = ts.createIf(ts.createTypeCheck(ts.getSynthesizedClone(name), "undefined"), ts.setEmitFlags(ts.setTextRange(ts.createBlock([
                ts.createStatement(ts.setTextRange(ts.createAssignment(ts.setEmitFlags(ts.getMutableClone(name), 48), ts.setEmitFlags(initializer, 48 | ts.getEmitFlags(initializer))), parameter))
            ]), parameter), 1 | 32 | 384));
            statement.startsOnNewLine = true;
            ts.setTextRange(statement, parameter);
            ts.setEmitFlags(statement, 384 | 32 | 1048576);
            statements.push(statement);
        }
        function shouldAddRestParameter(node, inConstructorWithSynthesizedSuper) {
            return node && node.dotDotDotToken && node.name.kind === 71 && !inConstructorWithSynthesizedSuper;
        }
        function addRestParameterIfNeeded(statements, node, inConstructorWithSynthesizedSuper) {
            var parameter = ts.lastOrUndefined(node.parameters);
            if (!shouldAddRestParameter(parameter, inConstructorWithSynthesizedSuper)) {
                return;
            }
            var declarationName = ts.getMutableClone(parameter.name);
            ts.setEmitFlags(declarationName, 48);
            var expressionName = ts.getSynthesizedClone(parameter.name);
            var restIndex = node.parameters.length - 1;
            var temp = ts.createLoopVariable();
            statements.push(ts.setEmitFlags(ts.setTextRange(ts.createVariableStatement(undefined, ts.createVariableDeclarationList([
                ts.createVariableDeclaration(declarationName, undefined, ts.createArrayLiteral([]))
            ])), parameter), 1048576));
            var forStatement = ts.createFor(ts.setTextRange(ts.createVariableDeclarationList([
                ts.createVariableDeclaration(temp, undefined, ts.createLiteral(restIndex))
            ]), parameter), ts.setTextRange(ts.createLessThan(temp, ts.createPropertyAccess(ts.createIdentifier("arguments"), "length")), parameter), ts.setTextRange(ts.createPostfixIncrement(temp), parameter), ts.createBlock([
                ts.startOnNewLine(ts.setTextRange(ts.createStatement(ts.createAssignment(ts.createElementAccess(expressionName, restIndex === 0
                    ? temp
                    : ts.createSubtract(temp, ts.createLiteral(restIndex))), ts.createElementAccess(ts.createIdentifier("arguments"), temp))), parameter))
            ]));
            ts.setEmitFlags(forStatement, 1048576);
            ts.startOnNewLine(forStatement);
            statements.push(forStatement);
        }
        function addCaptureThisForNodeIfNeeded(statements, node) {
            if (node.transformFlags & 32768 && node.kind !== 187) {
                captureThisForNode(statements, node, ts.createThis());
            }
        }
        function captureThisForNode(statements, node, initializer, originalStatement) {
            enableSubstitutionsForCapturedThis();
            var captureThisStatement = ts.createVariableStatement(undefined, ts.createVariableDeclarationList([
                ts.createVariableDeclaration("_this", undefined, initializer)
            ]));
            ts.setEmitFlags(captureThisStatement, 1536 | 1048576);
            ts.setTextRange(captureThisStatement, originalStatement);
            ts.setSourceMapRange(captureThisStatement, node);
            statements.push(captureThisStatement);
        }
        function prependCaptureNewTargetIfNeeded(statements, node, copyOnWrite) {
            if (hierarchyFacts & 16384) {
                var newTarget = void 0;
                switch (node.kind) {
                    case 187:
                        return statements;
                    case 151:
                    case 153:
                    case 154:
                        newTarget = ts.createVoidZero();
                        break;
                    case 152:
                        newTarget = ts.createPropertyAccess(ts.setEmitFlags(ts.createThis(), 4), "constructor");
                        break;
                    case 228:
                    case 186:
                        newTarget = ts.createConditional(ts.createLogicalAnd(ts.setEmitFlags(ts.createThis(), 4), ts.createBinary(ts.setEmitFlags(ts.createThis(), 4), 93, ts.getLocalName(node))), ts.createPropertyAccess(ts.setEmitFlags(ts.createThis(), 4), "constructor"), ts.createVoidZero());
                        break;
                    default:
                        ts.Debug.failBadSyntaxKind(node);
                        break;
                }
                var captureNewTargetStatement = ts.createVariableStatement(undefined, ts.createVariableDeclarationList([
                    ts.createVariableDeclaration("_newTarget", undefined, newTarget)
                ]));
                if (copyOnWrite) {
                    return [captureNewTargetStatement].concat(statements);
                }
                statements.unshift(captureNewTargetStatement);
            }
            return statements;
        }
        function addClassMembers(statements, node) {
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                switch (member.kind) {
                    case 206:
                        statements.push(transformSemicolonClassElementToStatement(member));
                        break;
                    case 151:
                        statements.push(transformClassMethodDeclarationToStatement(getClassMemberPrefix(node, member), member, node));
                        break;
                    case 153:
                    case 154:
                        var accessors = ts.getAllAccessorDeclarations(node.members, member);
                        if (member === accessors.firstAccessor) {
                            statements.push(transformAccessorsToStatement(getClassMemberPrefix(node, member), accessors, node));
                        }
                        break;
                    case 152:
                        break;
                    default:
                        ts.Debug.failBadSyntaxKind(node);
                        break;
                }
            }
        }
        function transformSemicolonClassElementToStatement(member) {
            return ts.setTextRange(ts.createEmptyStatement(), member);
        }
        function transformClassMethodDeclarationToStatement(receiver, member, container) {
            var ancestorFacts = enterSubtree(0, 0);
            var commentRange = ts.getCommentRange(member);
            var sourceMapRange = ts.getSourceMapRange(member);
            var memberName = ts.createMemberAccessForPropertyName(receiver, ts.visitNode(member.name, visitor, ts.isPropertyName), member.name);
            var memberFunction = transformFunctionLikeToExpression(member, member, undefined, container);
            ts.setEmitFlags(memberFunction, 1536);
            ts.setSourceMapRange(memberFunction, sourceMapRange);
            var statement = ts.setTextRange(ts.createStatement(ts.createAssignment(memberName, memberFunction)), member);
            ts.setOriginalNode(statement, member);
            ts.setCommentRange(statement, commentRange);
            ts.setEmitFlags(statement, 48);
            exitSubtree(ancestorFacts, 49152, hierarchyFacts & 49152 ? 16384 : 0);
            return statement;
        }
        function transformAccessorsToStatement(receiver, accessors, container) {
            var statement = ts.createStatement(transformAccessorsToExpression(receiver, accessors, container, false));
            ts.setEmitFlags(statement, 1536);
            ts.setSourceMapRange(statement, ts.getSourceMapRange(accessors.firstAccessor));
            return statement;
        }
        function transformAccessorsToExpression(receiver, _a, container, startsOnNewLine) {
            var firstAccessor = _a.firstAccessor, getAccessor = _a.getAccessor, setAccessor = _a.setAccessor;
            var ancestorFacts = enterSubtree(0, 0);
            var target = ts.getMutableClone(receiver);
            ts.setEmitFlags(target, 1536 | 32);
            ts.setSourceMapRange(target, firstAccessor.name);
            var propertyName = ts.createExpressionForPropertyName(ts.visitNode(firstAccessor.name, visitor, ts.isPropertyName));
            ts.setEmitFlags(propertyName, 1536 | 16);
            ts.setSourceMapRange(propertyName, firstAccessor.name);
            var properties = [];
            if (getAccessor) {
                var getterFunction = transformFunctionLikeToExpression(getAccessor, undefined, undefined, container);
                ts.setSourceMapRange(getterFunction, ts.getSourceMapRange(getAccessor));
                ts.setEmitFlags(getterFunction, 512);
                var getter = ts.createPropertyAssignment("get", getterFunction);
                ts.setCommentRange(getter, ts.getCommentRange(getAccessor));
                properties.push(getter);
            }
            if (setAccessor) {
                var setterFunction = transformFunctionLikeToExpression(setAccessor, undefined, undefined, container);
                ts.setSourceMapRange(setterFunction, ts.getSourceMapRange(setAccessor));
                ts.setEmitFlags(setterFunction, 512);
                var setter = ts.createPropertyAssignment("set", setterFunction);
                ts.setCommentRange(setter, ts.getCommentRange(setAccessor));
                properties.push(setter);
            }
            properties.push(ts.createPropertyAssignment("enumerable", ts.createTrue()), ts.createPropertyAssignment("configurable", ts.createTrue()));
            var call = ts.createCall(ts.createPropertyAccess(ts.createIdentifier("Object"), "defineProperty"), undefined, [
                target,
                propertyName,
                ts.createObjectLiteral(properties, true)
            ]);
            if (startsOnNewLine) {
                call.startsOnNewLine = true;
            }
            exitSubtree(ancestorFacts, 49152, hierarchyFacts & 49152 ? 16384 : 0);
            return call;
        }
        function visitArrowFunction(node) {
            if (node.transformFlags & 16384) {
                enableSubstitutionsForCapturedThis();
            }
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(16256, 66);
            var func = ts.createFunctionExpression(undefined, undefined, undefined, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, transformFunctionBody(node));
            ts.setTextRange(func, node);
            ts.setOriginalNode(func, node);
            ts.setEmitFlags(func, 8);
            exitSubtree(ancestorFacts, 0, 0);
            convertedLoopState = savedConvertedLoopState;
            return func;
        }
        function visitFunctionExpression(node) {
            var ancestorFacts = ts.getEmitFlags(node) & 262144
                ? enterSubtree(16278, 69)
                : enterSubtree(16286, 65);
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = node.transformFlags & 64
                ? transformFunctionBody(node)
                : visitFunctionBodyDownLevel(node);
            var name = hierarchyFacts & 16384
                ? ts.getLocalName(node)
                : node.name;
            exitSubtree(ancestorFacts, 49152, 0);
            convertedLoopState = savedConvertedLoopState;
            return ts.updateFunctionExpression(node, undefined, node.asteriskToken, name, undefined, parameters, undefined, body);
        }
        function visitFunctionDeclaration(node) {
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(16286, 65);
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = node.transformFlags & 64
                ? transformFunctionBody(node)
                : visitFunctionBodyDownLevel(node);
            var name = hierarchyFacts & 16384
                ? ts.getLocalName(node)
                : node.name;
            exitSubtree(ancestorFacts, 49152, 0);
            convertedLoopState = savedConvertedLoopState;
            return ts.updateFunctionDeclaration(node, undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, name, undefined, parameters, undefined, body);
        }
        function transformFunctionLikeToExpression(node, location, name, container) {
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = container && ts.isClassLike(container) && !ts.hasModifier(node, 32)
                ? enterSubtree(16286, 65 | 8)
                : enterSubtree(16286, 65);
            var parameters = ts.visitParameterList(node.parameters, visitor, context);
            var body = transformFunctionBody(node);
            if (hierarchyFacts & 16384 && !name && (node.kind === 228 || node.kind === 186)) {
                name = ts.getGeneratedNameForNode(node);
            }
            exitSubtree(ancestorFacts, 49152, 0);
            convertedLoopState = savedConvertedLoopState;
            return ts.setOriginalNode(ts.setTextRange(ts.createFunctionExpression(undefined, node.asteriskToken, name, undefined, parameters, undefined, body), location), node);
        }
        function transformFunctionBody(node) {
            var multiLine = false;
            var singleLine = false;
            var statementsLocation;
            var closeBraceLocation;
            var statements = [];
            var body = node.body;
            var statementOffset;
            resumeLexicalEnvironment();
            if (ts.isBlock(body)) {
                statementOffset = ts.addStandardPrologue(statements, body.statements, false);
            }
            addCaptureThisForNodeIfNeeded(statements, node);
            addDefaultValueAssignmentsIfNeeded(statements, node);
            addRestParameterIfNeeded(statements, node, false);
            if (!multiLine && statements.length > 0) {
                multiLine = true;
            }
            if (ts.isBlock(body)) {
                statementOffset = ts.addCustomPrologue(statements, body.statements, statementOffset, visitor);
                statementsLocation = body.statements;
                ts.addRange(statements, ts.visitNodes(body.statements, visitor, ts.isStatement, statementOffset));
                if (!multiLine && body.multiLine) {
                    multiLine = true;
                }
            }
            else {
                ts.Debug.assert(node.kind === 187);
                statementsLocation = ts.moveRangeEnd(body, -1);
                var equalsGreaterThanToken = node.equalsGreaterThanToken;
                if (!ts.nodeIsSynthesized(equalsGreaterThanToken) && !ts.nodeIsSynthesized(body)) {
                    if (ts.rangeEndIsOnSameLineAsRangeStart(equalsGreaterThanToken, body, currentSourceFile)) {
                        singleLine = true;
                    }
                    else {
                        multiLine = true;
                    }
                }
                var expression = ts.visitNode(body, visitor, ts.isExpression);
                var returnStatement = ts.createReturn(expression);
                ts.setTextRange(returnStatement, body);
                ts.setEmitFlags(returnStatement, 384 | 32 | 1024);
                statements.push(returnStatement);
                closeBraceLocation = body;
            }
            var lexicalEnvironment = context.endLexicalEnvironment();
            ts.addRange(statements, lexicalEnvironment);
            prependCaptureNewTargetIfNeeded(statements, node, false);
            if (!multiLine && lexicalEnvironment && lexicalEnvironment.length) {
                multiLine = true;
            }
            var block = ts.createBlock(ts.setTextRange(ts.createNodeArray(statements), statementsLocation), multiLine);
            ts.setTextRange(block, node.body);
            if (!multiLine && singleLine) {
                ts.setEmitFlags(block, 1);
            }
            if (closeBraceLocation) {
                ts.setTokenSourceMapRange(block, 18, closeBraceLocation);
            }
            ts.setOriginalNode(block, node.body);
            return block;
        }
        function visitFunctionBodyDownLevel(node) {
            var updated = ts.visitFunctionBody(node.body, functionBodyVisitor, context);
            return ts.updateBlock(updated, ts.setTextRange(ts.createNodeArray(prependCaptureNewTargetIfNeeded(updated.statements, node, true)), updated.statements));
        }
        function visitBlock(node, isFunctionBody) {
            if (isFunctionBody) {
                return ts.visitEachChild(node, visitor, context);
            }
            var ancestorFacts = hierarchyFacts & 256
                ? enterSubtree(4032, 512)
                : enterSubtree(3904, 128);
            var updated = ts.visitEachChild(node, visitor, context);
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function visitExpressionStatement(node) {
            switch (node.expression.kind) {
                case 185:
                    return ts.updateStatement(node, visitParenthesizedExpression(node.expression, false));
                case 194:
                    return ts.updateStatement(node, visitBinaryExpression(node.expression, false));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitParenthesizedExpression(node, needsDestructuringValue) {
            if (!needsDestructuringValue) {
                switch (node.expression.kind) {
                    case 185:
                        return ts.updateParen(node, visitParenthesizedExpression(node.expression, false));
                    case 194:
                        return ts.updateParen(node, visitBinaryExpression(node.expression, false));
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitBinaryExpression(node, needsDestructuringValue) {
            if (ts.isDestructuringAssignment(node)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0, needsDestructuringValue);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableStatement(node) {
            var ancestorFacts = enterSubtree(0, ts.hasModifier(node, 1) ? 32 : 0);
            var updated;
            if (convertedLoopState && (node.declarationList.flags & 3) === 0) {
                var assignments = void 0;
                for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    hoistVariableDeclarationDeclaredInConvertedLoop(convertedLoopState, decl);
                    if (decl.initializer) {
                        var assignment = void 0;
                        if (ts.isBindingPattern(decl.name)) {
                            assignment = ts.flattenDestructuringAssignment(decl, visitor, context, 0);
                        }
                        else {
                            assignment = ts.createBinary(decl.name, 58, ts.visitNode(decl.initializer, visitor, ts.isExpression));
                        }
                        assignments = ts.append(assignments, assignment);
                    }
                }
                if (assignments) {
                    updated = ts.setTextRange(ts.createStatement(ts.reduceLeft(assignments, function (acc, v) { return ts.createBinary(v, 26, acc); })), node);
                }
                else {
                    updated = undefined;
                }
            }
            else {
                updated = ts.visitEachChild(node, visitor, context);
            }
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function visitVariableDeclarationList(node) {
            if (node.transformFlags & 64) {
                if (node.flags & 3) {
                    enableSubstitutionsForBlockScopedBindings();
                }
                var declarations = ts.flatten(ts.map(node.declarations, node.flags & 1
                    ? visitVariableDeclarationInLetDeclarationList
                    : visitVariableDeclaration));
                var declarationList = ts.createVariableDeclarationList(declarations);
                ts.setOriginalNode(declarationList, node);
                ts.setTextRange(declarationList, node);
                ts.setCommentRange(declarationList, node);
                if (node.transformFlags & 8388608
                    && (ts.isBindingPattern(node.declarations[0].name)
                        || ts.isBindingPattern(ts.lastOrUndefined(node.declarations).name))) {
                    var firstDeclaration = ts.firstOrUndefined(declarations);
                    var lastDeclaration = ts.lastOrUndefined(declarations);
                    ts.setSourceMapRange(declarationList, ts.createRange(firstDeclaration.pos, lastDeclaration.end));
                }
                return declarationList;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function shouldEmitExplicitInitializerForLetDeclaration(node) {
            var flags = resolver.getNodeCheckFlags(node);
            var isCapturedInFunction = flags & 131072;
            var isDeclaredInLoop = flags & 262144;
            var emittedAsTopLevel = (hierarchyFacts & 64) !== 0
                || (isCapturedInFunction
                    && isDeclaredInLoop
                    && (hierarchyFacts & 512) !== 0);
            var emitExplicitInitializer = !emittedAsTopLevel
                && (hierarchyFacts & 2048) === 0
                && (!resolver.isDeclarationWithCollidingName(node)
                    || (isDeclaredInLoop
                        && !isCapturedInFunction
                        && (hierarchyFacts & (1024 | 2048)) === 0));
            return emitExplicitInitializer;
        }
        function visitVariableDeclarationInLetDeclarationList(node) {
            var name = node.name;
            if (ts.isBindingPattern(name)) {
                return visitVariableDeclaration(node);
            }
            if (!node.initializer && shouldEmitExplicitInitializerForLetDeclaration(node)) {
                var clone_3 = ts.getMutableClone(node);
                clone_3.initializer = ts.createVoidZero();
                return clone_3;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableDeclaration(node) {
            var ancestorFacts = enterSubtree(32, 0);
            var updated;
            if (ts.isBindingPattern(node.name)) {
                updated = ts.flattenDestructuringBinding(node, visitor, context, 0, undefined, (ancestorFacts & 32) !== 0);
            }
            else {
                updated = ts.visitEachChild(node, visitor, context);
            }
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function recordLabel(node) {
            convertedLoopState.labels.set(node.label.text, node.label.text);
        }
        function resetLabel(node) {
            convertedLoopState.labels.set(node.label.text, undefined);
        }
        function visitLabeledStatement(node) {
            if (convertedLoopState && !convertedLoopState.labels) {
                convertedLoopState.labels = ts.createMap();
            }
            var statement = ts.unwrapInnermostStatementOfLabel(node, convertedLoopState && recordLabel);
            return ts.isIterationStatement(statement, false)
                ? visitIterationStatement(statement, node)
                : ts.restoreEnclosingLabel(ts.visitNode(statement, visitor, ts.isStatement), node, convertedLoopState && resetLabel);
        }
        function visitIterationStatement(node, outermostLabeledStatement) {
            switch (node.kind) {
                case 212:
                case 213:
                    return visitDoOrWhileStatement(node, outermostLabeledStatement);
                case 214:
                    return visitForStatement(node, outermostLabeledStatement);
                case 215:
                    return visitForInStatement(node, outermostLabeledStatement);
                case 216:
                    return visitForOfStatement(node, outermostLabeledStatement);
            }
        }
        function visitIterationStatementWithFacts(excludeFacts, includeFacts, node, outermostLabeledStatement, convert) {
            var ancestorFacts = enterSubtree(excludeFacts, includeFacts);
            var updated = convertIterationStatementBodyIfNecessary(node, outermostLabeledStatement, convert);
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function visitDoOrWhileStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(0, 256, node, outermostLabeledStatement);
        }
        function visitForStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(3008, 1280, node, outermostLabeledStatement);
        }
        function visitForInStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(1984, 2304, node, outermostLabeledStatement);
        }
        function visitForOfStatement(node, outermostLabeledStatement) {
            return visitIterationStatementWithFacts(1984, 2304, node, outermostLabeledStatement, compilerOptions.downlevelIteration ? convertForOfStatementForIterable : convertForOfStatementForArray);
        }
        function convertForOfStatementHead(node, boundValue, convertedLoopBodyStatements) {
            var statements = [];
            if (ts.isVariableDeclarationList(node.initializer)) {
                if (node.initializer.flags & 3) {
                    enableSubstitutionsForBlockScopedBindings();
                }
                var firstOriginalDeclaration = ts.firstOrUndefined(node.initializer.declarations);
                if (firstOriginalDeclaration && ts.isBindingPattern(firstOriginalDeclaration.name)) {
                    var declarations = ts.flattenDestructuringBinding(firstOriginalDeclaration, visitor, context, 0, boundValue);
                    var declarationList = ts.setTextRange(ts.createVariableDeclarationList(declarations), node.initializer);
                    ts.setOriginalNode(declarationList, node.initializer);
                    var firstDeclaration = declarations[0];
                    var lastDeclaration = ts.lastOrUndefined(declarations);
                    ts.setSourceMapRange(declarationList, ts.createRange(firstDeclaration.pos, lastDeclaration.end));
                    statements.push(ts.createVariableStatement(undefined, declarationList));
                }
                else {
                    statements.push(ts.setTextRange(ts.createVariableStatement(undefined, ts.setOriginalNode(ts.setTextRange(ts.createVariableDeclarationList([
                        ts.createVariableDeclaration(firstOriginalDeclaration ? firstOriginalDeclaration.name : ts.createTempVariable(undefined), undefined, boundValue)
                    ]), ts.moveRangePos(node.initializer, -1)), node.initializer)), ts.moveRangeEnd(node.initializer, -1)));
                }
            }
            else {
                var assignment = ts.createAssignment(node.initializer, boundValue);
                if (ts.isDestructuringAssignment(assignment)) {
                    ts.aggregateTransformFlags(assignment);
                    statements.push(ts.createStatement(visitBinaryExpression(assignment, false)));
                }
                else {
                    assignment.end = node.initializer.end;
                    statements.push(ts.setTextRange(ts.createStatement(ts.visitNode(assignment, visitor, ts.isExpression)), ts.moveRangeEnd(node.initializer, -1)));
                }
            }
            var bodyLocation;
            var statementsLocation;
            if (convertedLoopBodyStatements) {
                ts.addRange(statements, convertedLoopBodyStatements);
            }
            else {
                var statement = ts.visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock);
                if (ts.isBlock(statement)) {
                    ts.addRange(statements, statement.statements);
                    bodyLocation = statement;
                    statementsLocation = statement.statements;
                }
                else {
                    statements.push(statement);
                }
            }
            return ts.setEmitFlags(ts.setTextRange(ts.createBlock(ts.setTextRange(ts.createNodeArray(statements), statementsLocation), true), bodyLocation), 48 | 384);
        }
        function convertForOfStatementForArray(node, outermostLabeledStatement, convertedLoopBodyStatements) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var counter = ts.createLoopVariable();
            var rhsReference = ts.isIdentifier(expression) ? ts.getGeneratedNameForNode(expression) : ts.createTempVariable(undefined);
            ts.setEmitFlags(expression, 48 | ts.getEmitFlags(expression));
            var forStatement = ts.setTextRange(ts.createFor(ts.setEmitFlags(ts.setTextRange(ts.createVariableDeclarationList([
                ts.setTextRange(ts.createVariableDeclaration(counter, undefined, ts.createLiteral(0)), ts.moveRangePos(node.expression, -1)),
                ts.setTextRange(ts.createVariableDeclaration(rhsReference, undefined, expression), node.expression)
            ]), node.expression), 2097152), ts.setTextRange(ts.createLessThan(counter, ts.createPropertyAccess(rhsReference, "length")), node.expression), ts.setTextRange(ts.createPostfixIncrement(counter), node.expression), convertForOfStatementHead(node, ts.createElementAccess(rhsReference, counter), convertedLoopBodyStatements)), node);
            ts.setEmitFlags(forStatement, 256);
            ts.setTextRange(forStatement, node);
            return ts.restoreEnclosingLabel(forStatement, outermostLabeledStatement, convertedLoopState && resetLabel);
        }
        function convertForOfStatementForIterable(node, outermostLabeledStatement, convertedLoopBodyStatements) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var iterator = ts.isIdentifier(expression) ? ts.getGeneratedNameForNode(expression) : ts.createTempVariable(undefined);
            var result = ts.isIdentifier(expression) ? ts.getGeneratedNameForNode(iterator) : ts.createTempVariable(undefined);
            var errorRecord = ts.createUniqueName("e");
            var catchVariable = ts.getGeneratedNameForNode(errorRecord);
            var returnMethod = ts.createTempVariable(undefined);
            var values = ts.createValuesHelper(context, expression, node.expression);
            var next = ts.createCall(ts.createPropertyAccess(iterator, "next"), undefined, []);
            hoistVariableDeclaration(errorRecord);
            hoistVariableDeclaration(returnMethod);
            var forStatement = ts.setEmitFlags(ts.setTextRange(ts.createFor(ts.setEmitFlags(ts.setTextRange(ts.createVariableDeclarationList([
                ts.setTextRange(ts.createVariableDeclaration(iterator, undefined, values), node.expression),
                ts.createVariableDeclaration(result, undefined, next)
            ]), node.expression), 2097152), ts.createLogicalNot(ts.createPropertyAccess(result, "done")), ts.createAssignment(result, next), convertForOfStatementHead(node, ts.createPropertyAccess(result, "value"), convertedLoopBodyStatements)), node), 256);
            return ts.createTry(ts.createBlock([
                ts.restoreEnclosingLabel(forStatement, outermostLabeledStatement, convertedLoopState && resetLabel)
            ]), ts.createCatchClause(ts.createVariableDeclaration(catchVariable), ts.setEmitFlags(ts.createBlock([
                ts.createStatement(ts.createAssignment(errorRecord, ts.createObjectLiteral([
                    ts.createPropertyAssignment("error", catchVariable)
                ])))
            ]), 1)), ts.createBlock([
                ts.createTry(ts.createBlock([
                    ts.setEmitFlags(ts.createIf(ts.createLogicalAnd(ts.createLogicalAnd(result, ts.createLogicalNot(ts.createPropertyAccess(result, "done"))), ts.createAssignment(returnMethod, ts.createPropertyAccess(iterator, "return"))), ts.createStatement(ts.createFunctionCall(returnMethod, iterator, []))), 1),
                ]), undefined, ts.setEmitFlags(ts.createBlock([
                    ts.setEmitFlags(ts.createIf(errorRecord, ts.createThrow(ts.createPropertyAccess(errorRecord, "error"))), 1)
                ]), 1))
            ]));
        }
        function visitObjectLiteralExpression(node) {
            var properties = node.properties;
            var numProperties = properties.length;
            var numInitialProperties = numProperties;
            var numInitialPropertiesWithoutYield = numProperties;
            for (var i = 0; i < numProperties; i++) {
                var property = properties[i];
                if ((property.transformFlags & 16777216 && hierarchyFacts & 4)
                    && i < numInitialPropertiesWithoutYield) {
                    numInitialPropertiesWithoutYield = i;
                }
                if (property.name.kind === 144) {
                    numInitialProperties = i;
                    break;
                }
            }
            if (numInitialProperties !== numProperties) {
                if (numInitialPropertiesWithoutYield < numInitialProperties) {
                    numInitialProperties = numInitialPropertiesWithoutYield;
                }
                var temp = ts.createTempVariable(hoistVariableDeclaration);
                var expressions = [];
                var assignment = ts.createAssignment(temp, ts.setEmitFlags(ts.createObjectLiteral(ts.visitNodes(properties, visitor, ts.isObjectLiteralElementLike, 0, numInitialProperties), node.multiLine), 65536));
                if (node.multiLine) {
                    assignment.startsOnNewLine = true;
                }
                expressions.push(assignment);
                addObjectLiteralMembers(expressions, node, temp, numInitialProperties);
                expressions.push(node.multiLine ? ts.startOnNewLine(ts.getMutableClone(temp)) : temp);
                return ts.inlineExpressions(expressions);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function shouldConvertIterationStatementBody(node) {
            return (resolver.getNodeCheckFlags(node) & 65536) !== 0;
        }
        function hoistVariableDeclarationDeclaredInConvertedLoop(state, node) {
            if (!state.hoistedLocalVariables) {
                state.hoistedLocalVariables = [];
            }
            visit(node.name);
            function visit(node) {
                if (node.kind === 71) {
                    state.hoistedLocalVariables.push(node);
                }
                else {
                    for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                        var element = _a[_i];
                        if (!ts.isOmittedExpression(element)) {
                            visit(element.name);
                        }
                    }
                }
            }
        }
        function convertIterationStatementBodyIfNecessary(node, outermostLabeledStatement, convert) {
            if (!shouldConvertIterationStatementBody(node)) {
                var saveAllowedNonLabeledJumps = void 0;
                if (convertedLoopState) {
                    saveAllowedNonLabeledJumps = convertedLoopState.allowedNonLabeledJumps;
                    convertedLoopState.allowedNonLabeledJumps = 2 | 4;
                }
                var result = convert
                    ? convert(node, outermostLabeledStatement, undefined)
                    : ts.restoreEnclosingLabel(ts.visitEachChild(node, visitor, context), outermostLabeledStatement, convertedLoopState && resetLabel);
                if (convertedLoopState) {
                    convertedLoopState.allowedNonLabeledJumps = saveAllowedNonLabeledJumps;
                }
                return result;
            }
            var functionName = ts.createUniqueName("_loop");
            var loopInitializer;
            switch (node.kind) {
                case 214:
                case 215:
                case 216:
                    var initializer = node.initializer;
                    if (initializer && initializer.kind === 227) {
                        loopInitializer = initializer;
                    }
                    break;
            }
            var loopParameters = [];
            var loopOutParameters = [];
            if (loopInitializer && (ts.getCombinedNodeFlags(loopInitializer) & 3)) {
                for (var _i = 0, _a = loopInitializer.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    processLoopVariableDeclaration(decl, loopParameters, loopOutParameters);
                }
            }
            var outerConvertedLoopState = convertedLoopState;
            convertedLoopState = { loopOutParameters: loopOutParameters };
            if (outerConvertedLoopState) {
                if (outerConvertedLoopState.argumentsName) {
                    convertedLoopState.argumentsName = outerConvertedLoopState.argumentsName;
                }
                if (outerConvertedLoopState.thisName) {
                    convertedLoopState.thisName = outerConvertedLoopState.thisName;
                }
                if (outerConvertedLoopState.hoistedLocalVariables) {
                    convertedLoopState.hoistedLocalVariables = outerConvertedLoopState.hoistedLocalVariables;
                }
            }
            startLexicalEnvironment();
            var loopBody = ts.visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock);
            var lexicalEnvironment = endLexicalEnvironment();
            var currentState = convertedLoopState;
            convertedLoopState = outerConvertedLoopState;
            if (loopOutParameters.length || lexicalEnvironment) {
                var statements_4 = ts.isBlock(loopBody) ? loopBody.statements.slice() : [loopBody];
                if (loopOutParameters.length) {
                    copyOutParameters(loopOutParameters, 1, statements_4);
                }
                ts.addRange(statements_4, lexicalEnvironment);
                loopBody = ts.createBlock(statements_4, true);
            }
            if (ts.isBlock(loopBody)) {
                loopBody.multiLine = true;
            }
            else {
                loopBody = ts.createBlock([loopBody], true);
            }
            var containsYield = (node.statement.transformFlags & 16777216) !== 0;
            var isAsyncBlockContainingAwait = containsYield && (hierarchyFacts & 4) !== 0;
            var loopBodyFlags = 0;
            if (currentState.containsLexicalThis) {
                loopBodyFlags |= 8;
            }
            if (isAsyncBlockContainingAwait) {
                loopBodyFlags |= 262144;
            }
            var convertedLoopVariable = ts.createVariableStatement(undefined, ts.setEmitFlags(ts.createVariableDeclarationList([
                ts.createVariableDeclaration(functionName, undefined, ts.setEmitFlags(ts.createFunctionExpression(undefined, containsYield ? ts.createToken(39) : undefined, undefined, undefined, loopParameters, undefined, loopBody), loopBodyFlags))
            ]), 2097152));
            var statements = [convertedLoopVariable];
            var extraVariableDeclarations;
            if (currentState.argumentsName) {
                if (outerConvertedLoopState) {
                    outerConvertedLoopState.argumentsName = currentState.argumentsName;
                }
                else {
                    (extraVariableDeclarations || (extraVariableDeclarations = [])).push(ts.createVariableDeclaration(currentState.argumentsName, undefined, ts.createIdentifier("arguments")));
                }
            }
            if (currentState.thisName) {
                if (outerConvertedLoopState) {
                    outerConvertedLoopState.thisName = currentState.thisName;
                }
                else {
                    (extraVariableDeclarations || (extraVariableDeclarations = [])).push(ts.createVariableDeclaration(currentState.thisName, undefined, ts.createIdentifier("this")));
                }
            }
            if (currentState.hoistedLocalVariables) {
                if (outerConvertedLoopState) {
                    outerConvertedLoopState.hoistedLocalVariables = currentState.hoistedLocalVariables;
                }
                else {
                    if (!extraVariableDeclarations) {
                        extraVariableDeclarations = [];
                    }
                    for (var _b = 0, _c = currentState.hoistedLocalVariables; _b < _c.length; _b++) {
                        var identifier = _c[_b];
                        extraVariableDeclarations.push(ts.createVariableDeclaration(identifier));
                    }
                }
            }
            if (loopOutParameters.length) {
                if (!extraVariableDeclarations) {
                    extraVariableDeclarations = [];
                }
                for (var _d = 0, loopOutParameters_1 = loopOutParameters; _d < loopOutParameters_1.length; _d++) {
                    var outParam = loopOutParameters_1[_d];
                    extraVariableDeclarations.push(ts.createVariableDeclaration(outParam.outParamName));
                }
            }
            if (extraVariableDeclarations) {
                statements.push(ts.createVariableStatement(undefined, ts.createVariableDeclarationList(extraVariableDeclarations)));
            }
            var convertedLoopBodyStatements = generateCallToConvertedLoop(functionName, loopParameters, currentState, containsYield);
            var loop;
            if (convert) {
                loop = convert(node, outermostLabeledStatement, convertedLoopBodyStatements);
            }
            else {
                var clone_4 = ts.getMutableClone(node);
                clone_4.statement = undefined;
                clone_4 = ts.visitEachChild(clone_4, visitor, context);
                clone_4.statement = ts.createBlock(convertedLoopBodyStatements, true);
                clone_4.transformFlags = 0;
                ts.aggregateTransformFlags(clone_4);
                loop = ts.restoreEnclosingLabel(clone_4, outermostLabeledStatement, convertedLoopState && resetLabel);
            }
            statements.push(loop);
            return statements;
        }
        function copyOutParameter(outParam, copyDirection) {
            var source = copyDirection === 0 ? outParam.outParamName : outParam.originalName;
            var target = copyDirection === 0 ? outParam.originalName : outParam.outParamName;
            return ts.createBinary(target, 58, source);
        }
        function copyOutParameters(outParams, copyDirection, statements) {
            for (var _i = 0, outParams_1 = outParams; _i < outParams_1.length; _i++) {
                var outParam = outParams_1[_i];
                statements.push(ts.createStatement(copyOutParameter(outParam, copyDirection)));
            }
        }
        function generateCallToConvertedLoop(loopFunctionExpressionName, parameters, state, isAsyncBlockContainingAwait) {
            var outerConvertedLoopState = convertedLoopState;
            var statements = [];
            var isSimpleLoop = !(state.nonLocalJumps & ~4) &&
                !state.labeledNonLocalBreaks &&
                !state.labeledNonLocalContinues;
            var call = ts.createCall(loopFunctionExpressionName, undefined, ts.map(parameters, function (p) { return p.name; }));
            var callResult = isAsyncBlockContainingAwait
                ? ts.createYield(ts.createToken(39), ts.setEmitFlags(call, 8388608))
                : call;
            if (isSimpleLoop) {
                statements.push(ts.createStatement(callResult));
                copyOutParameters(state.loopOutParameters, 0, statements);
            }
            else {
                var loopResultName = ts.createUniqueName("state");
                var stateVariable = ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(loopResultName, undefined, callResult)]));
                statements.push(stateVariable);
                copyOutParameters(state.loopOutParameters, 0, statements);
                if (state.nonLocalJumps & 8) {
                    var returnStatement = void 0;
                    if (outerConvertedLoopState) {
                        outerConvertedLoopState.nonLocalJumps |= 8;
                        returnStatement = ts.createReturn(loopResultName);
                    }
                    else {
                        returnStatement = ts.createReturn(ts.createPropertyAccess(loopResultName, "value"));
                    }
                    statements.push(ts.createIf(ts.createBinary(ts.createTypeOf(loopResultName), 34, ts.createLiteral("object")), returnStatement));
                }
                if (state.nonLocalJumps & 2) {
                    statements.push(ts.createIf(ts.createBinary(loopResultName, 34, ts.createLiteral("break")), ts.createBreak()));
                }
                if (state.labeledNonLocalBreaks || state.labeledNonLocalContinues) {
                    var caseClauses = [];
                    processLabeledJumps(state.labeledNonLocalBreaks, true, loopResultName, outerConvertedLoopState, caseClauses);
                    processLabeledJumps(state.labeledNonLocalContinues, false, loopResultName, outerConvertedLoopState, caseClauses);
                    statements.push(ts.createSwitch(loopResultName, ts.createCaseBlock(caseClauses)));
                }
            }
            return statements;
        }
        function setLabeledJump(state, isBreak, labelText, labelMarker) {
            if (isBreak) {
                if (!state.labeledNonLocalBreaks) {
                    state.labeledNonLocalBreaks = ts.createMap();
                }
                state.labeledNonLocalBreaks.set(labelText, labelMarker);
            }
            else {
                if (!state.labeledNonLocalContinues) {
                    state.labeledNonLocalContinues = ts.createMap();
                }
                state.labeledNonLocalContinues.set(labelText, labelMarker);
            }
        }
        function processLabeledJumps(table, isBreak, loopResultName, outerLoop, caseClauses) {
            if (!table) {
                return;
            }
            table.forEach(function (labelMarker, labelText) {
                var statements = [];
                if (!outerLoop || (outerLoop.labels && outerLoop.labels.get(labelText))) {
                    var label = ts.createIdentifier(labelText);
                    statements.push(isBreak ? ts.createBreak(label) : ts.createContinue(label));
                }
                else {
                    setLabeledJump(outerLoop, isBreak, labelText, labelMarker);
                    statements.push(ts.createReturn(loopResultName));
                }
                caseClauses.push(ts.createCaseClause(ts.createLiteral(labelMarker), statements));
            });
        }
        function processLoopVariableDeclaration(decl, loopParameters, loopOutParameters) {
            var name = decl.name;
            if (ts.isBindingPattern(name)) {
                for (var _i = 0, _a = name.elements; _i < _a.length; _i++) {
                    var element = _a[_i];
                    if (!ts.isOmittedExpression(element)) {
                        processLoopVariableDeclaration(element, loopParameters, loopOutParameters);
                    }
                }
            }
            else {
                loopParameters.push(ts.createParameter(undefined, undefined, undefined, name));
                if (resolver.getNodeCheckFlags(decl) & 2097152) {
                    var outParamName = ts.createUniqueName("out_" + ts.unescapeIdentifier(name.text));
                    loopOutParameters.push({ originalName: name, outParamName: outParamName });
                }
            }
        }
        function addObjectLiteralMembers(expressions, node, receiver, start) {
            var properties = node.properties;
            var numProperties = properties.length;
            for (var i = start; i < numProperties; i++) {
                var property = properties[i];
                switch (property.kind) {
                    case 153:
                    case 154:
                        var accessors = ts.getAllAccessorDeclarations(node.properties, property);
                        if (property === accessors.firstAccessor) {
                            expressions.push(transformAccessorsToExpression(receiver, accessors, node, node.multiLine));
                        }
                        break;
                    case 151:
                        expressions.push(transformObjectLiteralMethodDeclarationToExpression(property, receiver, node, node.multiLine));
                        break;
                    case 261:
                        expressions.push(transformPropertyAssignmentToExpression(property, receiver, node.multiLine));
                        break;
                    case 262:
                        expressions.push(transformShorthandPropertyAssignmentToExpression(property, receiver, node.multiLine));
                        break;
                    default:
                        ts.Debug.failBadSyntaxKind(node);
                        break;
                }
            }
        }
        function transformPropertyAssignmentToExpression(property, receiver, startsOnNewLine) {
            var expression = ts.createAssignment(ts.createMemberAccessForPropertyName(receiver, ts.visitNode(property.name, visitor, ts.isPropertyName)), ts.visitNode(property.initializer, visitor, ts.isExpression));
            ts.setTextRange(expression, property);
            if (startsOnNewLine) {
                expression.startsOnNewLine = true;
            }
            return expression;
        }
        function transformShorthandPropertyAssignmentToExpression(property, receiver, startsOnNewLine) {
            var expression = ts.createAssignment(ts.createMemberAccessForPropertyName(receiver, ts.visitNode(property.name, visitor, ts.isPropertyName)), ts.getSynthesizedClone(property.name));
            ts.setTextRange(expression, property);
            if (startsOnNewLine) {
                expression.startsOnNewLine = true;
            }
            return expression;
        }
        function transformObjectLiteralMethodDeclarationToExpression(method, receiver, container, startsOnNewLine) {
            var ancestorFacts = enterSubtree(0, 0);
            var expression = ts.createAssignment(ts.createMemberAccessForPropertyName(receiver, ts.visitNode(method.name, visitor, ts.isPropertyName)), transformFunctionLikeToExpression(method, method, undefined, container));
            ts.setTextRange(expression, method);
            if (startsOnNewLine) {
                expression.startsOnNewLine = true;
            }
            exitSubtree(ancestorFacts, 49152, hierarchyFacts & 49152 ? 16384 : 0);
            return expression;
        }
        function visitCatchClause(node) {
            var ancestorFacts = enterSubtree(4032, 0);
            var updated;
            if (ts.isBindingPattern(node.variableDeclaration.name)) {
                var temp = ts.createTempVariable(undefined);
                var newVariableDeclaration = ts.createVariableDeclaration(temp);
                ts.setTextRange(newVariableDeclaration, node.variableDeclaration);
                var vars = ts.flattenDestructuringBinding(node.variableDeclaration, visitor, context, 0, temp);
                var list = ts.createVariableDeclarationList(vars);
                ts.setTextRange(list, node.variableDeclaration);
                var destructure = ts.createVariableStatement(undefined, list);
                updated = ts.updateCatchClause(node, newVariableDeclaration, addStatementToStartOfBlock(node.block, destructure));
            }
            else {
                updated = ts.visitEachChild(node, visitor, context);
            }
            exitSubtree(ancestorFacts, 0, 0);
            return updated;
        }
        function addStatementToStartOfBlock(block, statement) {
            var transformedStatements = ts.visitNodes(block.statements, visitor, ts.isStatement);
            return ts.updateBlock(block, [statement].concat(transformedStatements));
        }
        function visitMethodDeclaration(node) {
            ts.Debug.assert(!ts.isComputedPropertyName(node.name));
            var functionExpression = transformFunctionLikeToExpression(node, ts.moveRangePos(node, -1), undefined, undefined);
            ts.setEmitFlags(functionExpression, 512 | ts.getEmitFlags(functionExpression));
            return ts.setTextRange(ts.createPropertyAssignment(node.name, functionExpression), node);
        }
        function visitAccessorDeclaration(node) {
            ts.Debug.assert(!ts.isComputedPropertyName(node.name));
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(16286, 65);
            var updated;
            if (node.transformFlags & 32768) {
                var parameters = ts.visitParameterList(node.parameters, visitor, context);
                var body = transformFunctionBody(node);
                if (node.kind === 153) {
                    updated = ts.updateGetAccessor(node, node.decorators, node.modifiers, node.name, parameters, node.type, body);
                }
                else {
                    updated = ts.updateSetAccessor(node, node.decorators, node.modifiers, node.name, parameters, body);
                }
            }
            else {
                updated = ts.visitEachChild(node, visitor, context);
            }
            exitSubtree(ancestorFacts, 49152, 0);
            convertedLoopState = savedConvertedLoopState;
            return updated;
        }
        function visitShorthandPropertyAssignment(node) {
            return ts.setTextRange(ts.createPropertyAssignment(node.name, ts.getSynthesizedClone(node.name)), node);
        }
        function visitComputedPropertyName(node) {
            var ancestorFacts = enterSubtree(0, 8192);
            var updated = ts.visitEachChild(node, visitor, context);
            exitSubtree(ancestorFacts, 49152, hierarchyFacts & 49152 ? 32768 : 0);
            return updated;
        }
        function visitYieldExpression(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function visitArrayLiteralExpression(node) {
            if (node.transformFlags & 64) {
                return transformAndSpreadElements(node.elements, true, node.multiLine, node.elements.hasTrailingComma);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCallExpression(node) {
            if (node.transformFlags & 64) {
                return visitCallExpressionWithPotentialCapturedThisAssignment(node, true);
            }
            return ts.updateCall(node, ts.visitNode(node.expression, callExpressionVisitor, ts.isExpression), undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function visitImmediateSuperCallInBody(node) {
            return visitCallExpressionWithPotentialCapturedThisAssignment(node, false);
        }
        function visitCallExpressionWithPotentialCapturedThisAssignment(node, assignToCapturedThis) {
            var _a = ts.createCallBinding(node.expression, hoistVariableDeclaration), target = _a.target, thisArg = _a.thisArg;
            if (node.expression.kind === 97) {
                ts.setEmitFlags(thisArg, 4);
            }
            var resultingCall;
            if (node.transformFlags & 524288) {
                resultingCall = ts.createFunctionApply(ts.visitNode(target, callExpressionVisitor, ts.isExpression), ts.visitNode(thisArg, visitor, ts.isExpression), transformAndSpreadElements(node.arguments, false, false, false));
            }
            else {
                resultingCall = ts.createFunctionCall(ts.visitNode(target, callExpressionVisitor, ts.isExpression), ts.visitNode(thisArg, visitor, ts.isExpression), ts.visitNodes(node.arguments, visitor, ts.isExpression), node);
            }
            if (node.expression.kind === 97) {
                var actualThis = ts.createThis();
                ts.setEmitFlags(actualThis, 4);
                var initializer = ts.createLogicalOr(resultingCall, actualThis);
                resultingCall = assignToCapturedThis
                    ? ts.createAssignment(ts.createIdentifier("_this"), initializer)
                    : initializer;
            }
            return ts.setOriginalNode(resultingCall, node);
        }
        function visitNewExpression(node) {
            if (node.transformFlags & 524288) {
                var _a = ts.createCallBinding(ts.createPropertyAccess(node.expression, "bind"), hoistVariableDeclaration), target = _a.target, thisArg = _a.thisArg;
                return ts.createNew(ts.createFunctionApply(ts.visitNode(target, visitor, ts.isExpression), thisArg, transformAndSpreadElements(ts.createNodeArray([ts.createVoidZero()].concat(node.arguments)), false, false, false)), undefined, []);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndSpreadElements(elements, needsUniqueCopy, multiLine, hasTrailingComma) {
            var numElements = elements.length;
            var segments = ts.flatten(ts.spanMap(elements, partitionSpread, function (partition, visitPartition, _start, end) {
                return visitPartition(partition, multiLine, hasTrailingComma && end === numElements);
            }));
            if (compilerOptions.downlevelIteration) {
                if (segments.length === 1) {
                    var firstSegment = segments[0];
                    if (ts.isCallExpression(firstSegment)
                        && ts.isIdentifier(firstSegment.expression)
                        && (ts.getEmitFlags(firstSegment.expression) & 4096)
                        && firstSegment.expression.text === "___spread") {
                        return segments[0];
                    }
                }
                return ts.createSpreadHelper(context, segments);
            }
            else {
                if (segments.length === 1) {
                    var firstElement = elements[0];
                    return needsUniqueCopy && ts.isSpreadExpression(firstElement) && firstElement.expression.kind !== 177
                        ? ts.createArraySlice(segments[0])
                        : segments[0];
                }
                return ts.createArrayConcat(segments.shift(), segments);
            }
        }
        function partitionSpread(node) {
            return ts.isSpreadExpression(node)
                ? visitSpanOfSpreads
                : visitSpanOfNonSpreads;
        }
        function visitSpanOfSpreads(chunk) {
            return ts.map(chunk, visitExpressionOfSpread);
        }
        function visitSpanOfNonSpreads(chunk, multiLine, hasTrailingComma) {
            return ts.createArrayLiteral(ts.visitNodes(ts.createNodeArray(chunk, hasTrailingComma), visitor, ts.isExpression), multiLine);
        }
        function visitSpreadElement(node) {
            return ts.visitNode(node.expression, visitor, ts.isExpression);
        }
        function visitExpressionOfSpread(node) {
            return ts.visitNode(node.expression, visitor, ts.isExpression);
        }
        function visitTemplateLiteral(node) {
            return ts.setTextRange(ts.createLiteral(node.text), node);
        }
        function visitStringLiteral(node) {
            if (node.hasExtendedUnicodeEscape) {
                return ts.setTextRange(ts.createLiteral(node.text), node);
            }
            return node;
        }
        function visitNumericLiteral(node) {
            if (node.numericLiteralFlags & 48) {
                return ts.setTextRange(ts.createNumericLiteral(node.text), node);
            }
            return node;
        }
        function visitTaggedTemplateExpression(node) {
            var tag = ts.visitNode(node.tag, visitor, ts.isExpression);
            var temp = ts.createTempVariable(hoistVariableDeclaration);
            var templateArguments = [temp];
            var cookedStrings = [];
            var rawStrings = [];
            var template = node.template;
            if (ts.isNoSubstitutionTemplateLiteral(template)) {
                cookedStrings.push(ts.createLiteral(template.text));
                rawStrings.push(getRawLiteral(template));
            }
            else {
                cookedStrings.push(ts.createLiteral(template.head.text));
                rawStrings.push(getRawLiteral(template.head));
                for (var _i = 0, _a = template.templateSpans; _i < _a.length; _i++) {
                    var templateSpan = _a[_i];
                    cookedStrings.push(ts.createLiteral(templateSpan.literal.text));
                    rawStrings.push(getRawLiteral(templateSpan.literal));
                    templateArguments.push(ts.visitNode(templateSpan.expression, visitor, ts.isExpression));
                }
            }
            return ts.createParen(ts.inlineExpressions([
                ts.createAssignment(temp, ts.createArrayLiteral(cookedStrings)),
                ts.createAssignment(ts.createPropertyAccess(temp, "raw"), ts.createArrayLiteral(rawStrings)),
                ts.createCall(tag, undefined, templateArguments)
            ]));
        }
        function getRawLiteral(node) {
            var text = ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node);
            var isLast = node.kind === 13 || node.kind === 16;
            text = text.substring(1, text.length - (isLast ? 1 : 2));
            text = text.replace(/\r\n?/g, "\n");
            return ts.setTextRange(ts.createLiteral(text), node);
        }
        function visitTemplateExpression(node) {
            var expressions = [];
            addTemplateHead(expressions, node);
            addTemplateSpans(expressions, node);
            var expression = ts.reduceLeft(expressions, ts.createAdd);
            if (ts.nodeIsSynthesized(expression)) {
                expression.pos = node.pos;
                expression.end = node.end;
            }
            return expression;
        }
        function shouldAddTemplateHead(node) {
            ts.Debug.assert(node.templateSpans.length !== 0);
            return node.head.text.length !== 0 || node.templateSpans[0].literal.text.length === 0;
        }
        function addTemplateHead(expressions, node) {
            if (!shouldAddTemplateHead(node)) {
                return;
            }
            expressions.push(ts.createLiteral(node.head.text));
        }
        function addTemplateSpans(expressions, node) {
            for (var _i = 0, _a = node.templateSpans; _i < _a.length; _i++) {
                var span_6 = _a[_i];
                expressions.push(ts.visitNode(span_6.expression, visitor, ts.isExpression));
                if (span_6.literal.text.length !== 0) {
                    expressions.push(ts.createLiteral(span_6.literal.text));
                }
            }
        }
        function visitSuperKeyword(isExpressionOfCall) {
            return hierarchyFacts & 8
                && !isExpressionOfCall
                ? ts.createPropertyAccess(ts.createIdentifier("_super"), "prototype")
                : ts.createIdentifier("_super");
        }
        function visitMetaProperty(node) {
            if (node.keywordToken === 94 && node.name.text === "target") {
                if (hierarchyFacts & 8192) {
                    hierarchyFacts |= 32768;
                }
                else {
                    hierarchyFacts |= 16384;
                }
                return ts.createIdentifier("_newTarget");
            }
            return node;
        }
        function onEmitNode(hint, node, emitCallback) {
            if (enabledSubstitutions & 1 && ts.isFunctionLike(node)) {
                var ancestorFacts = enterSubtree(16286, ts.getEmitFlags(node) & 8
                    ? 65 | 16
                    : 65);
                previousOnEmitNode(hint, node, emitCallback);
                exitSubtree(ancestorFacts, 0, 0);
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        function enableSubstitutionsForBlockScopedBindings() {
            if ((enabledSubstitutions & 2) === 0) {
                enabledSubstitutions |= 2;
                context.enableSubstitution(71);
            }
        }
        function enableSubstitutionsForCapturedThis() {
            if ((enabledSubstitutions & 1) === 0) {
                enabledSubstitutions |= 1;
                context.enableSubstitution(99);
                context.enableEmitNotification(152);
                context.enableEmitNotification(151);
                context.enableEmitNotification(153);
                context.enableEmitNotification(154);
                context.enableEmitNotification(187);
                context.enableEmitNotification(186);
                context.enableEmitNotification(228);
            }
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1) {
                return substituteExpression(node);
            }
            if (ts.isIdentifier(node)) {
                return substituteIdentifier(node);
            }
            return node;
        }
        function substituteIdentifier(node) {
            if (enabledSubstitutions & 2 && !ts.isInternalName(node)) {
                var original = ts.getParseTreeNode(node, ts.isIdentifier);
                if (original && isNameOfDeclarationWithCollidingName(original)) {
                    return ts.setTextRange(ts.getGeneratedNameForNode(original), node);
                }
            }
            return node;
        }
        function isNameOfDeclarationWithCollidingName(node) {
            var parent = node.parent;
            switch (parent.kind) {
                case 176:
                case 229:
                case 232:
                case 226:
                    return parent.name === node
                        && resolver.isDeclarationWithCollidingName(parent);
            }
            return false;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 71:
                    return substituteExpressionIdentifier(node);
                case 99:
                    return substituteThisKeyword(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            if (enabledSubstitutions & 2 && !ts.isInternalName(node)) {
                var declaration = resolver.getReferencedDeclarationWithCollidingName(node);
                if (declaration && !(ts.isClassLike(declaration) && isPartOfClassBody(declaration, node))) {
                    return ts.setTextRange(ts.getGeneratedNameForNode(ts.getNameOfDeclaration(declaration)), node);
                }
            }
            return node;
        }
        function isPartOfClassBody(declaration, node) {
            var currentNode = ts.getParseTreeNode(node);
            if (!currentNode || currentNode === declaration || currentNode.end <= declaration.pos || currentNode.pos >= declaration.end) {
                return false;
            }
            var blockScope = ts.getEnclosingBlockScopeContainer(declaration);
            while (currentNode) {
                if (currentNode === blockScope || currentNode === declaration) {
                    return false;
                }
                if (ts.isClassElement(currentNode) && currentNode.parent === declaration) {
                    return currentNode.kind !== 149
                        || (ts.getModifierFlags(currentNode) & 32) === 0;
                }
                currentNode = currentNode.parent;
            }
            return false;
        }
        function substituteThisKeyword(node) {
            if (enabledSubstitutions & 1
                && hierarchyFacts & 16) {
                return ts.setTextRange(ts.createIdentifier("_this"), node);
            }
            return node;
        }
        function getClassMemberPrefix(node, member) {
            return ts.hasModifier(member, 32)
                ? ts.getInternalName(node)
                : ts.createPropertyAccess(ts.getInternalName(node), "prototype");
        }
        function hasSynthesizedDefaultSuperCall(constructor, hasExtendsClause) {
            if (!constructor || !hasExtendsClause) {
                return false;
            }
            if (ts.some(constructor.parameters)) {
                return false;
            }
            var statement = ts.firstOrUndefined(constructor.body.statements);
            if (!statement || !ts.nodeIsSynthesized(statement) || statement.kind !== 210) {
                return false;
            }
            var statementExpression = statement.expression;
            if (!ts.nodeIsSynthesized(statementExpression) || statementExpression.kind !== 181) {
                return false;
            }
            var callTarget = statementExpression.expression;
            if (!ts.nodeIsSynthesized(callTarget) || callTarget.kind !== 97) {
                return false;
            }
            var callArgument = ts.singleOrUndefined(statementExpression.arguments);
            if (!callArgument || !ts.nodeIsSynthesized(callArgument) || callArgument.kind !== 198) {
                return false;
            }
            var expression = callArgument.expression;
            return ts.isIdentifier(expression) && expression.text === "arguments";
        }
    }
    ts.transformES2015 = transformES2015;
    function createExtendsHelper(context, name) {
        context.requestEmitHelper(extendsHelper);
        return ts.createCall(ts.getHelperName("__extends"), undefined, [
            name,
            ts.createIdentifier("_super")
        ]);
    }
    var extendsHelper = {
        name: "typescript:extends",
        scoped: false,
        priority: 0,
        text: "\n            var __extends = (this && this.__extends) || (function () {\n                var extendStatics = Object.setPrototypeOf ||\n                    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return function (d, b) {\n                    extendStatics(d, b);\n                    function __() { this.constructor = d; }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            })();"
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var OpCode;
    (function (OpCode) {
        OpCode[OpCode["Nop"] = 0] = "Nop";
        OpCode[OpCode["Statement"] = 1] = "Statement";
        OpCode[OpCode["Assign"] = 2] = "Assign";
        OpCode[OpCode["Break"] = 3] = "Break";
        OpCode[OpCode["BreakWhenTrue"] = 4] = "BreakWhenTrue";
        OpCode[OpCode["BreakWhenFalse"] = 5] = "BreakWhenFalse";
        OpCode[OpCode["Yield"] = 6] = "Yield";
        OpCode[OpCode["YieldStar"] = 7] = "YieldStar";
        OpCode[OpCode["Return"] = 8] = "Return";
        OpCode[OpCode["Throw"] = 9] = "Throw";
        OpCode[OpCode["Endfinally"] = 10] = "Endfinally";
    })(OpCode || (OpCode = {}));
    var BlockAction;
    (function (BlockAction) {
        BlockAction[BlockAction["Open"] = 0] = "Open";
        BlockAction[BlockAction["Close"] = 1] = "Close";
    })(BlockAction || (BlockAction = {}));
    var CodeBlockKind;
    (function (CodeBlockKind) {
        CodeBlockKind[CodeBlockKind["Exception"] = 0] = "Exception";
        CodeBlockKind[CodeBlockKind["With"] = 1] = "With";
        CodeBlockKind[CodeBlockKind["Switch"] = 2] = "Switch";
        CodeBlockKind[CodeBlockKind["Loop"] = 3] = "Loop";
        CodeBlockKind[CodeBlockKind["Labeled"] = 4] = "Labeled";
    })(CodeBlockKind || (CodeBlockKind = {}));
    var ExceptionBlockState;
    (function (ExceptionBlockState) {
        ExceptionBlockState[ExceptionBlockState["Try"] = 0] = "Try";
        ExceptionBlockState[ExceptionBlockState["Catch"] = 1] = "Catch";
        ExceptionBlockState[ExceptionBlockState["Finally"] = 2] = "Finally";
        ExceptionBlockState[ExceptionBlockState["Done"] = 3] = "Done";
    })(ExceptionBlockState || (ExceptionBlockState = {}));
    var Instruction;
    (function (Instruction) {
        Instruction[Instruction["Next"] = 0] = "Next";
        Instruction[Instruction["Throw"] = 1] = "Throw";
        Instruction[Instruction["Return"] = 2] = "Return";
        Instruction[Instruction["Break"] = 3] = "Break";
        Instruction[Instruction["Yield"] = 4] = "Yield";
        Instruction[Instruction["YieldStar"] = 5] = "YieldStar";
        Instruction[Instruction["Catch"] = 6] = "Catch";
        Instruction[Instruction["Endfinally"] = 7] = "Endfinally";
    })(Instruction || (Instruction = {}));
    function getInstructionName(instruction) {
        switch (instruction) {
            case 2: return "return";
            case 3: return "break";
            case 4: return "yield";
            case 5: return "yield*";
            case 7: return "endfinally";
        }
    }
    function transformGenerators(context) {
        var resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistFunctionDeclaration = context.hoistFunctionDeclaration, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var resolver = context.getEmitResolver();
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var currentSourceFile;
        var renamedCatchVariables;
        var renamedCatchVariableDeclarations;
        var inGeneratorFunctionBody;
        var inStatementContainingYield;
        var blocks;
        var blockOffsets;
        var blockActions;
        var blockStack;
        var labelOffsets;
        var labelExpressions;
        var nextLabelId = 1;
        var operations;
        var operationArguments;
        var operationLocations;
        var state;
        var blockIndex = 0;
        var labelNumber = 0;
        var labelNumbers;
        var lastOperationWasAbrupt;
        var lastOperationWasCompletion;
        var clauses;
        var statements;
        var exceptionBlockStack;
        var currentExceptionBlock;
        var withBlockStack;
        return transformSourceFile;
        function transformSourceFile(node) {
            if (ts.isDeclarationFile(node)
                || (node.transformFlags & 512) === 0) {
                return node;
            }
            currentSourceFile = node;
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            return visited;
        }
        function visitor(node) {
            var transformFlags = node.transformFlags;
            if (inStatementContainingYield) {
                return visitJavaScriptInStatementContainingYield(node);
            }
            else if (inGeneratorFunctionBody) {
                return visitJavaScriptInGeneratorFunctionBody(node);
            }
            else if (transformFlags & 256) {
                return visitGenerator(node);
            }
            else if (transformFlags & 512) {
                return ts.visitEachChild(node, visitor, context);
            }
            else {
                return node;
            }
        }
        function visitJavaScriptInStatementContainingYield(node) {
            switch (node.kind) {
                case 212:
                    return visitDoStatement(node);
                case 213:
                    return visitWhileStatement(node);
                case 221:
                    return visitSwitchStatement(node);
                case 222:
                    return visitLabeledStatement(node);
                default:
                    return visitJavaScriptInGeneratorFunctionBody(node);
            }
        }
        function visitJavaScriptInGeneratorFunctionBody(node) {
            switch (node.kind) {
                case 228:
                    return visitFunctionDeclaration(node);
                case 186:
                    return visitFunctionExpression(node);
                case 153:
                case 154:
                    return visitAccessorDeclaration(node);
                case 208:
                    return visitVariableStatement(node);
                case 214:
                    return visitForStatement(node);
                case 215:
                    return visitForInStatement(node);
                case 218:
                    return visitBreakStatement(node);
                case 217:
                    return visitContinueStatement(node);
                case 219:
                    return visitReturnStatement(node);
                default:
                    if (node.transformFlags & 16777216) {
                        return visitJavaScriptContainingYield(node);
                    }
                    else if (node.transformFlags & (512 | 33554432)) {
                        return ts.visitEachChild(node, visitor, context);
                    }
                    else {
                        return node;
                    }
            }
        }
        function visitJavaScriptContainingYield(node) {
            switch (node.kind) {
                case 194:
                    return visitBinaryExpression(node);
                case 195:
                    return visitConditionalExpression(node);
                case 197:
                    return visitYieldExpression(node);
                case 177:
                    return visitArrayLiteralExpression(node);
                case 178:
                    return visitObjectLiteralExpression(node);
                case 180:
                    return visitElementAccessExpression(node);
                case 181:
                    return visitCallExpression(node);
                case 182:
                    return visitNewExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitGenerator(node) {
            switch (node.kind) {
                case 228:
                    return visitFunctionDeclaration(node);
                case 186:
                    return visitFunctionExpression(node);
                default:
                    ts.Debug.failBadSyntaxKind(node);
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitFunctionDeclaration(node) {
            if (node.asteriskToken) {
                node = ts.setOriginalNode(ts.setTextRange(ts.createFunctionDeclaration(undefined, node.modifiers, undefined, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, transformGeneratorFunctionBody(node.body)), node), node);
            }
            else {
                var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
                var savedInStatementContainingYield = inStatementContainingYield;
                inGeneratorFunctionBody = false;
                inStatementContainingYield = false;
                node = ts.visitEachChild(node, visitor, context);
                inGeneratorFunctionBody = savedInGeneratorFunctionBody;
                inStatementContainingYield = savedInStatementContainingYield;
            }
            if (inGeneratorFunctionBody) {
                hoistFunctionDeclaration(node);
                return undefined;
            }
            else {
                return node;
            }
        }
        function visitFunctionExpression(node) {
            if (node.asteriskToken) {
                node = ts.setOriginalNode(ts.setTextRange(ts.createFunctionExpression(undefined, undefined, node.name, undefined, ts.visitParameterList(node.parameters, visitor, context), undefined, transformGeneratorFunctionBody(node.body)), node), node);
            }
            else {
                var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
                var savedInStatementContainingYield = inStatementContainingYield;
                inGeneratorFunctionBody = false;
                inStatementContainingYield = false;
                node = ts.visitEachChild(node, visitor, context);
                inGeneratorFunctionBody = savedInGeneratorFunctionBody;
                inStatementContainingYield = savedInStatementContainingYield;
            }
            return node;
        }
        function visitAccessorDeclaration(node) {
            var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
            var savedInStatementContainingYield = inStatementContainingYield;
            inGeneratorFunctionBody = false;
            inStatementContainingYield = false;
            node = ts.visitEachChild(node, visitor, context);
            inGeneratorFunctionBody = savedInGeneratorFunctionBody;
            inStatementContainingYield = savedInStatementContainingYield;
            return node;
        }
        function transformGeneratorFunctionBody(body) {
            var statements = [];
            var savedInGeneratorFunctionBody = inGeneratorFunctionBody;
            var savedInStatementContainingYield = inStatementContainingYield;
            var savedBlocks = blocks;
            var savedBlockOffsets = blockOffsets;
            var savedBlockActions = blockActions;
            var savedBlockStack = blockStack;
            var savedLabelOffsets = labelOffsets;
            var savedLabelExpressions = labelExpressions;
            var savedNextLabelId = nextLabelId;
            var savedOperations = operations;
            var savedOperationArguments = operationArguments;
            var savedOperationLocations = operationLocations;
            var savedState = state;
            inGeneratorFunctionBody = true;
            inStatementContainingYield = false;
            blocks = undefined;
            blockOffsets = undefined;
            blockActions = undefined;
            blockStack = undefined;
            labelOffsets = undefined;
            labelExpressions = undefined;
            nextLabelId = 1;
            operations = undefined;
            operationArguments = undefined;
            operationLocations = undefined;
            state = ts.createTempVariable(undefined);
            resumeLexicalEnvironment();
            var statementOffset = ts.addPrologue(statements, body.statements, false, visitor);
            transformAndEmitStatements(body.statements, statementOffset);
            var buildResult = build();
            ts.addRange(statements, endLexicalEnvironment());
            statements.push(ts.createReturn(buildResult));
            inGeneratorFunctionBody = savedInGeneratorFunctionBody;
            inStatementContainingYield = savedInStatementContainingYield;
            blocks = savedBlocks;
            blockOffsets = savedBlockOffsets;
            blockActions = savedBlockActions;
            blockStack = savedBlockStack;
            labelOffsets = savedLabelOffsets;
            labelExpressions = savedLabelExpressions;
            nextLabelId = savedNextLabelId;
            operations = savedOperations;
            operationArguments = savedOperationArguments;
            operationLocations = savedOperationLocations;
            state = savedState;
            return ts.setTextRange(ts.createBlock(statements, body.multiLine), body);
        }
        function visitVariableStatement(node) {
            if (node.transformFlags & 16777216) {
                transformAndEmitVariableDeclarationList(node.declarationList);
                return undefined;
            }
            else {
                if (ts.getEmitFlags(node) & 1048576) {
                    return node;
                }
                for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    hoistVariableDeclaration(variable.name);
                }
                var variables = ts.getInitializedVariables(node.declarationList);
                if (variables.length === 0) {
                    return undefined;
                }
                return ts.createStatement(ts.inlineExpressions(ts.map(variables, transformInitializedVariable)));
            }
        }
        function visitBinaryExpression(node) {
            switch (ts.getExpressionAssociativity(node)) {
                case 0:
                    return visitLeftAssociativeBinaryExpression(node);
                case 1:
                    return visitRightAssociativeBinaryExpression(node);
                default:
                    ts.Debug.fail("Unknown associativity.");
            }
        }
        function isCompoundAssignment(kind) {
            return kind >= 59
                && kind <= 70;
        }
        function getOperatorForCompoundAssignment(kind) {
            switch (kind) {
                case 59: return 37;
                case 60: return 38;
                case 61: return 39;
                case 62: return 40;
                case 63: return 41;
                case 64: return 42;
                case 65: return 45;
                case 66: return 46;
                case 67: return 47;
                case 68: return 48;
                case 69: return 49;
                case 70: return 50;
            }
        }
        function visitRightAssociativeBinaryExpression(node) {
            var left = node.left, right = node.right;
            if (containsYield(right)) {
                var target = void 0;
                switch (left.kind) {
                    case 179:
                        target = ts.updatePropertyAccess(left, cacheExpression(ts.visitNode(left.expression, visitor, ts.isLeftHandSideExpression)), left.name);
                        break;
                    case 180:
                        target = ts.updateElementAccess(left, cacheExpression(ts.visitNode(left.expression, visitor, ts.isLeftHandSideExpression)), cacheExpression(ts.visitNode(left.argumentExpression, visitor, ts.isExpression)));
                        break;
                    default:
                        target = ts.visitNode(left, visitor, ts.isExpression);
                        break;
                }
                var operator = node.operatorToken.kind;
                if (isCompoundAssignment(operator)) {
                    return ts.setTextRange(ts.createAssignment(target, ts.setTextRange(ts.createBinary(cacheExpression(target), getOperatorForCompoundAssignment(operator), ts.visitNode(right, visitor, ts.isExpression)), node)), node);
                }
                else {
                    return ts.updateBinary(node, target, ts.visitNode(right, visitor, ts.isExpression));
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitLeftAssociativeBinaryExpression(node) {
            if (containsYield(node.right)) {
                if (ts.isLogicalOperator(node.operatorToken.kind)) {
                    return visitLogicalBinaryExpression(node);
                }
                else if (node.operatorToken.kind === 26) {
                    return visitCommaExpression(node);
                }
                var clone_5 = ts.getMutableClone(node);
                clone_5.left = cacheExpression(ts.visitNode(node.left, visitor, ts.isExpression));
                clone_5.right = ts.visitNode(node.right, visitor, ts.isExpression);
                return clone_5;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitLogicalBinaryExpression(node) {
            var resultLabel = defineLabel();
            var resultLocal = declareLocal();
            emitAssignment(resultLocal, ts.visitNode(node.left, visitor, ts.isExpression), node.left);
            if (node.operatorToken.kind === 53) {
                emitBreakWhenFalse(resultLabel, resultLocal, node.left);
            }
            else {
                emitBreakWhenTrue(resultLabel, resultLocal, node.left);
            }
            emitAssignment(resultLocal, ts.visitNode(node.right, visitor, ts.isExpression), node.right);
            markLabel(resultLabel);
            return resultLocal;
        }
        function visitCommaExpression(node) {
            var pendingExpressions = [];
            visit(node.left);
            visit(node.right);
            return ts.inlineExpressions(pendingExpressions);
            function visit(node) {
                if (ts.isBinaryExpression(node) && node.operatorToken.kind === 26) {
                    visit(node.left);
                    visit(node.right);
                }
                else {
                    if (containsYield(node) && pendingExpressions.length > 0) {
                        emitWorker(1, [ts.createStatement(ts.inlineExpressions(pendingExpressions))]);
                        pendingExpressions = [];
                    }
                    pendingExpressions.push(ts.visitNode(node, visitor, ts.isExpression));
                }
            }
        }
        function visitConditionalExpression(node) {
            if (containsYield(node.whenTrue) || containsYield(node.whenFalse)) {
                var whenFalseLabel = defineLabel();
                var resultLabel = defineLabel();
                var resultLocal = declareLocal();
                emitBreakWhenFalse(whenFalseLabel, ts.visitNode(node.condition, visitor, ts.isExpression), node.condition);
                emitAssignment(resultLocal, ts.visitNode(node.whenTrue, visitor, ts.isExpression), node.whenTrue);
                emitBreak(resultLabel);
                markLabel(whenFalseLabel);
                emitAssignment(resultLocal, ts.visitNode(node.whenFalse, visitor, ts.isExpression), node.whenFalse);
                markLabel(resultLabel);
                return resultLocal;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitYieldExpression(node) {
            var resumeLabel = defineLabel();
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            if (node.asteriskToken) {
                var iterator = (ts.getEmitFlags(node.expression) & 8388608) === 0
                    ? ts.createValuesHelper(context, expression, node)
                    : expression;
                emitYieldStar(iterator, node);
            }
            else {
                emitYield(expression, node);
            }
            markLabel(resumeLabel);
            return createGeneratorResume(node);
        }
        function visitArrayLiteralExpression(node) {
            return visitElements(node.elements, undefined, undefined, node.multiLine);
        }
        function visitElements(elements, leadingElement, location, multiLine) {
            var numInitialElements = countInitialNodesWithoutYield(elements);
            var temp;
            if (numInitialElements > 0) {
                temp = declareLocal();
                var initialElements = ts.visitNodes(elements, visitor, ts.isExpression, 0, numInitialElements);
                emitAssignment(temp, ts.createArrayLiteral(leadingElement
                    ? [leadingElement].concat(initialElements) : initialElements));
                leadingElement = undefined;
            }
            var expressions = ts.reduceLeft(elements, reduceElement, [], numInitialElements);
            return temp
                ? ts.createArrayConcat(temp, [ts.createArrayLiteral(expressions, multiLine)])
                : ts.setTextRange(ts.createArrayLiteral(leadingElement ? [leadingElement].concat(expressions) : expressions, multiLine), location);
            function reduceElement(expressions, element) {
                if (containsYield(element) && expressions.length > 0) {
                    var hasAssignedTemp = temp !== undefined;
                    if (!temp) {
                        temp = declareLocal();
                    }
                    emitAssignment(temp, hasAssignedTemp
                        ? ts.createArrayConcat(temp, [ts.createArrayLiteral(expressions, multiLine)])
                        : ts.createArrayLiteral(leadingElement ? [leadingElement].concat(expressions) : expressions, multiLine));
                    leadingElement = undefined;
                    expressions = [];
                }
                expressions.push(ts.visitNode(element, visitor, ts.isExpression));
                return expressions;
            }
        }
        function visitObjectLiteralExpression(node) {
            var properties = node.properties;
            var multiLine = node.multiLine;
            var numInitialProperties = countInitialNodesWithoutYield(properties);
            var temp = declareLocal();
            emitAssignment(temp, ts.createObjectLiteral(ts.visitNodes(properties, visitor, ts.isObjectLiteralElementLike, 0, numInitialProperties), multiLine));
            var expressions = ts.reduceLeft(properties, reduceProperty, [], numInitialProperties);
            expressions.push(multiLine ? ts.startOnNewLine(ts.getMutableClone(temp)) : temp);
            return ts.inlineExpressions(expressions);
            function reduceProperty(expressions, property) {
                if (containsYield(property) && expressions.length > 0) {
                    emitStatement(ts.createStatement(ts.inlineExpressions(expressions)));
                    expressions = [];
                }
                var expression = ts.createExpressionForObjectLiteralElementLike(node, property, temp);
                var visited = ts.visitNode(expression, visitor, ts.isExpression);
                if (visited) {
                    if (multiLine) {
                        visited.startsOnNewLine = true;
                    }
                    expressions.push(visited);
                }
                return expressions;
            }
        }
        function visitElementAccessExpression(node) {
            if (containsYield(node.argumentExpression)) {
                var clone_6 = ts.getMutableClone(node);
                clone_6.expression = cacheExpression(ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression));
                clone_6.argumentExpression = ts.visitNode(node.argumentExpression, visitor, ts.isExpression);
                return clone_6;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCallExpression(node) {
            if (ts.forEach(node.arguments, containsYield)) {
                var _a = ts.createCallBinding(node.expression, hoistVariableDeclaration, languageVersion, true), target = _a.target, thisArg = _a.thisArg;
                return ts.setOriginalNode(ts.createFunctionApply(cacheExpression(ts.visitNode(target, visitor, ts.isLeftHandSideExpression)), thisArg, visitElements(node.arguments), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitNewExpression(node) {
            if (ts.forEach(node.arguments, containsYield)) {
                var _a = ts.createCallBinding(ts.createPropertyAccess(node.expression, "bind"), hoistVariableDeclaration), target = _a.target, thisArg = _a.thisArg;
                return ts.setOriginalNode(ts.setTextRange(ts.createNew(ts.createFunctionApply(cacheExpression(ts.visitNode(target, visitor, ts.isExpression)), thisArg, visitElements(node.arguments, ts.createVoidZero())), undefined, []), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndEmitStatements(statements, start) {
            if (start === void 0) { start = 0; }
            var numStatements = statements.length;
            for (var i = start; i < numStatements; i++) {
                transformAndEmitStatement(statements[i]);
            }
        }
        function transformAndEmitEmbeddedStatement(node) {
            if (ts.isBlock(node)) {
                transformAndEmitStatements(node.statements);
            }
            else {
                transformAndEmitStatement(node);
            }
        }
        function transformAndEmitStatement(node) {
            var savedInStatementContainingYield = inStatementContainingYield;
            if (!inStatementContainingYield) {
                inStatementContainingYield = containsYield(node);
            }
            transformAndEmitStatementWorker(node);
            inStatementContainingYield = savedInStatementContainingYield;
        }
        function transformAndEmitStatementWorker(node) {
            switch (node.kind) {
                case 207:
                    return transformAndEmitBlock(node);
                case 210:
                    return transformAndEmitExpressionStatement(node);
                case 211:
                    return transformAndEmitIfStatement(node);
                case 212:
                    return transformAndEmitDoStatement(node);
                case 213:
                    return transformAndEmitWhileStatement(node);
                case 214:
                    return transformAndEmitForStatement(node);
                case 215:
                    return transformAndEmitForInStatement(node);
                case 217:
                    return transformAndEmitContinueStatement(node);
                case 218:
                    return transformAndEmitBreakStatement(node);
                case 219:
                    return transformAndEmitReturnStatement(node);
                case 220:
                    return transformAndEmitWithStatement(node);
                case 221:
                    return transformAndEmitSwitchStatement(node);
                case 222:
                    return transformAndEmitLabeledStatement(node);
                case 223:
                    return transformAndEmitThrowStatement(node);
                case 224:
                    return transformAndEmitTryStatement(node);
                default:
                    return emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitBlock(node) {
            if (containsYield(node)) {
                transformAndEmitStatements(node.statements);
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitExpressionStatement(node) {
            emitStatement(ts.visitNode(node, visitor, ts.isStatement));
        }
        function transformAndEmitVariableDeclarationList(node) {
            for (var _i = 0, _a = node.declarations; _i < _a.length; _i++) {
                var variable = _a[_i];
                var name = ts.getSynthesizedClone(variable.name);
                ts.setCommentRange(name, variable.name);
                hoistVariableDeclaration(name);
            }
            var variables = ts.getInitializedVariables(node);
            var numVariables = variables.length;
            var variablesWritten = 0;
            var pendingExpressions = [];
            while (variablesWritten < numVariables) {
                for (var i = variablesWritten; i < numVariables; i++) {
                    var variable = variables[i];
                    if (containsYield(variable.initializer) && pendingExpressions.length > 0) {
                        break;
                    }
                    pendingExpressions.push(transformInitializedVariable(variable));
                }
                if (pendingExpressions.length) {
                    emitStatement(ts.createStatement(ts.inlineExpressions(pendingExpressions)));
                    variablesWritten += pendingExpressions.length;
                    pendingExpressions = [];
                }
            }
            return undefined;
        }
        function transformInitializedVariable(node) {
            return ts.createAssignment(ts.getSynthesizedClone(node.name), ts.visitNode(node.initializer, visitor, ts.isExpression));
        }
        function transformAndEmitIfStatement(node) {
            if (containsYield(node)) {
                if (containsYield(node.thenStatement) || containsYield(node.elseStatement)) {
                    var endLabel = defineLabel();
                    var elseLabel = node.elseStatement ? defineLabel() : undefined;
                    emitBreakWhenFalse(node.elseStatement ? elseLabel : endLabel, ts.visitNode(node.expression, visitor, ts.isExpression), node.expression);
                    transformAndEmitEmbeddedStatement(node.thenStatement);
                    if (node.elseStatement) {
                        emitBreak(endLabel);
                        markLabel(elseLabel);
                        transformAndEmitEmbeddedStatement(node.elseStatement);
                    }
                    markLabel(endLabel);
                }
                else {
                    emitStatement(ts.visitNode(node, visitor, ts.isStatement));
                }
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitDoStatement(node) {
            if (containsYield(node)) {
                var conditionLabel = defineLabel();
                var loopLabel = defineLabel();
                beginLoopBlock(conditionLabel);
                markLabel(loopLabel);
                transformAndEmitEmbeddedStatement(node.statement);
                markLabel(conditionLabel);
                emitBreakWhenTrue(loopLabel, ts.visitNode(node.expression, visitor, ts.isExpression));
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitDoStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
                node = ts.visitEachChild(node, visitor, context);
                endLoopBlock();
                return node;
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformAndEmitWhileStatement(node) {
            if (containsYield(node)) {
                var loopLabel = defineLabel();
                var endLabel = beginLoopBlock(loopLabel);
                markLabel(loopLabel);
                emitBreakWhenFalse(endLabel, ts.visitNode(node.expression, visitor, ts.isExpression));
                transformAndEmitEmbeddedStatement(node.statement);
                emitBreak(loopLabel);
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitWhileStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
                node = ts.visitEachChild(node, visitor, context);
                endLoopBlock();
                return node;
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformAndEmitForStatement(node) {
            if (containsYield(node)) {
                var conditionLabel = defineLabel();
                var incrementLabel = defineLabel();
                var endLabel = beginLoopBlock(incrementLabel);
                if (node.initializer) {
                    var initializer = node.initializer;
                    if (ts.isVariableDeclarationList(initializer)) {
                        transformAndEmitVariableDeclarationList(initializer);
                    }
                    else {
                        emitStatement(ts.setTextRange(ts.createStatement(ts.visitNode(initializer, visitor, ts.isExpression)), initializer));
                    }
                }
                markLabel(conditionLabel);
                if (node.condition) {
                    emitBreakWhenFalse(endLabel, ts.visitNode(node.condition, visitor, ts.isExpression));
                }
                transformAndEmitEmbeddedStatement(node.statement);
                markLabel(incrementLabel);
                if (node.incrementor) {
                    emitStatement(ts.setTextRange(ts.createStatement(ts.visitNode(node.incrementor, visitor, ts.isExpression)), node.incrementor));
                }
                emitBreak(conditionLabel);
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitForStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
            }
            var initializer = node.initializer;
            if (initializer && ts.isVariableDeclarationList(initializer)) {
                for (var _i = 0, _a = initializer.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    hoistVariableDeclaration(variable.name);
                }
                var variables = ts.getInitializedVariables(initializer);
                node = ts.updateFor(node, variables.length > 0
                    ? ts.inlineExpressions(ts.map(variables, transformInitializedVariable))
                    : undefined, ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitor, ts.isExpression), ts.visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock));
            }
            else {
                node = ts.visitEachChild(node, visitor, context);
            }
            if (inStatementContainingYield) {
                endLoopBlock();
            }
            return node;
        }
        function transformAndEmitForInStatement(node) {
            if (containsYield(node)) {
                var keysArray = declareLocal();
                var key = declareLocal();
                var keysIndex = ts.createLoopVariable();
                var initializer = node.initializer;
                hoistVariableDeclaration(keysIndex);
                emitAssignment(keysArray, ts.createArrayLiteral());
                emitStatement(ts.createForIn(key, ts.visitNode(node.expression, visitor, ts.isExpression), ts.createStatement(ts.createCall(ts.createPropertyAccess(keysArray, "push"), undefined, [key]))));
                emitAssignment(keysIndex, ts.createLiteral(0));
                var conditionLabel = defineLabel();
                var incrementLabel = defineLabel();
                var endLabel = beginLoopBlock(incrementLabel);
                markLabel(conditionLabel);
                emitBreakWhenFalse(endLabel, ts.createLessThan(keysIndex, ts.createPropertyAccess(keysArray, "length")));
                var variable = void 0;
                if (ts.isVariableDeclarationList(initializer)) {
                    for (var _i = 0, _a = initializer.declarations; _i < _a.length; _i++) {
                        var variable_1 = _a[_i];
                        hoistVariableDeclaration(variable_1.name);
                    }
                    variable = ts.getSynthesizedClone(initializer.declarations[0].name);
                }
                else {
                    variable = ts.visitNode(initializer, visitor, ts.isExpression);
                    ts.Debug.assert(ts.isLeftHandSideExpression(variable));
                }
                emitAssignment(variable, ts.createElementAccess(keysArray, keysIndex));
                transformAndEmitEmbeddedStatement(node.statement);
                markLabel(incrementLabel);
                emitStatement(ts.createStatement(ts.createPostfixIncrement(keysIndex)));
                emitBreak(conditionLabel);
                endLoopBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitForInStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLoopBlock();
            }
            var initializer = node.initializer;
            if (ts.isVariableDeclarationList(initializer)) {
                for (var _i = 0, _a = initializer.declarations; _i < _a.length; _i++) {
                    var variable = _a[_i];
                    hoistVariableDeclaration(variable.name);
                }
                node = ts.updateForIn(node, initializer.declarations[0].name, ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitNode(node.statement, visitor, ts.isStatement, ts.liftToBlock));
            }
            else {
                node = ts.visitEachChild(node, visitor, context);
            }
            if (inStatementContainingYield) {
                endLoopBlock();
            }
            return node;
        }
        function transformAndEmitContinueStatement(node) {
            var label = findContinueTarget(node.label ? node.label.text : undefined);
            ts.Debug.assert(label > 0, "Expected continue statment to point to a valid Label.");
            emitBreak(label, node);
        }
        function visitContinueStatement(node) {
            if (inStatementContainingYield) {
                var label = findContinueTarget(node.label && node.label.text);
                if (label > 0) {
                    return createInlineBreak(label, node);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndEmitBreakStatement(node) {
            var label = findBreakTarget(node.label ? node.label.text : undefined);
            ts.Debug.assert(label > 0, "Expected break statment to point to a valid Label.");
            emitBreak(label, node);
        }
        function visitBreakStatement(node) {
            if (inStatementContainingYield) {
                var label = findBreakTarget(node.label && node.label.text);
                if (label > 0) {
                    return createInlineBreak(label, node);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformAndEmitReturnStatement(node) {
            emitReturn(ts.visitNode(node.expression, visitor, ts.isExpression), node);
        }
        function visitReturnStatement(node) {
            return createInlineReturn(ts.visitNode(node.expression, visitor, ts.isExpression), node);
        }
        function transformAndEmitWithStatement(node) {
            if (containsYield(node)) {
                beginWithBlock(cacheExpression(ts.visitNode(node.expression, visitor, ts.isExpression)));
                transformAndEmitEmbeddedStatement(node.statement);
                endWithBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function transformAndEmitSwitchStatement(node) {
            if (containsYield(node.caseBlock)) {
                var caseBlock = node.caseBlock;
                var numClauses = caseBlock.clauses.length;
                var endLabel = beginSwitchBlock();
                var expression = cacheExpression(ts.visitNode(node.expression, visitor, ts.isExpression));
                var clauseLabels = [];
                var defaultClauseIndex = -1;
                for (var i = 0; i < numClauses; i++) {
                    var clause = caseBlock.clauses[i];
                    clauseLabels.push(defineLabel());
                    if (clause.kind === 258 && defaultClauseIndex === -1) {
                        defaultClauseIndex = i;
                    }
                }
                var clausesWritten = 0;
                var pendingClauses = [];
                while (clausesWritten < numClauses) {
                    var defaultClausesSkipped = 0;
                    for (var i = clausesWritten; i < numClauses; i++) {
                        var clause = caseBlock.clauses[i];
                        if (clause.kind === 257) {
                            var caseClause = clause;
                            if (containsYield(caseClause.expression) && pendingClauses.length > 0) {
                                break;
                            }
                            pendingClauses.push(ts.createCaseClause(ts.visitNode(caseClause.expression, visitor, ts.isExpression), [
                                createInlineBreak(clauseLabels[i], caseClause.expression)
                            ]));
                        }
                        else {
                            defaultClausesSkipped++;
                        }
                    }
                    if (pendingClauses.length) {
                        emitStatement(ts.createSwitch(expression, ts.createCaseBlock(pendingClauses)));
                        clausesWritten += pendingClauses.length;
                        pendingClauses = [];
                    }
                    if (defaultClausesSkipped > 0) {
                        clausesWritten += defaultClausesSkipped;
                        defaultClausesSkipped = 0;
                    }
                }
                if (defaultClauseIndex >= 0) {
                    emitBreak(clauseLabels[defaultClauseIndex]);
                }
                else {
                    emitBreak(endLabel);
                }
                for (var i = 0; i < numClauses; i++) {
                    markLabel(clauseLabels[i]);
                    transformAndEmitStatements(caseBlock.clauses[i].statements);
                }
                endSwitchBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitSwitchStatement(node) {
            if (inStatementContainingYield) {
                beginScriptSwitchBlock();
            }
            node = ts.visitEachChild(node, visitor, context);
            if (inStatementContainingYield) {
                endSwitchBlock();
            }
            return node;
        }
        function transformAndEmitLabeledStatement(node) {
            if (containsYield(node)) {
                beginLabeledBlock(node.label.text);
                transformAndEmitEmbeddedStatement(node.statement);
                endLabeledBlock();
            }
            else {
                emitStatement(ts.visitNode(node, visitor, ts.isStatement));
            }
        }
        function visitLabeledStatement(node) {
            if (inStatementContainingYield) {
                beginScriptLabeledBlock(node.label.text);
            }
            node = ts.visitEachChild(node, visitor, context);
            if (inStatementContainingYield) {
                endLabeledBlock();
            }
            return node;
        }
        function transformAndEmitThrowStatement(node) {
            emitThrow(ts.visitNode(node.expression, visitor, ts.isExpression), node);
        }
        function transformAndEmitTryStatement(node) {
            if (containsYield(node)) {
                beginExceptionBlock();
                transformAndEmitEmbeddedStatement(node.tryBlock);
                if (node.catchClause) {
                    beginCatchBlock(node.catchClause.variableDeclaration);
                    transformAndEmitEmbeddedStatement(node.catchClause.block);
                }
                if (node.finallyBlock) {
                    beginFinallyBlock();
                    transformAndEmitEmbeddedStatement(node.finallyBlock);
                }
                endExceptionBlock();
            }
            else {
                emitStatement(ts.visitEachChild(node, visitor, context));
            }
        }
        function containsYield(node) {
            return node && (node.transformFlags & 16777216) !== 0;
        }
        function countInitialNodesWithoutYield(nodes) {
            var numNodes = nodes.length;
            for (var i = 0; i < numNodes; i++) {
                if (containsYield(nodes[i])) {
                    return i;
                }
            }
            return -1;
        }
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            if (ts.isIdentifier(node)) {
                return substituteExpressionIdentifier(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            if (!ts.isGeneratedIdentifier(node) && renamedCatchVariables && renamedCatchVariables.has(node.text)) {
                var original = ts.getOriginalNode(node);
                if (ts.isIdentifier(original) && original.parent) {
                    var declaration = resolver.getReferencedValueDeclaration(original);
                    if (declaration) {
                        var name = renamedCatchVariableDeclarations[ts.getOriginalNodeId(declaration)];
                        if (name) {
                            var clone_7 = ts.getMutableClone(name);
                            ts.setSourceMapRange(clone_7, node);
                            ts.setCommentRange(clone_7, node);
                            return clone_7;
                        }
                    }
                }
            }
            return node;
        }
        function cacheExpression(node) {
            var temp;
            if (ts.isGeneratedIdentifier(node) || ts.getEmitFlags(node) & 4096) {
                return node;
            }
            temp = ts.createTempVariable(hoistVariableDeclaration);
            emitAssignment(temp, node, node);
            return temp;
        }
        function declareLocal(name) {
            var temp = name
                ? ts.createUniqueName(name)
                : ts.createTempVariable(undefined);
            hoistVariableDeclaration(temp);
            return temp;
        }
        function defineLabel() {
            if (!labelOffsets) {
                labelOffsets = [];
            }
            var label = nextLabelId;
            nextLabelId++;
            labelOffsets[label] = -1;
            return label;
        }
        function markLabel(label) {
            ts.Debug.assert(labelOffsets !== undefined, "No labels were defined.");
            labelOffsets[label] = operations ? operations.length : 0;
        }
        function beginBlock(block) {
            if (!blocks) {
                blocks = [];
                blockActions = [];
                blockOffsets = [];
                blockStack = [];
            }
            var index = blockActions.length;
            blockActions[index] = 0;
            blockOffsets[index] = operations ? operations.length : 0;
            blocks[index] = block;
            blockStack.push(block);
            return index;
        }
        function endBlock() {
            var block = peekBlock();
            ts.Debug.assert(block !== undefined, "beginBlock was never called.");
            var index = blockActions.length;
            blockActions[index] = 1;
            blockOffsets[index] = operations ? operations.length : 0;
            blocks[index] = block;
            blockStack.pop();
            return block;
        }
        function peekBlock() {
            return ts.lastOrUndefined(blockStack);
        }
        function peekBlockKind() {
            var block = peekBlock();
            return block && block.kind;
        }
        function beginWithBlock(expression) {
            var startLabel = defineLabel();
            var endLabel = defineLabel();
            markLabel(startLabel);
            beginBlock({
                kind: 1,
                expression: expression,
                startLabel: startLabel,
                endLabel: endLabel
            });
        }
        function endWithBlock() {
            ts.Debug.assert(peekBlockKind() === 1);
            var block = endBlock();
            markLabel(block.endLabel);
        }
        function isWithBlock(block) {
            return block.kind === 1;
        }
        function beginExceptionBlock() {
            var startLabel = defineLabel();
            var endLabel = defineLabel();
            markLabel(startLabel);
            beginBlock({
                kind: 0,
                state: 0,
                startLabel: startLabel,
                endLabel: endLabel
            });
            emitNop();
            return endLabel;
        }
        function beginCatchBlock(variable) {
            ts.Debug.assert(peekBlockKind() === 0);
            var name;
            if (ts.isGeneratedIdentifier(variable.name)) {
                name = variable.name;
                hoistVariableDeclaration(variable.name);
            }
            else {
                var text = variable.name.text;
                name = declareLocal(text);
                if (!renamedCatchVariables) {
                    renamedCatchVariables = ts.createMap();
                    renamedCatchVariableDeclarations = [];
                    context.enableSubstitution(71);
                }
                renamedCatchVariables.set(text, true);
                renamedCatchVariableDeclarations[ts.getOriginalNodeId(variable)] = name;
            }
            var exception = peekBlock();
            ts.Debug.assert(exception.state < 1);
            var endLabel = exception.endLabel;
            emitBreak(endLabel);
            var catchLabel = defineLabel();
            markLabel(catchLabel);
            exception.state = 1;
            exception.catchVariable = name;
            exception.catchLabel = catchLabel;
            emitAssignment(name, ts.createCall(ts.createPropertyAccess(state, "sent"), undefined, []));
            emitNop();
        }
        function beginFinallyBlock() {
            ts.Debug.assert(peekBlockKind() === 0);
            var exception = peekBlock();
            ts.Debug.assert(exception.state < 2);
            var endLabel = exception.endLabel;
            emitBreak(endLabel);
            var finallyLabel = defineLabel();
            markLabel(finallyLabel);
            exception.state = 2;
            exception.finallyLabel = finallyLabel;
        }
        function endExceptionBlock() {
            ts.Debug.assert(peekBlockKind() === 0);
            var exception = endBlock();
            var state = exception.state;
            if (state < 2) {
                emitBreak(exception.endLabel);
            }
            else {
                emitEndfinally();
            }
            markLabel(exception.endLabel);
            emitNop();
            exception.state = 3;
        }
        function isExceptionBlock(block) {
            return block.kind === 0;
        }
        function beginScriptLoopBlock() {
            beginBlock({
                kind: 3,
                isScript: true,
                breakLabel: -1,
                continueLabel: -1
            });
        }
        function beginLoopBlock(continueLabel) {
            var breakLabel = defineLabel();
            beginBlock({
                kind: 3,
                isScript: false,
                breakLabel: breakLabel,
                continueLabel: continueLabel
            });
            return breakLabel;
        }
        function endLoopBlock() {
            ts.Debug.assert(peekBlockKind() === 3);
            var block = endBlock();
            var breakLabel = block.breakLabel;
            if (!block.isScript) {
                markLabel(breakLabel);
            }
        }
        function beginScriptSwitchBlock() {
            beginBlock({
                kind: 2,
                isScript: true,
                breakLabel: -1
            });
        }
        function beginSwitchBlock() {
            var breakLabel = defineLabel();
            beginBlock({
                kind: 2,
                isScript: false,
                breakLabel: breakLabel
            });
            return breakLabel;
        }
        function endSwitchBlock() {
            ts.Debug.assert(peekBlockKind() === 2);
            var block = endBlock();
            var breakLabel = block.breakLabel;
            if (!block.isScript) {
                markLabel(breakLabel);
            }
        }
        function beginScriptLabeledBlock(labelText) {
            beginBlock({
                kind: 4,
                isScript: true,
                labelText: labelText,
                breakLabel: -1
            });
        }
        function beginLabeledBlock(labelText) {
            var breakLabel = defineLabel();
            beginBlock({
                kind: 4,
                isScript: false,
                labelText: labelText,
                breakLabel: breakLabel
            });
        }
        function endLabeledBlock() {
            ts.Debug.assert(peekBlockKind() === 4);
            var block = endBlock();
            if (!block.isScript) {
                markLabel(block.breakLabel);
            }
        }
        function supportsUnlabeledBreak(block) {
            return block.kind === 2
                || block.kind === 3;
        }
        function supportsLabeledBreakOrContinue(block) {
            return block.kind === 4;
        }
        function supportsUnlabeledContinue(block) {
            return block.kind === 3;
        }
        function hasImmediateContainingLabeledBlock(labelText, start) {
            for (var j = start; j >= 0; j--) {
                var containingBlock = blockStack[j];
                if (supportsLabeledBreakOrContinue(containingBlock)) {
                    if (containingBlock.labelText === labelText) {
                        return true;
                    }
                }
                else {
                    break;
                }
            }
            return false;
        }
        function findBreakTarget(labelText) {
            ts.Debug.assert(blocks !== undefined);
            if (labelText) {
                for (var i = blockStack.length - 1; i >= 0; i--) {
                    var block = blockStack[i];
                    if (supportsLabeledBreakOrContinue(block) && block.labelText === labelText) {
                        return block.breakLabel;
                    }
                    else if (supportsUnlabeledBreak(block) && hasImmediateContainingLabeledBlock(labelText, i - 1)) {
                        return block.breakLabel;
                    }
                }
            }
            else {
                for (var i = blockStack.length - 1; i >= 0; i--) {
                    var block = blockStack[i];
                    if (supportsUnlabeledBreak(block)) {
                        return block.breakLabel;
                    }
                }
            }
            return 0;
        }
        function findContinueTarget(labelText) {
            ts.Debug.assert(blocks !== undefined);
            if (labelText) {
                for (var i = blockStack.length - 1; i >= 0; i--) {
                    var block = blockStack[i];
                    if (supportsUnlabeledContinue(block) && hasImmediateContainingLabeledBlock(labelText, i - 1)) {
                        return block.continueLabel;
                    }
                }
            }
            else {
                for (var i = blockStack.length - 1; i >= 0; i--) {
                    var block = blockStack[i];
                    if (supportsUnlabeledContinue(block)) {
                        return block.continueLabel;
                    }
                }
            }
            return 0;
        }
        function createLabel(label) {
            if (label > 0) {
                if (labelExpressions === undefined) {
                    labelExpressions = [];
                }
                var expression = ts.createLiteral(-1);
                if (labelExpressions[label] === undefined) {
                    labelExpressions[label] = [expression];
                }
                else {
                    labelExpressions[label].push(expression);
                }
                return expression;
            }
            return ts.createOmittedExpression();
        }
        function createInstruction(instruction) {
            var literal = ts.createLiteral(instruction);
            ts.addSyntheticTrailingComment(literal, 3, getInstructionName(instruction));
            return literal;
        }
        function createInlineBreak(label, location) {
            ts.Debug.assert(label > 0, "Invalid label: " + label);
            return ts.setTextRange(ts.createReturn(ts.createArrayLiteral([
                createInstruction(3),
                createLabel(label)
            ])), location);
        }
        function createInlineReturn(expression, location) {
            return ts.setTextRange(ts.createReturn(ts.createArrayLiteral(expression
                ? [createInstruction(2), expression]
                : [createInstruction(2)])), location);
        }
        function createGeneratorResume(location) {
            return ts.setTextRange(ts.createCall(ts.createPropertyAccess(state, "sent"), undefined, []), location);
        }
        function emitNop() {
            emitWorker(0);
        }
        function emitStatement(node) {
            if (node) {
                emitWorker(1, [node]);
            }
            else {
                emitNop();
            }
        }
        function emitAssignment(left, right, location) {
            emitWorker(2, [left, right], location);
        }
        function emitBreak(label, location) {
            emitWorker(3, [label], location);
        }
        function emitBreakWhenTrue(label, condition, location) {
            emitWorker(4, [label, condition], location);
        }
        function emitBreakWhenFalse(label, condition, location) {
            emitWorker(5, [label, condition], location);
        }
        function emitYieldStar(expression, location) {
            emitWorker(7, [expression], location);
        }
        function emitYield(expression, location) {
            emitWorker(6, [expression], location);
        }
        function emitReturn(expression, location) {
            emitWorker(8, [expression], location);
        }
        function emitThrow(expression, location) {
            emitWorker(9, [expression], location);
        }
        function emitEndfinally() {
            emitWorker(10);
        }
        function emitWorker(code, args, location) {
            if (operations === undefined) {
                operations = [];
                operationArguments = [];
                operationLocations = [];
            }
            if (labelOffsets === undefined) {
                markLabel(defineLabel());
            }
            var operationIndex = operations.length;
            operations[operationIndex] = code;
            operationArguments[operationIndex] = args;
            operationLocations[operationIndex] = location;
        }
        function build() {
            blockIndex = 0;
            labelNumber = 0;
            labelNumbers = undefined;
            lastOperationWasAbrupt = false;
            lastOperationWasCompletion = false;
            clauses = undefined;
            statements = undefined;
            exceptionBlockStack = undefined;
            currentExceptionBlock = undefined;
            withBlockStack = undefined;
            var buildResult = buildStatements();
            return createGeneratorHelper(context, ts.setEmitFlags(ts.createFunctionExpression(undefined, undefined, undefined, undefined, [ts.createParameter(undefined, undefined, undefined, state)], undefined, ts.createBlock(buildResult, buildResult.length > 0)), 524288));
        }
        function buildStatements() {
            if (operations) {
                for (var operationIndex = 0; operationIndex < operations.length; operationIndex++) {
                    writeOperation(operationIndex);
                }
                flushFinalLabel(operations.length);
            }
            else {
                flushFinalLabel(0);
            }
            if (clauses) {
                var labelExpression = ts.createPropertyAccess(state, "label");
                var switchStatement = ts.createSwitch(labelExpression, ts.createCaseBlock(clauses));
                switchStatement.startsOnNewLine = true;
                return [switchStatement];
            }
            if (statements) {
                return statements;
            }
            return [];
        }
        function flushLabel() {
            if (!statements) {
                return;
            }
            appendLabel(!lastOperationWasAbrupt);
            lastOperationWasAbrupt = false;
            lastOperationWasCompletion = false;
            labelNumber++;
        }
        function flushFinalLabel(operationIndex) {
            if (isFinalLabelReachable(operationIndex)) {
                tryEnterLabel(operationIndex);
                withBlockStack = undefined;
                writeReturn(undefined, undefined);
            }
            if (statements && clauses) {
                appendLabel(false);
            }
            updateLabelExpressions();
        }
        function isFinalLabelReachable(operationIndex) {
            if (!lastOperationWasCompletion) {
                return true;
            }
            if (!labelOffsets || !labelExpressions) {
                return false;
            }
            for (var label = 0; label < labelOffsets.length; label++) {
                if (labelOffsets[label] === operationIndex && labelExpressions[label]) {
                    return true;
                }
            }
            return false;
        }
        function appendLabel(markLabelEnd) {
            if (!clauses) {
                clauses = [];
            }
            if (statements) {
                if (withBlockStack) {
                    for (var i = withBlockStack.length - 1; i >= 0; i--) {
                        var withBlock = withBlockStack[i];
                        statements = [ts.createWith(withBlock.expression, ts.createBlock(statements))];
                    }
                }
                if (currentExceptionBlock) {
                    var startLabel = currentExceptionBlock.startLabel, catchLabel = currentExceptionBlock.catchLabel, finallyLabel = currentExceptionBlock.finallyLabel, endLabel = currentExceptionBlock.endLabel;
                    statements.unshift(ts.createStatement(ts.createCall(ts.createPropertyAccess(ts.createPropertyAccess(state, "trys"), "push"), undefined, [
                        ts.createArrayLiteral([
                            createLabel(startLabel),
                            createLabel(catchLabel),
                            createLabel(finallyLabel),
                            createLabel(endLabel)
                        ])
                    ])));
                    currentExceptionBlock = undefined;
                }
                if (markLabelEnd) {
                    statements.push(ts.createStatement(ts.createAssignment(ts.createPropertyAccess(state, "label"), ts.createLiteral(labelNumber + 1))));
                }
            }
            clauses.push(ts.createCaseClause(ts.createLiteral(labelNumber), statements || []));
            statements = undefined;
        }
        function tryEnterLabel(operationIndex) {
            if (!labelOffsets) {
                return;
            }
            for (var label = 0; label < labelOffsets.length; label++) {
                if (labelOffsets[label] === operationIndex) {
                    flushLabel();
                    if (labelNumbers === undefined) {
                        labelNumbers = [];
                    }
                    if (labelNumbers[labelNumber] === undefined) {
                        labelNumbers[labelNumber] = [label];
                    }
                    else {
                        labelNumbers[labelNumber].push(label);
                    }
                }
            }
        }
        function updateLabelExpressions() {
            if (labelExpressions !== undefined && labelNumbers !== undefined) {
                for (var labelNumber_1 = 0; labelNumber_1 < labelNumbers.length; labelNumber_1++) {
                    var labels = labelNumbers[labelNumber_1];
                    if (labels !== undefined) {
                        for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
                            var label = labels_1[_i];
                            var expressions = labelExpressions[label];
                            if (expressions !== undefined) {
                                for (var _a = 0, expressions_1 = expressions; _a < expressions_1.length; _a++) {
                                    var expression = expressions_1[_a];
                                    expression.text = String(labelNumber_1);
                                }
                            }
                        }
                    }
                }
            }
        }
        function tryEnterOrLeaveBlock(operationIndex) {
            if (blocks) {
                for (; blockIndex < blockActions.length && blockOffsets[blockIndex] <= operationIndex; blockIndex++) {
                    var block = blocks[blockIndex];
                    var blockAction = blockActions[blockIndex];
                    if 